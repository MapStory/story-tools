!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var o;"undefined"!=typeof window?o=window:"undefined"!=typeof global?o=global:"undefined"!=typeof self&&(o=self),(o.storytools||(o.storytools={})).core=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
exports.time = require('./time/controls');
exports.maps = require('./time/maps');
exports.maps.pins = require('./time/pins');
exports.maps.boxes = require('./time/boxes');
exports.utils = require('./time/utils');

},{"./time/boxes":2,"./time/controls":3,"./time/maps":5,"./time/pins":7,"./time/utils":9}],2:[function(require,module,exports){
var utils = require('./utils');

function Box(options) {
    this.range = options.range || null;
    this.data = options.data || null;
    this.layerIds = options.layerIds || null;
    this.center = options.center || null; // ol.Coordinate
    this.resolution = options.resolution || null;
    this.allowPan = options.allowPan;
    this.allowZoom = options.allowZoom;
    this.speed = options.speed;  // interval, seconds
    this.title = options.title || '';
    this.id = options.id || new Date().getUTCMilliseconds();
    this.zoom = options.zoom || null;
    this._offset = 0;
    if (this.range === null) {
        if(this.data) {
            this.range = utils.createRange(this.data[0], this.data[this.data.length - 1]);
        }else{
            this.range = utils.createRange(options.start_time, options.end_time);
        }
    }
    // @todo possible divide by zero if speed.interval not set!
    this._steps = this.data === null ? Math.floor(this.range.width() / this.speed.interval) + 1: this.data.length;
}
Box.prototype.getSteps = function() {
    return this._steps;
};
Box.prototype.getRange = function() {
    return this.range;
};
Box.prototype.getIndex = function(instant) {
    return this.data ? utils.find(this.data, instant) :
        Math.floor(Math.min(this.range.width(), Math.max(0, instant - this.range.start)) / this.speed.interval);
};
Box.prototype.getDate = function(idx) {
    idx = idx - this._offset;
    return this.data ? this.data[idx] : this.range.start + (idx * this.speed.interval);
};


function getTime(props, prop) {
    var val = props[prop];
    if (typeof val != 'undefined') {
        return val *= 1000;
    }
    return null;
}

/**
 * Load Box from geojson, reprojecting from 4326 to the provided
 * projection.
 * @param {Object} geojson
 * @param {String} projection
 * @returns array of Box features
 */
exports.loadFromGeoJSON = function(geojson, projection) {
    if (projection) {
        projection = ol.proj.get(projection);
    }
    return geojson.features.map(function(f) {
        var props = f.properties;
        //props.the_geom = f.geometry;
        props.id = f.id;
        props.start_time = getTime(props, 'start_time');
        props.end_time = getTime(props, 'end_time');
        return new Box(props, projection);
    });
};

function findBox(boxes, idx) {
    var i, ii;
    var box;
    for (i = 0, ii = boxes.length; i < ii; i++) {
        box = boxes[i];
        if (idx >= box._offset) {
            if (i + 1 < ii) {
                if (idx < boxes[i + 1]._offset) {
                    break;
                }
            } else {
                break;
            }
        }
    }
    return box;
}

exports.BoxModel = function(boxArray) {
    var boxes,
        range,
        steps;
    function updateBoxes(neu) {
        var offset = 0;
        boxes = neu.map(function(b) {
            var box = new Box(b);
            box._offset = offset;
            offset += box.getSteps();
            return box;
        });
        range = utils.computeRange(boxes, 'range');
        steps = offset;
    }
    updateBoxes(boxArray);
    this.getRange = function() {
        return range;
    };
    this.getSteps = function() {
        return steps;
    };
    this.getRangeAt = function(s, e) {
        var start = findBox(boxes, s);
        var end = findBox(boxes, e);
        return utils.createRange(start.getDate(s), end.getDate(e));
    };
    this.getIndex = function(instant) {
        var idx = 0, i;
        if (instant < boxes[0].getRange().start) {
            return 0;
        }
        for (i = 0; i < boxes.length; i++) {
            var box = boxes[i];
            var range = box.getRange();
            if (instant >= range.start && instant <= range.end) {
                idx += box.getIndex(instant);
                break;
            } else {
                idx += box.getSteps();
            }
        }
        return idx;
    };
    this.setRange = function(newRange) {
        if (boxes.length == 1) {
            // @todo support for range
            if (utils.isRangeLike(newRange)) {
                throw new Error('not supported yet');
            }
            boxes[0].data = newRange;
            // @todo must set here or constructor is dumb and doesn't recompute
            boxes[0].range = utils.computeRange(newRange);
        } else {
            // @todo finish
            console.log('more than one story box to update range with!');
        }
        updateBoxes(boxes);
    };
    this.update = function(options) {

    };
};

exports.findBox = findBox;
exports.Box = Box;

},{"./utils":9}],3:[function(require,module,exports){
var utils = require('./utils');
var models = require('./models');
var timeslider = require('./slider');
var line = require('./line');
var maps = require('./maps');

/**
 * Facade object and guts of slider/timeline/playback logic.
 *
 * Since playback is driven by a timeout, all other potential events
 * are fired in an async manner to ensure a uniform API.
 */
function TimeController(model, slider, timeline, controls) {
    this.model = model;
    this.slider = slider;
    this.timeline = timeline;
    this.loop = 'none';

    var self = this,
        currentTimelineWindow = getTimelineWindow(),
        isAdjusting = false,
        started = false,
        timeout = null,
        events = new utils.Events(),
        deferred = [];

    function getTimelineWindow() {
        return utils.createRange(timeline.getWindow());
    }

    function adjust(fun, a, b) {
        if (isAdjusting) {
            return;
        }
        isAdjusting = true;
        try {
            fun(a, b);
        } finally {
            isAdjusting = false;
        }
    }

    function centerTimeline(range) {
        var c = model.mode === 'cumulative' ? range.end : range.center();
        timeline.moveTo(c);
        publishRangeChange(range);
    }

    function adjustSlider(range) {
        if (timeline.isWindowMax()) {
            return;
        }

        var center = range.center();
        var idx = model.getIndex(center);
        if (model.mode === 'cumulative') {
            slider.growTo(idx);
        } else {
            slider.center(idx);
        }
        timeline.setTime(center);
        publishRangeChange(slider.getRange());
    }

    function updateSlider(range) {
        if (utils.rangesEqual(range, currentTimelineWindow)) {
            return;
        }
        range = utils.createRange(range);
        // zoom or scroll event?
        if (range.width() !== currentTimelineWindow.width()) {
            timeline.moveToCurrentTime();
        } else {
            adjustSlider(range);
        }
        currentTimelineWindow = range;
    }

    slider.on('rangeChanged', function(range) {
        clearTimeout();
        adjust(centerTimeline, range);
        schedule();
    });
    timeline.on('rangechanged', function(range) {
        adjust(updateSlider, range);
    });
    timeline.on('select', function(properties) {
        console.log("Selected items: ", properties.items);
    });
    function clearTimeout() {
        if (timeout !== null) {
            window.clearTimeout(timeout);
        }
        timeout = null;
    }

    function move(amt) {
        timeout = null;
        var atEnd;
        if (model.mode === 'cumulative') {
            atEnd = slider.grow(amt);
        } else {
            atEnd = slider.move(amt);
        }
        if (atEnd) {
            if (self.loop === 'chapter') {
                slider.jump(0);
            } else if (self.loop === 'story') {
              var currentChapter = window.location.hash.split("/")[2];
              var nextChapter = currentChapter === undefined || currentChapter === null ? 2 : parseInt(currentChapter) + 1;
              if(nextChapter <= controls.chapterCount) {
                  console.log("Going to Chapter ", nextChapter);
                  window.location.href = '#/chapter/' + nextChapter;
                  slider.jump(0);
              } else {
                console.log("Going to Chapter 1");
                window.location.href = '#/chapter/1';
                slider.jump(0);
              }
            } else {
              self.stop();
            }
        }
        centerTimeline(slider.getRange());
        if (started) {
            schedule();
        }
    }

    function schedule() {
        if (started) {
            // @todo respect playback interval options...
            var wait = model.interval;
            $.when.apply($, deferred).then(function() {
                if (started) {
                    timeout = window.setTimeout(move, wait, 1);
                }
            }, function() {
                // the deferred was rejected, if arguments provided, this
                // represents an error state so don't continue playing
                if (arguments.length === 0 && started && timeout === null) {
                    timeout = window.setTimeout(move, wait, 1);
                } else {
                    self.stop();
                }
            });
            deferred = [];
        }
    }

    function run() {
        publishStateChange("running");
        move(1);
    }

    function publishRangeChange(data) {
        if (typeof data === 'undefined') {
            data = slider.getRange();
        }
        publish("rangeChange", data);
    }

    function publishStateChange(state) {
        publish("stateChange", state);
    }

    function publish(event, data) {
        events.event(event).publish(data);
    }

    this.defer = function(defer) {
        deferred.push(defer);
    };
    this.getCurrentRange = function() {
        return slider.getRange();
    };
    this.update = function(options) {
        model.update(options);
        slider.update(model);
        timeline.update(model);
        window.setTimeout(publishRangeChange, 0);
    };
    this.start = function() {
        if (started) {
            return;
        }
        deferred = [];
        started = true;
        window.setTimeout(run, 0);
    };
    this.stop = function() {
        deferred = [];
        started = false;
        clearTimeout();
        window.setTimeout(publishStateChange, 0, 'stopped');
    };
    this.next = function() {
        clearTimeout();
        window.setTimeout(move, 0, 1);
    };
    this.prev = function() {
        clearTimeout();
        window.setTimeout(move, 0, -1);
    };
    this.isStarted = function() {
        return started;
    };
    this.isReady = function() {
        var r = model.getRange();
        return r.start !== null && r.end !== null;
    };
    this.on = function(event, f) {
        events.event(event).subscribe(f);
    };
}

/**
 * annotation model:
 * title
 * content
 * the_geom
 * start_time
 * end_time
 * in_timeline
 * in_map
 * appearance
 */
function Annotations(annotations) {
    var ann = annotations || [];
    function inTimeline() {
        return ann.filter(function(a) {
            return a.in_timeline;
        });
    }
    this.getTimeLineAnnotatons = function() {
        return inTimeline(true);
    };
    this.update = function(annotations) {
        this.ann = annotations;
    };
}

/**
 * box model:
 * title
 * content
 * the_geom
 * start_time
 * end_time
 * in_timeline
 * in_map
 * appearance
 */
function Boxes(boxes) {
    var box = boxes || [];
    function inTimeline() {
        return box.filter(function(b) {
            return true;//b.in_timeline;
        });
    }
    this.getTimeLineBoxes = function() {
        return inTimeline(true);
    };
    this.update = function(boxes) {
        this.box = boxes;
    };
}


/**
 * common lingo:
 * instant: a single point in time
 * extent, range: has property start and end
 * start, end: long values representing UTC (internal) but generally,
 *             a date
 * interval: multipier * precision
 * precision: tick, second, minute, hour, day, week, month, year
 *            note: tick implies a multipier of 1
 * speed: object with property seconds (framerate) and optional interval
 *
 * options = {
 *   annotations: [ {
 *      title,
 *      content,
 *      the_geom,
 *      start_time,
 *      end_time,
 *      in_timeline,
 *      in_map,
 *      appearance
 *      } ... ],
 *   map: ol.Map,
 *   boxes : [ {
 *      range : {
 *          start, end
 *      },
 *      center: ol.Coordinate,
 *      resolution: float,
 *      static: boolean,
 *      speed: { interval, seconds }
 *      } ... ],
 *   data : [ date ...] | rangeWithInterval,
 *   playback : {
 *      mode: instant | range | cumulative,
 *      fixed: boolean
 *   },
 *   timeLineId : element id,
 *   timeSliderId : element id,
 *   controlsId: element id
 *
 * }
 */
function create(options) {
    // @todo for layers, annotations won't exist and, intially, we won't
    //       have playback settings for layers...
    var model,
        annotations = new Annotations(options.annotations),
        boxes = options.boxes,
        controls = {'chapterCount': options.chapterCount},
        totalRange,
        slider,
        timeline,
        mapController;
    options.boxy = new Boxes(options.boxes);
    // make a default box if none provided
    if (typeof boxes == 'undefined' || boxes.length === 0) {
        var interval = 0, data = null;
        if (Array.isArray(options.data)) {
            data = options.data;
            totalRange = utils.computeRange(options.data);
        } else {
            interval = options.data.interval || utils.pickInterval(options.data);
            totalRange = options.data;
        }
        boxes = [{
                data: data,
                range: totalRange,
                speed: {
                    interval: interval,
                    seconds: 3
                }
            }];
    }

    model = new models.TimeModel(options, boxes, annotations);
    slider = new timeslider.TimeSlider(options.timeSliderId || 'slider', model);
    timeline = new line.TimeLine(options.timeLineId || 'timeline', model);

    var timeControls = new TimeController(model, slider, timeline, controls);
    mapController = new maps.MapController(options, timeControls);
    return timeControls;
}

exports.create = create;
exports.maps = maps;
exports.utils = utils;

},{"./line":4,"./maps":5,"./models":6,"./slider":8,"./utils":9}],4:[function(require,module,exports){
var Timeline = require('vis/lib/timeline/Timeline');
var utils = require('./utils');

/**
 * Display annotations or other temporal instant/extent. Allow adjusting
 * time (either instant or extent) by dragging.
 * @param {type} id
 * @param {type} model
 * @returns {_L1.TimeLine}
 */
exports.TimeLine = function(id, model) {
    var dom = $("#" + id);
    var timeline = null;
    // @revisit - internally the timeline seems to apply the offset when
    //            creating a tool tip, does this cause problems elsewhere?
    var offset = new Date().getTimezoneOffset() * 60 * 1000;

    function init(model) {
        var elements = [], layer_groups = [], groups = [], options;
        var story_pin_label = 'Annotation';
        var range = model.getRange();
        if (range.isEmpty()) {
            range = utils.createRange(Date.now());
        }
        elements = model.annotations.getTimeLineAnnotatons().map(function(ann, i) {
            /*jshint eqnull:true */
            var start = ann.start_time != null ? ann.start_time : range.start;
            var end = ann.end_time != null ? ann.end_time : range.end;
            var type = start === end ? 'box' : 'range';
            return {
                id: utils.sha1('annotation' + ann.id + i),
                start: start,
                end: end,
                content: ann.content || ann.title,
                title: ann.title,
                type: type,
                group: story_pin_label
            };
        });

        // Add the Group we there are elements.
        if(elements.length > 0){
            groups.push({id: story_pin_label, title: story_pin_label, time: []});
        }

        if (model.boxy.box) {
            var box_elements = model.boxy.box.map(function(box, i) {
                /*jshint eqnull:true */
                var start = box.range != null ? box.range.start : range.start;
                var end = box.range != null ? box.range.end : range.end;
                var type = 'background';
                return {
                    id: utils.sha1('box' + box.id),
                    start: start,
                    end: end,
                    content: box.content || box.title,
                    type: type
                };
            });
            elements = elements.concat(box_elements);
        }


        layer_groups = $.map(model.storyLayers, function(lyr, i) {
            var id = lyr.get('id');
            var title = lyr.get('title');
            var times = lyr.get('times') || [];
            var group = null;

            if (times.length > 0) {
                if (times.length > 1500) {
                    elements.push({
                        id: utils.sha1(id),
                        group: id,
                        content: "",
                        start: times[0],
                        end: times[times.length - 1],
                        type: 'range'
                    });
                } else {
                    for (var j = 0; j < times.length; j++) {
                        var time = times[j];
                        elements.push({
                            id: utils.sha1(id + time + Date()),
                            group: id,
                            content: "",
                            start: time,
                            type: 'box'
                        });
                    }
                }
                group = {
                id: id,
                content: title
            };

            }
            return group;
        });

        groups = groups.concat(layer_groups);

        if(elements.length > 5000){
            console.debug("%s elements is too large for the timeline to render performant, no worries we will take care of it.", elements.length);
            elements = [];

        }

        console.debug("Building the timeline from %s to %s with %s elements and %s groups.",
              new Date(range.start).toISOString(),
              new Date(range.end).toISOString(),
              elements.length,
              groups.length);

        var height = $( document ).height() * 0.35;

        options = {
            min: range.start,
            max: range.end,
            start: range.start,
            end: range.end,
            height: (height < 300)? 138: height,
            maxHeight: 400,
            showCurrentTime: false
        };
        if (timeline === null) {
            timeline = new Timeline(dom.get(0), elements, options);
            timeline.setGroups(groups);
            timeline.setCurrentTime(range.start);
            timeline.addCustomTime();
        } else {
            timeline.setOptions(options);
            timeline.setItems(elements);
            timeline.setGroups(groups);
        }
    }
    init(model);

    // updates from user dragging customtime bar
    // @todo will not update slider currently at min timeline zoom as it
    // is difficult to determine whether an event is from zooming or dragging
    // need to wrap event handling to better differentiate
    timeline.on('timechanged', function() {
        timeline.moveTo(timeline.getCustomTime(), {animate: false});
    });

    this.moveTo = function(time) {
        timeline.moveTo(time, {animate: false});
        this.setTime(time);
    };
    this.setTime = function(time) {
        timeline.setCustomTime(time + offset);
    };
    this.isWindowMax = function() {
        return utils.rangesEqual(timeline.getWindow(), model.getRange());
    };
    this.moveToCurrentTime = function() {
        var current = timeline.getCustomTime().getTime();
        var width = utils.createRange(timeline.getWindow()).width();
        var range = model.getRange();
        if (current === range.start) {
            timeline.setWindow(range.start, range.start + width, {animate: false});
        } else if (current === range.end) {
            timeline.setWindow(range.end - width, range.end, {animate: false});
        } else {
            timeline.moveTo(current, {animate: false});
        }
    };
    this.getWindow = function() {
        return timeline.getWindow();
    };
    this.on = function(ev, cb) {
        timeline.on(ev, cb);
    };
    this.update = init;
    // @todo detect click or dblclick event and position based on % of total width
};

},{"./utils":9,"vis/lib/timeline/Timeline":31}],5:[function(require,module,exports){
/*jshint loopfunc: true */
var utils = require('./utils');
var moment = require('moment');

/**
 * Read the provide ol3 WMS capabilities document
 * @param {type} caps
 * @returns an object of name->[date|interval]|interval-range mappings
 */
exports.readCapabilitiesTimeDimensions = function(caps, openlayers2) {
    var dimensions = {};
    function readRange(subparts) {
        if (subparts.length < 2) {
            throw new Error('expected 2 parts for range : ' + subparts);
        }
        var range = utils.createRange(subparts[0], subparts[1]);
        if (subparts.length == 3) {
            range.duration = subparts[2];
            range = new utils.Interval(range);
        }
        return range;
    }
    function readPart(part) {
        var subparts = part.split('/');
        if (subparts.length == 1) {
            return utils.getTime(subparts[0]);
        } else {
            return readRange(subparts);
        }
    }
    function parse(dimension) {
        var dims = openlayers2 ? dimension : dimension.split(',');
        if (dims.length == 1) {
            var read = readPart(dims[0]);
            return typeof read === 'number' ? [read] : read;
        }
        return dims.map(readPart);
    }
    if (openlayers2 === true) {
        if (caps.dimensions && caps.dimensions.time) {
            dimensions = parse(caps.dimensions.time.values);
        } else {
            dimensions = undefined;
        }
    } else {
        // @todo need to make layer scanning recursive?
        caps.value.capability.layer.layer.forEach(function(lyr) {
          for (var i = 0; i < lyr.dimension.length; i ++) {
            if (lyr.dimension[i] && lyr.dimension[i].name && lyr.dimension[i].name === 'time') {
              dimensions[lyr.name] = parse(lyr.dimension[i].value);
            }
          }
        });
    }
    return dimensions;
};

function TileLoadListener(tileStatusCallback) {
    var tilesLoading = {};
    var deferred = $.Deferred(),
          cancelled = false;
    function remainingTiles() {
        var t = 0;
        for (var i in tilesLoading) {
            t += tilesLoading[i];
        }
        return t;
    }
    var listener = {
        deferred: deferred,
        cancel: function() {
            cancelled = true;
            for (var s in tilesLoading) {
                tilesLoading[s] = 0;
            }
            if (deferred) {
                deferred.reject(); // notify we've aborted but w/out error
            }
            if (tileStatusCallback) {
                tileStatusCallback(0);
            }
        },
        tileQueued: function(source) {
            if (cancelled) {
                return;
            }
            var key;
            if (source instanceof ol.source.TileWMS) {
                key = source.getUrls()[0];
            } else if (source instanceof ol.source.ImageWMS) {
                key = source.getUrl();
            }
            tilesLoading[key] = (tilesLoading[key] || 0) + 1;
            if (tileStatusCallback) {
                tileStatusCallback(remainingTiles());
            }
        },
        tileLoaded: function(event, source) {
            if (cancelled) {
                return;
            }
            var key;
            if (source instanceof ol.source.TileWMS) {
                key = source.getUrls()[0];
            } else if (source instanceof ol.source.ImageWMS) {
                key = source.getUrl();
            }
            tilesLoading[key] -= 1;
            var remaining = remainingTiles();
            if (tileStatusCallback) {
                tileStatusCallback(remaining);
            }
            if (remaining === 0 && deferred) {
                deferred.resolve();
            }
        }
    };
    // workaround for when the tiles are cached and no events are triggered
    // this adds a constant (small) additional delay to the current play rate
    // under optimal (cached) conditions
    // @todo can this safely be shortened?
    window.setTimeout(function() {
        if (Object.keys(tilesLoading).length === 0) {
            listener.cancel();
        }
    },100);
    return listener;
}

function filterVectorLayer(storyLayer, range) {
    var timeAttr = storyLayer.get('timeAttribute'), l_features = storyLayer.get('features') || storyLayer.getLayer().get('features');
    if (timeAttr === undefined || l_features === undefined) {
        return;
    }
    range = utils.createRange(range);
    // loop over all original features and filter them
    var features = [];
    var layer = storyLayer.getLayer();
    visitAllLayerFeatureTimes(storyLayer, function(f,r) {
        if (range.intersects(r)) {
            features.push(f);
        }
    }, l_features);
    layer.getSource().clear(true);
    layer.getSource().addFeatures(features);
    return features;
}


function filterVectorBoxLayer(storyLayer, range) {
    var timeAttr = storyLayer.get('timeAttribute'), l_features = storyLayer.get('features');
    if (timeAttr === undefined || l_features === undefined) {
        return;
    }
    range = utils.createRange(range);
    // loop over all original features and filter them
    var features = [];
    visitAllLayerFeatureTimes(storyLayer, function(f,r) {
        if (range.intersects(r)) {
            features.push(f);
        }
    });

    return features;
}
/**
 * Call the provided visitor function on the specified features using the
 * configuration provided in the layer. The visitor function will be called
 * with the feature, and start and end time, if any. The features visited will
 * be, in order of priority: the provided (optional) features argument, the
 * layer property 'features', the layer's source features.
 * @param {StoryLayer} story layer
 * @param {function} visitor function(feature, start, end)
 * @param {array} features (opitonal)
 */
function visitAllLayerFeatureTimes(storyLayer, visitor, features) {
    var startAtt = storyLayer.get('timeAttribute');
    var endAtt = storyLayer.get('endTimeAttribute');
    var rangeGetter;
    var layer = storyLayer.getLayer();
    features = features || storyLayer.get('features') || layer.getSource().getFeatures();
    if (endAtt) {
        rangeGetter = function(f) {
            if(f.range){
                return f.range;
            }else {
                var start = f.get(startAtt);
                var end = f.get(endAtt);
                return utils.createRange(start, end);
            }
        };
    } else {
        rangeGetter = function(f) {
            if(f.range){
                return f.range;
            }else {
                var start = f.get(startAtt);
                return utils.createRange(start, start);
            }
        };
    }
    utils.visitRanges(features, rangeGetter, visitor);
}

/**
 * Compute the range of the provided features using the layer's configured
 * timeattributes. If the optional features array is omitted, the features
 * will come from the layer.
 * @param {StoryLayer} storyLayer
 * @param {array} features (optional)
 * @returns {storytools.core.time.Range} range of features
 */
exports.computeVectorRange = function(storyLayer, features) {
    var startAtt = storyLayer.get('timeAttribute');
    var endAtt = storyLayer.get('endTimeAttribute');
    var layer = storyLayer.getLayer();
    features = features || storyLayer.get('features') || layer.getSource().getFeatures();
    return utils.computeRange(features, function(f) {
        return utils.createRange(f.get(startAtt), f.get(endAtt));
    });
};

exports.filterVectorLayer = filterVectorLayer;
exports.filterVectorBoxLayer = filterVectorBoxLayer;

exports.MapController = function(options, timeControls) {
    var loadListener = null,
          tileStatusCallback = options.tileStatusCallback,
          storyMap = options.storyMap;
    function layerAdded(layer) {
        var source, image;
        var loaded = function(event) {
            // grab the active loadListener to avoid phantom onloads
            // when listener is cancelled
            var currentListener = loadListener;
            if (currentListener) {
                currentListener.tileLoaded(event, source);
            }
        };
        var loadstart = function() {
            // grab the active loadListener to avoid phantom onloads
            // when listener is cancelled
            var currentListener = loadListener;
            if (currentListener) {
                currentListener.tileQueued(source);
            }
        };
        if (layer instanceof ol.layer.Tile && layer.getSource() instanceof ol.source.TileWMS) {
            source = layer.getSource();
            source.on('tileloadstart', loadstart);
            source.on('tileloadend', loaded);
            // @todo handle onerror and cancel deferred with an example
            // to stop automatic playback
            source.on('tileloaderror', loaded);
        } else if (layer instanceof ol.layer.Image && layer.getSource() instanceof ol.source.ImageWMS) {
            source = layer.getSource();
            source.on('imageloadstart', loadstart);
            source.on('imageloadend', loaded);
            source.on('imageloaderror', loaded);
        }
    }
    function createLoadListener() {
        if (loadListener !== null) {
            loadListener.cancel();
        }
        loadListener = new TileLoadListener(tileStatusCallback);
        return loadListener;
    }

    function updateCenterAndZoom(range){
        var currentBoxes = filterVectorBoxLayer(storyMap.storyBoxesLayer, range);
        var currentPinFeatures = filterVectorLayer(storyMap.storyPinsLayer, range);

        if (currentPinFeatures && currentPinFeatures.length > 0) {
          return;
        } else if (currentBoxes && currentBoxes.length > 0) {
            var currentBox = currentBoxes[0];

            if (currentBox.center) {
                storyMap.animateCenterAndZoom(currentBox.center, currentBox.zoom);
            }
        } else {
            if (storyMap.returnToExtent) {
               storyMap.animateCenterAndZoom(storyMap.getCenter(), storyMap.getZoom());
            }
        }
    }

    function updateLayers(range) {
        var storyLayers = storyMap.getStoryLayers();
        var time = new Date(range.start).toISOString();
        if (range.start != range.end) {
            time += "/" + new Date(range.end).toISOString();
        }
        for (var i = 0; i < storyLayers.getLength(); i++) {
            var storyLayer = storyLayers.item(i), layer = storyLayer.getLayer();
            if ((layer instanceof ol.layer.Tile && layer.getSource() instanceof ol.source.TileWMS) ||
                  (layer instanceof ol.layer.Image && layer.getSource() instanceof ol.source.ImageWMS)) {
                if (storyLayer.get('times')) {
                    layer.getSource().updateParams({TIME: time});
                }
            } else if (layer instanceof ol.layer.Vector) {
                filterVectorLayer(storyLayer, range);
            }
        }
        // this is a non-story layer - not part of the main collection
        filterVectorLayer(storyMap.storyPinsLayer, range);
        if (storyLayers.getLength() >= 1) {
            timeControls.defer(createLoadListener().deferred);
        }
    }
    var me = this;
    me.layers = {};
    storyMap.getStoryLayers().on('add', function(ev) {
        var lyr = ev.element, id = lyr.get('id');
        if (me.layers[id] !== true) {
            layerAdded(lyr.getLayer());
            me.layers[id] = true;
        }
    });
    storyMap.getStoryLayers().forEach(function(lyr) {
        var id = lyr.get('id');
        if (id !== undefined && me.layers[id] !== true) {
            layerAdded(lyr.getLayer());
            me.layers[id] = true;
        }
    });
    timeControls.on('rangeChange', updateCenterAndZoom);
    timeControls.on('rangeChange', updateLayers);
};

},{"./utils":9,"moment":13}],6:[function(require,module,exports){
var utils = require('./utils');
var BoxModel = require('./boxes').BoxModel;

/**
 * @todo document me
 */
exports.TimeModel = function(options, boxes, annotations) {
    
    var events = new utils.Events(),
        boxModel = new BoxModel(boxes);

    this.annotations = annotations;
    this.boxes = boxes;
    this.boxy = options.boxy;
    this.storyLayers = [];
    this.fixed = false;
    this.mode = 'instant';
    this.interval = 1000;

    function init(opts) {
        if (opts.hasOwnProperty('fixed')) {
            this.fixed = opts.fixed;
        }

        if (opts.hasOwnProperty('speed') && opts.speed !== undefined) {
            this.interval = opts.speed;
        }

        if (opts.hasOwnProperty('mode') && opts.mode !== undefined) {
            this.mode = opts.mode;
        }
        if (opts.hasOwnProperty('annotations')) {
            this.annotations.update(opts.annotations);
        }
        if (opts.hasOwnProperty('boxes')) {
            this.boxy.update(opts.boxes);
        }

        if (opts.hasOwnProperty('storyLayers')) {
            this.storyLayers = opts.storyLayers;
        }

        // @todo is the best name for this
        if (opts.hasOwnProperty('data')) {
            boxModel.setRange(opts.data);
        }
    }

    init.call(this, options);
    this.getRange = function() {
        return boxModel.getRange();
    };
    this.getTotalRange = function() {
        // @todo need to access layers and cached dimension data
        //       and consider annotations?
        throw Error('not implemented');
    };
    this.update = init;
    this.getSteps = function() {
        return boxModel.getSteps();
    };
    this.getIndex = function(instant) {
        return boxModel.getIndex(instant);
    };
    this.getRangeAt = function(i, j) {
        return boxModel.getRangeAt(i, j);
    };
};

},{"./boxes":2,"./utils":9}],7:[function(require,module,exports){
var format = new ol.format.GeoJSON();


var StoryPin = function(data, projection) {
    ol.Feature.call(this, data);
    if (data) {
        if (data.the_geom) {
            var geom = data.the_geom;
            if (typeof geom === 'string' || 'type' in geom) {
                geom = format.readGeometry(geom, {
                    featureProjection: projection
                });
            }
            this.setGeometry(geom);
            delete data.the_geom;
        }
        this.setId(data.id);
    }
};
StoryPin.prototype = Object.create(ol.Feature.prototype);
StoryPin.prototype.constructor = StoryPin;
// expose these simply for the timeline - it doesn't know they're features
['id','start_time','end_time','content','title','in_timeline','in_map', 'auto_show', 'pause_playback'].forEach(function(prop) {
    Object.defineProperty(StoryPin.prototype, prop, {
        get: function() {
            var val = this.get(prop);
            return typeof val === 'undefined' ? null : val;
        },
        set: function(val) {
            this.set(prop, val);
        }
    });
});

/*
 var start = ann.start_time != null ? ann.start_time : range.start;
 var end = ann.end_time != null ? ann.end_time : range.end;
 var type = start === end ? 'box' : 'range';
 return {
 id: ann.id,
 start: start,
 end: end,
 content: ann.content || ann.title,
 title: ann.title,
 type: type
 };
 */

function getTime(props, prop) {
    var val = props[prop];
    if (typeof val != 'undefined') {
        return val *= 1000;
    }
    return null;
}

/**
 * Load StoryPins from geojson, reprojecting from 4326 to the provided
 * projection.
 * @param {Object} geojson
 * @param {String} projection
 * @returns array of StoryPin features
 */
exports.loadFromGeoJSON = function(geojson, projection) {
    if (projection) {
        projection = ol.proj.get(projection);
    }
    return geojson.features.map(function(f) {
        var props = f.properties;
        props.the_geom = f.geometry;
        props.id = f.id;
        props.start_time = getTime(props, 'start_time');
        props.end_time = getTime(props, 'end_time');
        return new StoryPin(props, projection);
    });
};

exports.StoryPin = StoryPin;

},{}],8:[function(require,module,exports){
var utils = require('./utils');
/**
 * Visual feedback of complete story line. Allow dragging of range, click
 * to position.
 *
 * Playback Modes
 * - fixed cumulative (min fixed at 0, max adjusts with tick)
 * - fixed range playback (range fixed, window adjusts with tick)
 * - fixed instant (like fixed range but range of 0)
 * - open range playback (fully adjustable min/max, window adjusts with tick)
 *
 * Internal model
 * - 0-N where N is either the number of instants or the total number of extents
 *
 * @param {type} id
 * @param {type} model
 * @returns {TimeSlider}
 */
exports.TimeSlider = function(id, model) {
    var slider = $("#" + id)[0];
    var events = new utils.Events();
    var initialized = false;
    var singleSlider;

    function init(model) {
        var options = {
            step: 1,
            start: [0, 0],
            animate: false,
            connect: true,
            range: {
                min: 0,
                max: model.getSteps() - 1
            },
            behaviour: 'drag-snap'
        };
        singleSlider = false;

        /*if (model.fixed) {
            // @todo need model interval
        }*/

        if (model.mode === 'cumulative') {
            singleSlider = true;
            options.connect = 'lower';
        } else if (model.mode === 'instant') {
            singleSlider = true;
            options.connect = false;
        } else if (model.mode === 'range') {
            if (model.fixed) {
                // ideally we'd support snap but it breaks fixed
                options.behaviour = 'drag-fixed';
            }
        } else {
            throw "invalid model mode : " + model.mode;
        }

        if (initialized) {
            // have to update values based on current state
            var range = getSliderRangeInternal();
            if (singleSlider) {
                options.start = range[0];
            } else {
                if (range[0] === range[1]) {
                    range[1] += 1;
                }
                options.start = range;
            }
        } else if (singleSlider) {
            options.start = 0;
        }

        if (!initialized) {
            if(slider)
            {
                noUiSlider.create(slider, options);
                slider.noUiSlider.on('slide', function (ev) {
                    var range = getRange();
                    events.event('rangeChanged').publish(range);
                });
                initialized = true;
            }
        } else {
          options.range = {
            min: 0,
            max: model.getSteps() - 1
          };
          slider.noUiSlider.updateOptions(options, true);
        }

    }

    init(model);

    function getSliderRangeInternal() {
        var range = slider.noUiSlider.get();
        if (! Array.isArray(range)) {
            range = parseInt(range, 10);
            range = [model.mode === 'cumulative' ? 0 : range, range];
        } else {
            range = range.map(function(i) { return parseInt(i, 10); });
        }
        return range;
    }

    function getRange() {
        var range = getSliderRangeInternal();
        return model.getRangeAt(range[0], range[1]);
    }

    function width() {
        var range = getSliderRangeInternal();
        return range[1] - range[0];
    }

    function isAtEnd(left) {
        var range = getSliderRangeInternal();
        if (left) {
            return range[0] === 0;
        }
        return range[1] === model.getSteps()-1;
    }

    function setValue(val) {
        // normalize nouislider.val to handle array
        if (singleSlider) {
            slider.noUiSlider.set(val[1]);
        } else {
            slider.noUiSlider.set(val);
        }
    }

    this.slider = slider;
    this.on = function(event, fn) {
        if(initialized) {
            events.event(event).subscribe(fn);
        }
    };
    this.getSliderRangeInternal = getSliderRangeInternal;
    this.center = function(index) {
        var half = Math.floor(width() / 2);
        setValue([index - half, index + half]);
    };
    this.move = function(amt) {
        var vals  = getSliderRangeInternal();
        vals[0] += amt;
        vals[1] += amt;
        setValue(vals);
        return isAtEnd(amt < 0);
    };
    this.grow = function(amt) {
        var vals = getSliderRangeInternal();
        vals[1] += amt;
        setValue(vals);
        return isAtEnd(false);
    };
    this.growTo = function(where) {
        var vals = getSliderRangeInternal();
        vals[1] = where;
        setValue(vals);
        return isAtEnd(false);
    };
    this.jump = function(to) {
        setValue([to, to + width()]);
    };
    this.getRange = getRange;
    this.update = init;
};

},{"./utils":9}],9:[function(require,module,exports){
var moment = require('moment');

/**
 * Get the number of milliseconds from the provided arg.
 * @param arg - either Date, range (returns start), string or number
 * @returns milliseconds or null if nothing provided
 */
var getTime = function(arg) {
    var type = typeof arg;
    if (type === 'number') {
        return arg;
    }
    if (arg instanceof Date) {
        return arg.getTime();
    }
    if (type === 'string') {
        return parseDate(arg).getTime();
    }
    /*jshint eqnull:true */
    if (arg == null) {
        return null;
    }
    if (isRangeLike(arg)) {
        /*jshint eqnull:true */
        return getTime(arg.start != null ? arg.start : arg.end);
    }
    throw new Error('cannot call getTime with ' + type + ", : " + arg);
};

var isRangeLike = function(object) {
    /*jshint eqnull:true */
    return object != null && (object.hasOwnProperty('start') || object.hasOwnProperty('end'));
};

exports.isRangeLike = isRangeLike;

exports.createRange = function(start, end) {
    if (arguments.length === 1) {
        var other = start;
        if (isRangeLike(other)) {
            start = other.start;
            end = other.end;
        } else {
            end = start;
        }
    }
    /*jshint eqnull:true */
    if (start != null && end != null && start > end) {
        throw new Error('start > end');
    }
    return new Range(getTime(start), getTime(end));
};

exports.rangesEqual = function(a, b) {
    return getTime(a.start) === getTime(b.start) &&
        getTime(a.end) === getTime(b.end);
};

function rangeContains(range, time) {
    /*jshint eqnull:true */
    if (time == null) {
        throw new Error('invalid time argument');
    }
    /*jshint eqnull:true */
    return ((range.start != null ? time >= range.start : true) &&
           (range.end != null ? time < range.end : true)) ||
           range.start === range.end && time === range.start;
}

exports.parseISODuration = function(duration) {
    var values = exports.isoDurationToMoment(duration);
    return moment.duration(values).asMilliseconds();
};

exports.Interval = function(start, end, duration) {
    if (typeof start === 'object') {
        var opts = start;
        start = opts.start;
        end = opts.end;
        duration = opts.duration;
    }
    if (start === end) {
        throw new Error('interval should have width');
    }
    Range.call(this, start, end);
    this.duration = duration;
    this.interval = exports.parseISODuration(this.duration);
    this.offset = exports.createOffsetter(this);
};

function Range(start, end) {
    if (isNaN(start) || isNaN(end)) {
        throw new Error('invalid start and/or end');
    }
    this.start = start;
    this.end = end;
}
/**
 * extend this Range by another. This algorithm will consider an open-ended
 * range to represent a minimum of start and maximum of end.
 * @param {type} other
 * @returns {undefined}
 */
Range.prototype.extend = function(other) {
    /*jshint eqnull:true */
    if (!isRangeLike(other)) {
        other = exports.createRange(other);
    }
    var start = getTime(other.start);
    var end = getTime(other.end);
    if (start == null) {
        start = end;
    }
    if (end == null) {
        end = start;
    }
    if (start != null) {
        if (this.start == null) {
            this.start = start;
        } else {
            this.start = Math.min(this.start, start);
        }
    }
    if (end != null) {
        if (this.end == null) {
            this.end = end;
        } else {
            this.end = Math.max(this.end, end);
        }
    }
};
Range.prototype.intersects = function(other) {
    if (isRangeLike(other)) {
        /*jshint eqnull:true */
        var es = other.start == null ? Number.MIN_VALUE : other.start;
        var ee = other.end == null ? Number.MAX_VALUE : other.end;
        // intersection if (any)
        // effective end in this range
        // effective start in this range
        // effective start before and effective end after
        return rangeContains(this, es) ||
            rangeContains(this, ee) ||
            es <= this.start && ee >= this.end;
    } else {
        return rangeContains(this, getTime(other));
    }
};
Range.prototype.toString = function() {
    return new Date(this.start).toUTCString() + " : " + new Date(this.end).toUTCString();
};
Range.prototype.center = function() {
    return Math.floor(this.start + (this.end - this.start) / 2);
};
Range.prototype.width = function() {
    return this.end - this.start;
};
Range.prototype.isEmpty = function() {
    /*jshint eqnull:true */
    return this.end == null && this.start == null;
};
exports.Range = Range;



/**
 * Compute the overall range of provided args. Args may be an array of:
 * date or long, range, object with property/function yielding range for the
 * object.
 * @param {type} args
 * @returns range will have start/end even if the same time.
 */
exports.computeRange = function(args, rangeGetter) {
    var range = new Range(null, null);
    exports.visitRanges(args, rangeGetter, function(arg, r) {
        range.extend(r);
    });
    /*jshint eqnull:true */
    if (range.start == null) {
        range.start = range.end;
    }
    if (range.end == null) {
        range.end = range.start;
    }
    return range;
};

exports.visitRanges = function(objects, rangeGetter, visitor) {
    var getRange;
    if (typeof rangeGetter == 'string') {
        getRange = function(object) {
            return object[rangeGetter];
        };
    } else if (typeof rangeGetter == 'function') {
        getRange = rangeGetter;
    } else {
        getRange = function(object) {
            return isRangeLike(object) ? object : exports.createRange(object);
        };
    }
    for (var i = 0, ii = objects.length; i < ii; i++) {
        var object = objects[i];
        visitor(object, getRange(object));
    }
};

/** for the given what, find the index in the items that what is closest
 * to. items must be sorted. The lowest closest value possible is returned.
 */
exports.binarySearch = function(items, what) {
    var start = 0;
    var stop = items.length - 1;
    var mid = stop + start / 2 | 0;
    var val;
    if (what < items[0]) {
        return 0;
    }
    if (what > items[stop]) {
        return items.length - 1;
    }
    while ((val = items[mid]) !== what && start < stop) {
        if (what > val) {
            if (what < items[mid + 1]) {
                return mid;
            }
        } else if (what < val) {
            if (what > items[mid - 1]) {
                return mid - 1;
            }
            stop = mid - 1;
        }
        mid = stop + start / 2 | 0;
    }
    return mid;
};

exports.find = function(items, what) {
    if (what < items[0]) {
        return 0;
    }
    for (var i = 0, ii = items.length - 1; i < ii; i++) {
        if (what >= items[i] && what < items[i + 1]) {
            return i;
        }
    }
    return items.length - 1;
};

exports.Events = function() {
    var topics = {};

    // @todo introduce setting topics with arguments and logging/exception
    // on un-fired event

    function event(id) {
        var callbacks, method,
                topic = id && topics[ id ];
        if (!topic) {
            callbacks = jQuery.Callbacks();
            topic = {
                publish: callbacks.fire,
                subscribe: callbacks.add,
                unsubscribe: callbacks.remove
            };
            if (id) {
                topics[ id ] = topic;
            }
        }
        return topic;
    }

    return {
        event: event
    };
};

exports.pickInterval = function(range) {
    var intervals = [
        moment.duration(1, 'seconds').asMilliseconds(),
        moment.duration(1, 'minutes').asMilliseconds(),
        moment.duration(1, 'hours').asMilliseconds(),
        moment.duration(1, 'days').asMilliseconds(),
        moment.duration(1, 'weeks').asMilliseconds(),
        moment.duration(1, 'months').asMilliseconds(),
        moment.duration(1, 'years').asMilliseconds()
    ];
    return intervals[Math.max(exports.find(intervals, range.width()) - 1, 0)];
};

exports.stringToMoment = function(date, format){
    return moment(date, format);
};

exports.getTime = getTime;

/**
 * Read an iso duration into a moment.js object.
 * @param {string} duration
 * @returns {object} with moment.js info
 */
exports.isoDurationToMoment = function(duration) {
    if (duration.charAt(0) != 'P') {
        throw new Error('expected P as starting duration : ' + duration);
    }
    var pattern = /(\d+)(\w)/g;
    var date = null, time = null, values = {};
    duration = duration.substring(1);
    if (duration.indexOf('T') >= 0) {
        var parts = duration.split('T');
        date = parts[0];
        time = parts[1];
    } else {
        date = duration;
    }
    var mapping = {
        'Y': 'years',
        'M': 'months',
        'W': 'weeks',
        'D': 'days',
        'H': 'hours',
        'm': 'minutes',
        'S': 'seconds'
    };
    function parse(chunk, time) {
        function read(amount, part) {
            if (time && part == 'M') {
                part = 'm';
            }
            var mappedTo = mapping[part];
            if (typeof mappedTo == 'undefined') {
                throw Error('unknown duration specifier : ' + part);
            }
            values[mappedTo] = parseFloat(amount);
        }
        var next;
        while ((next = pattern.exec(chunk)) !== null) {
            read(next[1], next[2]);
        }
    }
    if (date !== null) {
        parse(date, false);
    }
    if (time !== null) {
        parse(time, true);
    }
    return values;
};

/**
 * Get a function for the provided duration that computes a new timestamp based on a
 * provided date and optional multiplier (negative for reverse).
 * @param {string} iso duration
 * @returns {function} offsetter(timestamp, multiplier=1)
 */
exports.createOffsetter = function(intervalOrDuration) {
    var duration = typeof intervalOrDuration === 'string' ? intervalOrDuration: intervalOrDuration.duration;
    var values = exports.isoDurationToMoment(duration);
    // as of writing, moment assumes y=365d and m=30d resulting in slow
    // day of month shifts that break ticks from matching
    // so we take care of this using a more accurate approach
    // ** the current approach breaks down if the day of month is greater than
    // 28 and day of month will no longer be retained (will shift)
    if ('years' in values || 'months' in values) {
        var years = values.years;
        var months = values.months;
        values.years = 0;
        values.months = 0;
        var millis = moment.duration(values).asMilliseconds();
        return function(ts, mult) {
            mult = mult || 1;
            var d = new Date(ts);
            /*jshint eqnull:true */
            var y = d.getUTCFullYear();
            if (years != null) {
                y += mult * years;
            }
            var m = d.getUTCMonth();
            if (months != null) {
                m += mult * months;
            }
            d.setUTCFullYear(y, m);
            return d.getTime() + (mult * millis);
        };
    } else {
        var offset = moment.duration(values).asMilliseconds();
        return function(ts, mult) {
            mult = mult || 1;
            return ts + (mult * offset);
        };
    }
};


/**
 * Contains implementations of Date.parse and date.toISOString that match the
 *     ECMAScript 5 specification for parsing RFC 3339 dates.
 *     http://tools.ietf.org/html/rfc3339
 */


/**
 * The regex to be used for validating dates. You can provide your own
 * regex for instance for adding support for years before BC. Default
 * value is: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/
 */
var dateRegEx = /^(-?)(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/;


/**
 * Generate a date object from a string.  The format for the string follows
 *     the profile of ISO 8601 for date and time on the Internet (see
 *     http://tools.ietf.org/html/rfc3339).  We don't call the native
 *     Date.parse because of inconsistency between implmentations.  In
 *     Chrome, calling Date.parse with a string that doesn't contain any
 *     indication of the timezone (e.g. "2011"), the date is interpreted
 *     in local time.  On Firefox, the assumption is UTC.
 *
 * Parameters:
 * str - {String} A string representing the date (e.g.
 *     "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z",
 *     "2010-08-07T11:58:23.123-06", "-3000-08-07T16:58:23.123Z").
 *
 * Returns:
 * {Date} A date object.  If the string could not be parsed, an invalid
 *     date is returned (i.e. isNaN(date.getTime())).
 */
parseDate = function(str) {
  var date;
  var match = str.match(dateRegEx);
  if (match && (match[2] || match[8])) { // must have at least year or time
    var year = parseInt(match[2], 10) || 0;
    if (match[1]){
      year = year * -1;
    }
    var month = (parseInt(match[3], 10) - 1) || 0;
    var day = parseInt(match[4], 10) || 1;
    date = new Date(Date.UTC(year, month, day));
    // optional time
    var type = match[8];
    if (type) {
      var hours = parseInt(match[5], 10);
      var minutes = parseInt(match[6], 10);
      var secFrac = parseFloat(match[7]);
      var seconds = secFrac | 0;
      var milliseconds = Math.round(1000 * (secFrac - seconds));
      date.setUTCHours(hours, minutes, seconds, milliseconds);
      // check offset
      if (type !== "Z") {
        var hoursOffset = parseInt(type, 10);
        var minutesOffset = parseInt(match[9], 10) || 0;
        var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);
        date = new Date(date.getTime() + offset);
      }
    }
  } else {
    date = new Date("invalid");
  }
  return date;
};


//  Secure Hash Algorithm (SHA1)
//  http://www.webtoolkit.info/

exports.sha1 = function(msg) {

  var rotate_left = function(n, s) {
    return (n << s) | (n >>> (32 - s));
  };

  var cvt_hex = function(val) {
    var str = '';
    var i;
    var v;

    for (i = 7; i >= 0; i--) {
      v = (val >>> (i * 4)) & 0x0f;
      str += v.toString(16);
    }
    return str;
  };


  var utf8Encode = function(string) {
    string = string.replace(/\r\n/g, '\n');
    var utftext = '';

    for (var n = 0; n < string.length; n++) {

      var c = string.charCodeAt(n);

      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if ((c > 127) && (c < 2048)) {
        utftext += String.fromCharCode((c >> 6) | 192);
        utftext += String.fromCharCode((c & 63) | 128);
      } else {
        utftext += String.fromCharCode((c >> 12) | 224);
        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
        utftext += String.fromCharCode((c & 63) | 128);
      }

    }
    return utftext;
  };

  var blockstart;
  var i, j;
  var W = new Array(80);
  var H0 = 0x67452301;
  var H1 = 0xEFCDAB89;
  var H2 = 0x98BADCFE;
  var H3 = 0x10325476;
  var H4 = 0xC3D2E1F0;
  var A, B, C, D, E;
  var temp;

  msg = utf8Encode(msg);

  var msg_len = msg.length;

  var word_array = [];
  for (i = 0; i < msg_len - 3; i += 4) {
    j = msg.charCodeAt(i) << 24 | msg.charCodeAt(i + 1) << 16 |
        msg.charCodeAt(i + 2) << 8 | msg.charCodeAt(i + 3);
    word_array.push(j);
  }

  switch (msg_len % 4) {
    case 0:
      i = 0x080000000;
      break;
    case 1:
      i = msg.charCodeAt(msg_len - 1) << 24 | 0x0800000;
      break;

    case 2:
      i = msg.charCodeAt(msg_len - 2) << 24 | msg.charCodeAt(msg_len - 1) << 16 | 0x08000;
      break;

    case 3:
      i = msg.charCodeAt(msg_len - 3) << 24 | msg.charCodeAt(msg_len - 2) << 16 |
          msg.charCodeAt(msg_len - 1) << 8 | 0x80;
      break;
  }

  word_array.push(i);

  while ((word_array.length % 16) != 14) {
    word_array.push(0);
  }

  word_array.push(msg_len >>> 29);
  word_array.push((msg_len << 3) & 0x0ffffffff);


  for (blockstart = 0; blockstart < word_array.length; blockstart += 16) {

    for (i = 0; i < 16; i++) {
      W[i] = word_array[blockstart + i];
    }
    for (i = 16; i <= 79; i++) {
      W[i] = rotate_left(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    }

    A = H0;
    B = H1;
    C = H2;
    D = H3;
    E = H4;

    for (i = 0; i <= 19; i++) {
      temp = (rotate_left(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    for (i = 20; i <= 39; i++) {
      temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    for (i = 40; i <= 59; i++) {
      temp = (rotate_left(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    for (i = 60; i <= 79; i++) {
      temp = (rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;
      E = D;
      D = C;
      C = rotate_left(B, 30);
      B = A;
      A = temp;
    }

    H0 = (H0 + A) & 0x0ffffffff;
    H1 = (H1 + B) & 0x0ffffffff;
    H2 = (H2 + C) & 0x0ffffffff;
    H3 = (H3 + D) & 0x0ffffffff;
    H4 = (H4 + E) & 0x0ffffffff;

  }

  var localtemp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);

  return localtemp.toLowerCase();

};

},{"moment":13}],10:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],11:[function(require,module,exports){
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof define === 'function' && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],12:[function(require,module,exports){
"use strict";
/**
 * Created by Alex on 11/6/2014.
 */

// https://github.com/umdjs/umd/blob/master/returnExports.js#L40-L60
// if the module has no dependencies, the above pattern can be simplified to
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.keycharm = factory();
  }
}(this, function () {

  function keycharm(options) {
    var preventDefault = options && options.preventDefault || false;

    var container = options && options.container || window;

    var _exportFunctions = {};
    var _bound = {keydown:{}, keyup:{}};
    var _keys = {};
    var i;

    // a - z
    for (i = 97; i <= 122; i++) {_keys[String.fromCharCode(i)] = {code:65 + (i - 97), shift: false};}
    // A - Z
    for (i = 65; i <= 90; i++) {_keys[String.fromCharCode(i)] = {code:i, shift: true};}
    // 0 - 9
    for (i = 0;  i <= 9;   i++) {_keys['' + i] = {code:48 + i, shift: false};}
    // F1 - F12
    for (i = 1;  i <= 12;   i++) {_keys['F' + i] = {code:111 + i, shift: false};}
    // num0 - num9
    for (i = 0;  i <= 9;   i++) {_keys['num' + i] = {code:96 + i, shift: false};}

    // numpad misc
    _keys['num*'] = {code:106, shift: false};
    _keys['num+'] = {code:107, shift: false};
    _keys['num-'] = {code:109, shift: false};
    _keys['num/'] = {code:111, shift: false};
    _keys['num.'] = {code:110, shift: false};
    // arrows
    _keys['left']  = {code:37, shift: false};
    _keys['up']    = {code:38, shift: false};
    _keys['right'] = {code:39, shift: false};
    _keys['down']  = {code:40, shift: false};
    // extra keys
    _keys['space'] = {code:32, shift: false};
    _keys['enter'] = {code:13, shift: false};
    _keys['shift'] = {code:16, shift: undefined};
    _keys['esc']   = {code:27, shift: false};
    _keys['backspace'] = {code:8, shift: false};
    _keys['tab']       = {code:9, shift: false};
    _keys['ctrl']      = {code:17, shift: false};
    _keys['alt']       = {code:18, shift: false};
    _keys['delete']    = {code:46, shift: false};
    _keys['pageup']    = {code:33, shift: false};
    _keys['pagedown']  = {code:34, shift: false};
    // symbols
    _keys['=']     = {code:187, shift: false};
    _keys['-']     = {code:189, shift: false};
    _keys[']']     = {code:221, shift: false};
    _keys['[']     = {code:219, shift: false};



    var down = function(event) {handleEvent(event,'keydown');};
    var up = function(event) {handleEvent(event,'keyup');};

    // handle the actualy bound key with the event
    var handleEvent = function(event,type) {
      if (_bound[type][event.keyCode] !== undefined) {
        var bound = _bound[type][event.keyCode];
        for (var i = 0; i < bound.length; i++) {
          if (bound[i].shift === undefined) {
            bound[i].fn(event);
          }
          else if (bound[i].shift == true && event.shiftKey == true) {
            bound[i].fn(event);
          }
          else if (bound[i].shift == false && event.shiftKey == false) {
            bound[i].fn(event);
          }
        }

        if (preventDefault == true) {
          event.preventDefault();
        }
      }
    };

    // bind a key to a callback
    _exportFunctions.bind = function(key, callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      if (_keys[key] === undefined) {
        throw new Error("unsupported key: " + key);
      }
      if (_bound[type][_keys[key].code] === undefined) {
        _bound[type][_keys[key].code] = [];
      }
      _bound[type][_keys[key].code].push({fn:callback, shift:_keys[key].shift});
    };


    // bind all keys to a call back (demo purposes)
    _exportFunctions.bindAll = function(callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      for (var key in _keys) {
        if (_keys.hasOwnProperty(key)) {
          _exportFunctions.bind(key,callback,type);
        }
      }
    };

    // get the key label from an event
    _exportFunctions.getKey = function(event) {
      for (var key in _keys) {
        if (_keys.hasOwnProperty(key)) {
          if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {
            return key;
          }
          else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {
            return key;
          }
          else if (event.keyCode == _keys[key].code && key == 'shift') {
            return key;
          }
        }
      }
      return "unknown key, currently not supported";
    };

    // unbind either a specific callback from a key or all of them (by leaving callback undefined)
    _exportFunctions.unbind = function(key, callback, type) {
      if (type === undefined) {
        type = 'keydown';
      }
      if (_keys[key] === undefined) {
        throw new Error("unsupported key: " + key);
      }
      if (callback !== undefined) {
        var newBindings = [];
        var bound = _bound[type][_keys[key].code];
        if (bound !== undefined) {
          for (var i = 0; i < bound.length; i++) {
            if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {
              newBindings.push(_bound[type][_keys[key].code][i]);
            }
          }
        }
        _bound[type][_keys[key].code] = newBindings;
      }
      else {
        _bound[type][_keys[key].code] = [];
      }
    };

    // reset all bound variables.
    _exportFunctions.reset = function() {
      _bound = {keydown:{}, keyup:{}};
    };

    // unbind all listeners and reset all variables.
    _exportFunctions.destroy = function() {
      _bound = {keydown:{}, keyup:{}};
      container.removeEventListener('keydown', down, true);
      container.removeEventListener('keyup', up, true);
    };

    // create listeners.
    container.addEventListener('keydown',down,true);
    container.addEventListener('keyup',up,true);

    // return the public functions.
    return _exportFunctions;
  }

  return keycharm;
}));



},{}],13:[function(require,module,exports){
//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date = new Date(y, m, d, h, M, s, ms);

        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        if (!m) {
            return isArray(this._weekdays) ? this._weekdays :
                this._weekdays['standalone'];
        }
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
            case 'date':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIOROITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.22.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'YYYY-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

},{}],14:[function(require,module,exports){
'use strict';

(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    window.propagating = factory();
  }
}(function () {
  var _firstTarget = null; // singleton, will contain the target element where the touch event started

  /**
   * Extend an Hammer.js instance with event propagation.
   *
   * Features:
   * - Events emitted by hammer will propagate in order from child to parent
   *   elements.
   * - Events are extended with a function `event.stopPropagation()` to stop
   *   propagation to parent elements.
   * - An option `preventDefault` to stop all default browser behavior.
   *
   * Usage:
   *   var hammer = propagatingHammer(new Hammer(element));
   *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});
   *
   * @param {Hammer.Manager} hammer   An hammer instance.
   * @param {Object} [options]        Available options:
   *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.
   *                                    Enforce preventing the default browser behavior.
   *                                    Cannot be set to `false`.
   * @return {Hammer.Manager} Returns the same hammer instance with extended
   *                          functionality
   */
  return function propagating(hammer, options) {
    var _options = options || {
      preventDefault: false
    };

    if (hammer.Manager) {
      // This looks like the Hammer constructor.
      // Overload the constructors with our own.
      var Hammer = hammer;

      var PropagatingHammer = function(element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer(element, o), o);
      };
      Hammer.assign(PropagatingHammer, Hammer);

      PropagatingHammer.Manager = function (element, options) {
        var o = Object.create(_options);
        if (options) Hammer.assign(o, options);
        return propagating(new Hammer.Manager(element, o), o);
      };

      return PropagatingHammer;
    }

    // create a wrapper object which will override the functions
    // `on`, `off`, `destroy`, and `emit` of the hammer instance
    var wrapper = Object.create(hammer);

    // attach to DOM element
    var element = hammer.element;

    if(!element.hammer) element.hammer = [];
    element.hammer.push(wrapper);

    // register an event to catch the start of a gesture and store the
    // target in a singleton
    hammer.on('hammer.input', function (event) {
      if (_options.preventDefault === true || (_options.preventDefault === event.pointerType)) {
        event.preventDefault();
      }
      if (event.isFirst) {
        _firstTarget = event.target;
      }
    });

    /** @type {Object.<String, Array.<function>>} */
    wrapper._handlers = {};

    /**
     * Register a handler for one or multiple events
     * @param {String} events    A space separated string with events
     * @param {function} handler A callback function, called as handler(event)
     * @returns {Hammer.Manager} Returns the hammer instance
     */
    wrapper.on = function (events, handler) {
      // register the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];
        if (!_handlers) {
          wrapper._handlers[event] = _handlers = [];

          // register the static, propagated handler
          hammer.on(event, propagatedHandler);
        }
        _handlers.push(handler);
      });

      return wrapper;
    };

    /**
     * Unregister a handler for one or multiple events
     * @param {String} events      A space separated string with events
     * @param {function} [handler] Optional. The registered handler. If not
     *                             provided, all handlers for given events
     *                             are removed.
     * @returns {Hammer.Manager}   Returns the hammer instance
     */
    wrapper.off = function (events, handler) {
      // unregister the handler
      split(events).forEach(function (event) {
        var _handlers = wrapper._handlers[event];
        if (_handlers) {
          _handlers = handler ? _handlers.filter(function (h) {
            return h !== handler;
          }) : [];

          if (_handlers.length > 0) {
            wrapper._handlers[event] = _handlers;
          }
          else {
            // remove static, propagated handler
            hammer.off(event, propagatedHandler);
            delete wrapper._handlers[event];
          }
        }
      });

      return wrapper;
    };

    /**
     * Emit to the event listeners
     * @param {string} eventType
     * @param {Event} event
     */
    wrapper.emit = function(eventType, event) {
      _firstTarget = event.target;
      hammer.emit(eventType, event);
    };

    wrapper.destroy = function () {
      // Detach from DOM element
      var hammers = hammer.element.hammer;
      var idx = hammers.indexOf(wrapper);
      if(idx !== -1) hammers.splice(idx,1);
      if(!hammers.length) delete hammer.element.hammer;

      // clear all handlers
      wrapper._handlers = {};

      // call original hammer destroy
      hammer.destroy();
    };

    // split a string with space separated words
    function split(events) {
      return events.match(/[^ ]+/g);
    }

    /**
     * A static event handler, applying event propagation.
     * @param {Object} event
     */
    function propagatedHandler(event) {
      // let only a single hammer instance handle this event
      if (event.type !== 'hammer.input') {
        // it is possible that the same srcEvent is used with multiple hammer events,
        // we keep track on which events are handled in an object _handled
        if (!event.srcEvent._handled) {
          event.srcEvent._handled = {};
        }

        if (event.srcEvent._handled[event.type]) {
          return;
        }
        else {
          event.srcEvent._handled[event.type] = true;
        }
      }

      // attach a stopPropagation function to the event
      var stopped = false;
      event.stopPropagation = function () {
        stopped = true;
      };

      //wrap the srcEvent's stopPropagation to also stop hammer propagation:
      var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);
      if(typeof srcStop == "function") {
        event.srcEvent.stopPropagation = function(){
          srcStop();
          event.stopPropagation();
        }
      }

      // attach firstTarget property to the event
      event.firstTarget = _firstTarget;

      // propagate over all elements (until stopped)
      var elem = _firstTarget;
      while (elem && !stopped) {
        var elemHammer = elem.hammer;
        if(elemHammer){
          var _handlers;
          for(var k = 0; k < elemHammer.length; k++){
            _handlers = elemHammer[k]._handlers[event.type];
            if(_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {
              _handlers[i](event);
            }
          }
        }
        elem = elem.parentNode;
      }
    }

    return wrapper;
  };
}));

},{}],15:[function(require,module,exports){
'use strict';

var util = require('./util');
var Queue = require('./Queue');

/**
 * DataSet
 *
 * Usage:
 *     var dataSet = new DataSet({
 *         fieldId: '_id',
 *         type: {
 *             // ...
 *         }
 *     });
 *
 *     dataSet.add(item);
 *     dataSet.add(data);
 *     dataSet.update(item);
 *     dataSet.update(data);
 *     dataSet.remove(id);
 *     dataSet.remove(ids);
 *     var data = dataSet.get();
 *     var data = dataSet.get(id);
 *     var data = dataSet.get(ids);
 *     var data = dataSet.get(ids, options, data);
 *     dataSet.clear();
 *
 * A data set can:
 * - add/remove/update data
 * - gives triggers upon changes in the data
 * - can  import/export data in various data formats
 *
 * @param {Array} [data]    Optional array with initial data
 * @param {Object} [options]   Available options:
 *                             {String} fieldId Field name of the id in the
 *                                              items, 'id' by default.
 *                             {Object.<String, String} type
 *                                              A map with field names as key,
 *                                              and the field type as value.
 *                             {Object} queue   Queue changes to the DataSet,
 *                                              flush them all at once.
 *                                              Queue options:
 *                                              - {number} delay  Delay in ms, null by default
 *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
 * @constructor DataSet
 */
// TODO: add a DataSet constructor DataSet(data, options)
function DataSet(data, options) {
  // correctly read optional arguments
  if (data && !Array.isArray(data)) {
    options = data;
    data = null;
  }

  this._options = options || {};
  this._data = {}; // map with data indexed by id
  this.length = 0; // number of items in the DataSet
  this._fieldId = this._options.fieldId || 'id'; // name of the field containing id
  this._type = {}; // internal field types (NOTE: this can differ from this._options.type)

  // all variants of a Date are internally stored as Date, so we can convert
  // from everything to everything (also from ISODate to Number for example)
  if (this._options.type) {
    for (var field in this._options.type) {
      if (this._options.type.hasOwnProperty(field)) {
        var value = this._options.type[field];
        if (value == 'Date' || value == 'ISODate' || value == 'ASPDate') {
          this._type[field] = 'Date';
        } else {
          this._type[field] = value;
        }
      }
    }
  }

  // TODO: deprecated since version 1.1.1 (or 2.0.0?)
  if (this._options.convert) {
    throw new Error('Option "convert" is deprecated. Use "type" instead.');
  }

  this._subscribers = {}; // event subscribers

  // add initial data when provided
  if (data) {
    this.add(data);
  }

  this.setOptions(options);
}

/**
 * @param {Object} [options]   Available options:
 *                             {Object} queue   Queue changes to the DataSet,
 *                                              flush them all at once.
 *                                              Queue options:
 *                                              - {number} delay  Delay in ms, null by default
 *                                              - {number} max    Maximum number of entries in the queue, Infinity by default
 * @param options
 */
DataSet.prototype.setOptions = function (options) {
  if (options && options.queue !== undefined) {
    if (options.queue === false) {
      // delete queue if loaded
      if (this._queue) {
        this._queue.destroy();
        delete this._queue;
      }
    } else {
      // create queue and update its options
      if (!this._queue) {
        this._queue = Queue.extend(this, {
          replace: ['add', 'update', 'remove']
        });
      }

      if (typeof options.queue === 'object') {
        this._queue.setOptions(options.queue);
      }
    }
  }
};

/**
 * Subscribe to an event, add an event listener
 * @param {String} event        Event name. Available events: 'put', 'update',
 *                              'remove'
 * @param {function} callback   Callback method. Called with three parameters:
 *                                  {String} event
 *                                  {Object | null} params
 *                                  {String | Number} senderId
 */
DataSet.prototype.on = function (event, callback) {
  var subscribers = this._subscribers[event];
  if (!subscribers) {
    subscribers = [];
    this._subscribers[event] = subscribers;
  }

  subscribers.push({
    callback: callback
  });
};

// TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
DataSet.prototype.subscribe = function () {
  throw new Error('DataSet.subscribe is deprecated. Use DataSet.on instead.');
};

/**
 * Unsubscribe from an event, remove an event listener
 * @param {String} event
 * @param {function} callback
 */
DataSet.prototype.off = function (event, callback) {
  var subscribers = this._subscribers[event];
  if (subscribers) {
    this._subscribers[event] = subscribers.filter(function (listener) {
      return listener.callback != callback;
    });
  }
};

// TODO: remove this deprecated function some day (replaced with `on` since version 0.5, deprecated since v4.0)
DataSet.prototype.unsubscribe = function () {
  throw new Error('DataSet.unsubscribe is deprecated. Use DataSet.off instead.');
};

/**
 * Trigger an event
 * @param {String} event
 * @param {Object | null} params
 * @param {String} [senderId]       Optional id of the sender.
 * @private
 */
DataSet.prototype._trigger = function (event, params, senderId) {
  if (event == '*') {
    throw new Error('Cannot trigger event *');
  }

  var subscribers = [];
  if (event in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers[event]);
  }
  if ('*' in this._subscribers) {
    subscribers = subscribers.concat(this._subscribers['*']);
  }

  for (var i = 0; i < subscribers.length; i++) {
    var subscriber = subscribers[i];
    if (subscriber.callback) {
      subscriber.callback(event, params, senderId || null);
    }
  }
};

/**
 * Add data.
 * Adding an item will fail when there already is an item with the same id.
 * @param {Object | Array} data
 * @param {String} [senderId] Optional sender id
 * @return {Array} addedIds      Array with the ids of the added items
 */
DataSet.prototype.add = function (data, senderId) {
  var addedIds = [],
      id,
      me = this;

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      id = me._addItem(data[i]);
      addedIds.push(id);
    }
  } else if (data instanceof Object) {
    // Single item
    id = me._addItem(data);
    addedIds.push(id);
  } else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', { items: addedIds }, senderId);
  }

  return addedIds;
};

/**
 * Update existing items. When an item does not exist, it will be created
 * @param {Object | Array} data
 * @param {String} [senderId] Optional sender id
 * @return {Array} updatedIds     The ids of the added or updated items
 */
DataSet.prototype.update = function (data, senderId) {
  var addedIds = [];
  var updatedIds = [];
  var updatedData = [];
  var me = this;
  var fieldId = me._fieldId;

  var addOrUpdate = function addOrUpdate(item) {
    var id = item[fieldId];
    if (me._data[id]) {
      // update item
      id = me._updateItem(item);
      updatedIds.push(id);
      updatedData.push(item);
    } else {
      // add new item
      id = me._addItem(item);
      addedIds.push(id);
    }
  };

  if (Array.isArray(data)) {
    // Array
    for (var i = 0, len = data.length; i < len; i++) {
      addOrUpdate(data[i]);
    }
  } else if (data instanceof Object) {
    // Single item
    addOrUpdate(data);
  } else {
    throw new Error('Unknown dataType');
  }

  if (addedIds.length) {
    this._trigger('add', { items: addedIds }, senderId);
  }
  if (updatedIds.length) {
    this._trigger('update', { items: updatedIds, data: updatedData }, senderId);
  }

  return addedIds.concat(updatedIds);
};

/**
 * Get a data item or multiple items.
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *
 *     get(id: Number | String)
 *     get(id: Number | String, options: Object)
 *
 *     get(ids: Number[] | String[])
 *     get(ids: Number[] | String[], options: Object)
 *
 * Where:
 *
 * {Number | String} id         The id of an item
 * {Number[] | String{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 * {String} [returnType]        Type of data to be returned.
 *                              Can be 'Array' (default) or 'Object'.
 * {Object.<String, String>} [type]
 * {String[]} [fields]          field names to be returned
 * {function} [filter]          filter items
 * {String | function} [order]  Order the items by a field name or custom sort function.
 * @throws Error
 */
DataSet.prototype.get = function (args) {
  var me = this;

  // parse the arguments
  var id, ids, options;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number') {
    // get(id [, options])
    id = arguments[0];
    options = arguments[1];
  } else if (firstType == 'Array') {
    // get(ids [, options])
    ids = arguments[0];
    options = arguments[1];
  } else {
    // get([, options])
    options = arguments[0];
  }

  // determine the return type
  var returnType;
  if (options && options.returnType) {
    var allowedValues = ['Array', 'Object'];
    returnType = allowedValues.indexOf(options.returnType) == -1 ? 'Array' : options.returnType;
  } else {
    returnType = 'Array';
  }

  // build options
  var type = options && options.type || this._options.type;
  var filter = options && options.filter;
  var items = [],
      item,
      itemId,
      i,
      len;

  // convert items
  if (id != undefined) {
    // return a single item
    item = me._getItem(id, type);
    if (filter && !filter(item)) {
      item = null;
    }
  } else if (ids != undefined) {
    // return a subset of items
    for (i = 0, len = ids.length; i < len; i++) {
      item = me._getItem(ids[i], type);
      if (!filter || filter(item)) {
        items.push(item);
      }
    }
  } else {
    // return all items
    for (itemId in this._data) {
      if (this._data.hasOwnProperty(itemId)) {
        item = me._getItem(itemId, type);
        if (!filter || filter(item)) {
          items.push(item);
        }
      }
    }
  }

  // order the results
  if (options && options.order && id == undefined) {
    this._sort(items, options.order);
  }

  // filter fields of the items
  if (options && options.fields) {
    var fields = options.fields;
    if (id != undefined) {
      item = this._filterFields(item, fields);
    } else {
      for (i = 0, len = items.length; i < len; i++) {
        items[i] = this._filterFields(items[i], fields);
      }
    }
  }

  // return the results
  if (returnType == 'Object') {
    var result = {};
    for (i = 0; i < items.length; i++) {
      result[items[i].id] = items[i];
    }
    return result;
  } else {
    if (id != undefined) {
      // a single item
      return item;
    } else {
      // just return our array
      return items;
    }
  }
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array} ids
 */
DataSet.prototype.getIds = function (options) {
  var data = this._data,
      filter = options && options.filter,
      order = options && options.order,
      type = options && options.type || this._options.type,
      i,
      len,
      id,
      item,
      items,
      ids = [];

  if (filter) {
    // get filtered items
    if (order) {
      // create ordered list
      items = [];
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = this._getItem(id, type);
          if (filter(item)) {
            items.push(item);
          }
        }
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids[i] = items[i][this._fieldId];
      }
    } else {
      // create unordered list
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = this._getItem(id, type);
          if (filter(item)) {
            ids.push(item[this._fieldId]);
          }
        }
      }
    }
  } else {
    // get all items
    if (order) {
      // create an ordered list
      items = [];
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          items.push(data[id]);
        }
      }

      this._sort(items, order);

      for (i = 0, len = items.length; i < len; i++) {
        ids[i] = items[i][this._fieldId];
      }
    } else {
      // create unordered list
      for (id in data) {
        if (data.hasOwnProperty(id)) {
          item = data[id];
          ids.push(item[this._fieldId]);
        }
      }
    }
  }

  return ids;
};

/**
 * Returns the DataSet itself. Is overwritten for example by the DataView,
 * which returns the DataSet it is connected to instead.
 */
DataSet.prototype.getDataSet = function () {
  return this;
};

/**
 * Execute a callback function for every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<String, String>} [type]
 *                              {String[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 */
DataSet.prototype.forEach = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      data = this._data,
      item,
      id;

  if (options && options.order) {
    // execute forEach on ordered list
    var items = this.get(options);

    for (var i = 0, len = items.length; i < len; i++) {
      item = items[i];
      id = item[this._fieldId];
      callback(item, id);
    }
  } else {
    // unordered
    for (id in data) {
      if (data.hasOwnProperty(id)) {
        item = this._getItem(id, type);
        if (!filter || filter(item)) {
          callback(item, id);
        }
      }
    }
  }
};

/**
 * Map every item in the dataset.
 * @param {function} callback
 * @param {Object} [options]    Available options:
 *                              {Object.<String, String>} [type]
 *                              {String[]} [fields] filter fields
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Object[]} mappedItems
 */
DataSet.prototype.map = function (callback, options) {
  var filter = options && options.filter,
      type = options && options.type || this._options.type,
      mappedItems = [],
      data = this._data,
      item;

  // convert and filter items
  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      item = this._getItem(id, type);
      if (!filter || filter(item)) {
        mappedItems.push(callback(item, id));
      }
    }
  }

  // order items
  if (options && options.order) {
    this._sort(mappedItems, options.order);
  }

  return mappedItems;
};

/**
 * Filter the fields of an item
 * @param {Object | null} item
 * @param {String[]} fields     Field names
 * @return {Object | null} filteredItem or null if no item is provided
 * @private
 */
DataSet.prototype._filterFields = function (item, fields) {
  if (!item) {
    // item is null
    return item;
  }

  var filteredItem = {};

  if (Array.isArray(fields)) {
    for (var field in item) {
      if (item.hasOwnProperty(field) && fields.indexOf(field) != -1) {
        filteredItem[field] = item[field];
      }
    }
  } else {
    for (var field in item) {
      if (item.hasOwnProperty(field) && fields.hasOwnProperty(field)) {
        filteredItem[fields[field]] = item[field];
      }
    }
  }

  return filteredItem;
};

/**
 * Sort the provided array with items
 * @param {Object[]} items
 * @param {String | function} order      A field name or custom sort function.
 * @private
 */
DataSet.prototype._sort = function (items, order) {
  if (util.isString(order)) {
    // order by provided field name
    var name = order; // field name
    items.sort(function (a, b) {
      var av = a[name];
      var bv = b[name];
      return av > bv ? 1 : av < bv ? -1 : 0;
    });
  } else if (typeof order === 'function') {
    // order by sort function
    items.sort(order);
  }
  // TODO: extend order by an Object {field:String, direction:String}
  //       where direction can be 'asc' or 'desc'
  else {
      throw new TypeError('Order must be a function or a string');
    }
};

/**
 * Remove an object by pointer or by id
 * @param {String | Number | Object | Array} id Object or id, or an array with
 *                                              objects or ids to be removed
 * @param {String} [senderId] Optional sender id
 * @return {Array} removedIds
 */
DataSet.prototype.remove = function (id, senderId) {
  var removedIds = [],
      i,
      len,
      removedId;

  if (Array.isArray(id)) {
    for (i = 0, len = id.length; i < len; i++) {
      removedId = this._remove(id[i]);
      if (removedId != null) {
        removedIds.push(removedId);
      }
    }
  } else {
    removedId = this._remove(id);
    if (removedId != null) {
      removedIds.push(removedId);
    }
  }

  if (removedIds.length) {
    this._trigger('remove', { items: removedIds }, senderId);
  }

  return removedIds;
};

/**
 * Remove an item by its id
 * @param {Number | String | Object} id   id or item
 * @returns {Number | String | null} id
 * @private
 */
DataSet.prototype._remove = function (id) {
  if (util.isNumber(id) || util.isString(id)) {
    if (this._data[id]) {
      delete this._data[id];
      this.length--;
      return id;
    }
  } else if (id instanceof Object) {
    var itemId = id[this._fieldId];
    if (itemId && this._data[itemId]) {
      delete this._data[itemId];
      this.length--;
      return itemId;
    }
  }
  return null;
};

/**
 * Clear the data
 * @param {String} [senderId] Optional sender id
 * @return {Array} removedIds    The ids of all removed items
 */
DataSet.prototype.clear = function (senderId) {
  var ids = Object.keys(this._data);

  this._data = {};
  this.length = 0;

  this._trigger('remove', { items: ids }, senderId);

  return ids;
};

/**
 * Find the item with maximum value of a specified field
 * @param {String} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.max = function (field) {
  var data = this._data,
      max = null,
      maxField = null;

  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!max || itemField > maxField)) {
        max = item;
        maxField = itemField;
      }
    }
  }

  return max;
};

/**
 * Find the item with minimum value of a specified field
 * @param {String} field
 * @return {Object | null} item  Item containing max value, or null if no items
 */
DataSet.prototype.min = function (field) {
  var data = this._data,
      min = null,
      minField = null;

  for (var id in data) {
    if (data.hasOwnProperty(id)) {
      var item = data[id];
      var itemField = item[field];
      if (itemField != null && (!min || itemField < minField)) {
        min = item;
        minField = itemField;
      }
    }
  }

  return min;
};

/**
 * Find all distinct values of a specified field
 * @param {String} field
 * @return {Array} values  Array containing all distinct values. If data items
 *                         do not contain the specified field are ignored.
 *                         The returned array is unordered.
 */
DataSet.prototype.distinct = function (field) {
  var data = this._data;
  var values = [];
  var fieldType = this._options.type && this._options.type[field] || null;
  var count = 0;
  var i;

  for (var prop in data) {
    if (data.hasOwnProperty(prop)) {
      var item = data[prop];
      var value = item[field];
      var exists = false;
      for (i = 0; i < count; i++) {
        if (values[i] == value) {
          exists = true;
          break;
        }
      }
      if (!exists && value !== undefined) {
        values[count] = value;
        count++;
      }
    }
  }

  if (fieldType) {
    for (i = 0; i < values.length; i++) {
      values[i] = util.convert(values[i], fieldType);
    }
  }

  return values;
};

/**
 * Add a single item. Will fail when an item with the same id already exists.
 * @param {Object} item
 * @return {String} id
 * @private
 */
DataSet.prototype._addItem = function (item) {
  var id = item[this._fieldId];

  if (id != undefined) {
    // check whether this id is already taken
    if (this._data[id]) {
      // item already exists
      throw new Error('Cannot add item: item with id ' + id + ' already exists');
    }
  } else {
    // generate an id
    id = util.randomUUID();
    item[this._fieldId] = id;
  }

  var d = {};
  for (var field in item) {
    if (item.hasOwnProperty(field)) {
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
  }
  this._data[id] = d;
  this.length++;

  return id;
};

/**
 * Get an item. Fields can be converted to a specific type
 * @param {String} id
 * @param {Object.<String, String>} [types]  field types to convert
 * @return {Object | null} item
 * @private
 */
DataSet.prototype._getItem = function (id, types) {
  var field, value;

  // get the item from the dataset
  var raw = this._data[id];
  if (!raw) {
    return null;
  }

  // convert the items field types
  var converted = {};
  if (types) {
    for (field in raw) {
      if (raw.hasOwnProperty(field)) {
        value = raw[field];
        converted[field] = util.convert(value, types[field]);
      }
    }
  } else {
    // no field types specified, no converting needed
    for (field in raw) {
      if (raw.hasOwnProperty(field)) {
        value = raw[field];
        converted[field] = value;
      }
    }
  }
  return converted;
};

/**
 * Update a single item: merge with existing item.
 * Will fail when the item has no id, or when there does not exist an item
 * with the same id.
 * @param {Object} item
 * @return {String} id
 * @private
 */
DataSet.prototype._updateItem = function (item) {
  var id = item[this._fieldId];
  if (id == undefined) {
    throw new Error('Cannot update item: item has no id (item: ' + JSON.stringify(item) + ')');
  }
  var d = this._data[id];
  if (!d) {
    // item doesn't exist
    throw new Error('Cannot update item: no item with id ' + id + ' found');
  }

  // merge with current item
  for (var field in item) {
    if (item.hasOwnProperty(field)) {
      var fieldType = this._type[field]; // type may be undefined
      d[field] = util.convert(item[field], fieldType);
    }
  }

  return id;
};

module.exports = DataSet;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9EYXRhU2V0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzdCLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkMvQixTQUFTLE9BQU8sQ0FBRSxJQUFJLEVBQUUsT0FBTyxFQUFFOztBQUUvQixNQUFJLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDaEMsV0FBTyxHQUFHLElBQUksQ0FBQztBQUNmLFFBQUksR0FBRyxJQUFJLENBQUM7R0FDYjs7QUFFRCxNQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7QUFDOUIsTUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDaEIsTUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDaEIsTUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUM7QUFDOUMsTUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7Ozs7QUFJaEIsTUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRTtBQUN0QixTQUFLLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFO0FBQ3BDLFVBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzVDLFlBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3RDLFlBQUksS0FBSyxJQUFJLE1BQU0sSUFBSSxLQUFLLElBQUksU0FBUyxJQUFJLEtBQUss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LE9BQUssSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFO0FBQ3RCLFFBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUM5QixVQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2xDLE9BQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztLQUNqRDtHQUNGOztBQUVELFNBQU8sRUFBRSxDQUFDO0NBQ1gsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyIsImZpbGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvRGF0YVNldC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgUXVldWUgPSByZXF1aXJlKCcuL1F1ZXVlJyk7XG5cbi8qKlxuICogRGF0YVNldFxuICpcbiAqIFVzYWdlOlxuICogICAgIHZhciBkYXRhU2V0ID0gbmV3IERhdGFTZXQoe1xuICogICAgICAgICBmaWVsZElkOiAnX2lkJyxcbiAqICAgICAgICAgdHlwZToge1xuICogICAgICAgICAgICAgLy8gLi4uXG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgZGF0YVNldC5hZGQoaXRlbSk7XG4gKiAgICAgZGF0YVNldC5hZGQoZGF0YSk7XG4gKiAgICAgZGF0YVNldC51cGRhdGUoaXRlbSk7XG4gKiAgICAgZGF0YVNldC51cGRhdGUoZGF0YSk7XG4gKiAgICAgZGF0YVNldC5yZW1vdmUoaWQpO1xuICogICAgIGRhdGFTZXQucmVtb3ZlKGlkcyk7XG4gKiAgICAgdmFyIGRhdGEgPSBkYXRhU2V0LmdldCgpO1xuICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoaWQpO1xuICogICAgIHZhciBkYXRhID0gZGF0YVNldC5nZXQoaWRzKTtcbiAqICAgICB2YXIgZGF0YSA9IGRhdGFTZXQuZ2V0KGlkcywgb3B0aW9ucywgZGF0YSk7XG4gKiAgICAgZGF0YVNldC5jbGVhcigpO1xuICpcbiAqIEEgZGF0YSBzZXQgY2FuOlxuICogLSBhZGQvcmVtb3ZlL3VwZGF0ZSBkYXRhXG4gKiAtIGdpdmVzIHRyaWdnZXJzIHVwb24gY2hhbmdlcyBpbiB0aGUgZGF0YVxuICogLSBjYW4gIGltcG9ydC9leHBvcnQgZGF0YSBpbiB2YXJpb3VzIGRhdGEgZm9ybWF0c1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IFtkYXRhXSAgICBPcHRpb25hbCBhcnJheSB3aXRoIGluaXRpYWwgZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGZpZWxkSWQgRmllbGQgbmFtZSBvZiB0aGUgaWQgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtcywgJ2lkJyBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nfSB0eXBlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIG1hcCB3aXRoIGZpZWxkIG5hbWVzIGFzIGtleSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgZmllbGQgdHlwZSBhcyB2YWx1ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBxdWV1ZSAgIFF1ZXVlIGNoYW5nZXMgdG8gdGhlIERhdGFTZXQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbHVzaCB0aGVtIGFsbCBhdCBvbmNlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUXVldWUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gZGVsYXkgIERlbGF5IGluIG1zLCBudWxsIGJ5IGRlZmF1bHRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ge251bWJlcn0gbWF4ICAgIE1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHF1ZXVlLCBJbmZpbml0eSBieSBkZWZhdWx0XG4gKiBAY29uc3RydWN0b3IgRGF0YVNldFxuICovXG4vLyBUT0RPOiBhZGQgYSBEYXRhU2V0IGNvbnN0cnVjdG9yIERhdGFTZXQoZGF0YSwgb3B0aW9ucylcbmZ1bmN0aW9uIERhdGFTZXQgKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gY29ycmVjdGx5IHJlYWQgb3B0aW9uYWwgYXJndW1lbnRzXG4gIGlmIChkYXRhICYmICFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgb3B0aW9ucyA9IGRhdGE7XG4gICAgZGF0YSA9IG51bGw7XG4gIH1cblxuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fZGF0YSA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hcCB3aXRoIGRhdGEgaW5kZXhlZCBieSBpZFxuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBEYXRhU2V0XG4gIHRoaXMuX2ZpZWxkSWQgPSB0aGlzLl9vcHRpb25zLmZpZWxkSWQgfHwgJ2lkJzsgICAvLyBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIGlkXG4gIHRoaXMuX3R5cGUgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcm5hbCBmaWVsZCB0eXBlcyAoTk9URTogdGhpcyBjYW4gZGlmZmVyIGZyb20gdGhpcy5fb3B0aW9ucy50eXBlKVxuXG4gIC8vIGFsbCB2YXJpYW50cyBvZiBhIERhdGUgYXJlIGludGVybmFsbHkgc3RvcmVkIGFzIERhdGUsIHNvIHdlIGNhbiBjb252ZXJ0XG4gIC8vIGZyb20gZXZlcnl0aGluZyB0byBldmVyeXRoaW5nIChhbHNvIGZyb20gSVNPRGF0ZSB0byBOdW1iZXIgZm9yIGV4YW1wbGUpXG4gIGlmICh0aGlzLl9vcHRpb25zLnR5cGUpIHtcbiAgICBmb3IgKHZhciBmaWVsZCBpbiB0aGlzLl9vcHRpb25zLnR5cGUpIHtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnR5cGUuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX29wdGlvbnMudHlwZVtmaWVsZF07XG4gICAgICAgIGlmICh2YWx1ZSA9PSAnRGF0ZScgfHwgdmFsdWUgPT0gJ0lTT0RhdGUnIHx8IHZhbHVlID09ICdBU1BEYXRlJykge1xuICAgICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gJ0RhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3R5cGVbZmllbGRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xLjEgKG9yIDIuMC4wPylcbiAgaWYgKHRoaXMuX29wdGlvbnMuY29udmVydCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9uIFwiY29udmVydFwiIGlzIGRlcHJlY2F0ZWQuIFVzZSBcInR5cGVcIiBpbnN0ZWFkLicpO1xuICB9XG5cbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTsgIC8vIGV2ZW50IHN1YnNjcmliZXJzXG5cbiAgLy8gYWRkIGluaXRpYWwgZGF0YSB3aGVuIHByb3ZpZGVkXG4gIGlmIChkYXRhKSB7XG4gICAgdGhpcy5hZGQoZGF0YSk7XG4gIH1cblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IHF1ZXVlICAgUXVldWUgY2hhbmdlcyB0byB0aGUgRGF0YVNldCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoIHRoZW0gYWxsIGF0IG9uY2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWV1ZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBkZWxheSAgRGVsYXkgaW4gbXMsIG51bGwgYnkgZGVmYXVsdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7bnVtYmVyfSBtYXggICAgTWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgcXVldWUsIEluZmluaXR5IGJ5IGRlZmF1bHRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucXVldWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLnF1ZXVlID09PSBmYWxzZSkge1xuICAgICAgLy8gZGVsZXRlIHF1ZXVlIGlmIGxvYWRlZFxuICAgICAgaWYgKHRoaXMuX3F1ZXVlKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLmRlc3Ryb3koKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3F1ZXVlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSBxdWV1ZSBhbmQgdXBkYXRlIGl0cyBvcHRpb25zXG4gICAgICBpZiAoIXRoaXMuX3F1ZXVlKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gUXVldWUuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICByZXBsYWNlOiBbJ2FkZCcsICd1cGRhdGUnLCAncmVtb3ZlJ11cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5xdWV1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5fcXVldWUuc2V0T3B0aW9ucyhvcHRpb25zLnF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIGFuIGV2ZW50LCBhZGQgYW4gZXZlbnQgbGlzdGVuZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAgICAgICAgRXZlbnQgbmFtZS4gQXZhaWxhYmxlIGV2ZW50czogJ3B1dCcsICd1cGRhdGUnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVtb3ZlJ1xuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjayBtZXRob2QuIENhbGxlZCB3aXRoIHRocmVlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBldmVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdCB8IG51bGx9IHBhcmFtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IE51bWJlcn0gc2VuZGVySWRcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdO1xuICBpZiAoIXN1YnNjcmliZXJzKSB7XG4gICAgc3Vic2NyaWJlcnMgPSBbXTtcbiAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBzdWJzY3JpYmVycztcbiAgfVxuXG4gIHN1YnNjcmliZXJzLnB1c2goe1xuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbi8vIFRPRE86IHJlbW92ZSB0aGlzIGRlcHJlY2F0ZWQgZnVuY3Rpb24gc29tZSBkYXkgKHJlcGxhY2VkIHdpdGggYG9uYCBzaW5jZSB2ZXJzaW9uIDAuNSwgZGVwcmVjYXRlZCBzaW5jZSB2NC4wKVxuRGF0YVNldC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFTZXQuc3Vic2NyaWJlIGlzIGRlcHJlY2F0ZWQuIFVzZSBEYXRhU2V0Lm9uIGluc3RlYWQuJyk7XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gYW4gZXZlbnQsIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdO1xuICBpZiAoc3Vic2NyaWJlcnMpIHtcbiAgICB0aGlzLl9zdWJzY3JpYmVyc1tldmVudF0gPSBzdWJzY3JpYmVycy5maWx0ZXIobGlzdGVuZXIgPT4gbGlzdGVuZXIuY2FsbGJhY2sgIT0gY2FsbGJhY2spO1xuICB9XG59O1xuXG4vLyBUT0RPOiByZW1vdmUgdGhpcyBkZXByZWNhdGVkIGZ1bmN0aW9uIHNvbWUgZGF5IChyZXBsYWNlZCB3aXRoIGBvbmAgc2luY2UgdmVyc2lvbiAwLjUsIGRlcHJlY2F0ZWQgc2luY2UgdjQuMClcbkRhdGFTZXQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFTZXQudW5zdWJzY3JpYmUgaXMgZGVwcmVjYXRlZC4gVXNlIERhdGFTZXQub2ZmIGluc3RlYWQuJyk7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3QgfCBudWxsfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdICAgICAgIE9wdGlvbmFsIGlkIG9mIHRoZSBzZW5kZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICBpZiAoZXZlbnQgPT0gJyonKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdHJpZ2dlciBldmVudCAqJyk7XG4gIH1cblxuICB2YXIgc3Vic2NyaWJlcnMgPSBbXTtcbiAgaWYgKGV2ZW50IGluIHRoaXMuX3N1YnNjcmliZXJzKSB7XG4gICAgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5jb25jYXQodGhpcy5fc3Vic2NyaWJlcnNbZXZlbnRdKTtcbiAgfVxuICBpZiAoJyonIGluIHRoaXMuX3N1YnNjcmliZXJzKSB7XG4gICAgc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5jb25jYXQodGhpcy5fc3Vic2NyaWJlcnNbJyonXSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBpZiAoc3Vic2NyaWJlci5jYWxsYmFjaykge1xuICAgICAgc3Vic2NyaWJlci5jYWxsYmFjayhldmVudCwgcGFyYW1zLCBzZW5kZXJJZCB8fCBudWxsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGRhdGEuXG4gKiBBZGRpbmcgYW4gaXRlbSB3aWxsIGZhaWwgd2hlbiB0aGVyZSBhbHJlYWR5IGlzIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBpZC5cbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2VuZGVySWRdIE9wdGlvbmFsIHNlbmRlciBpZFxuICogQHJldHVybiB7QXJyYXl9IGFkZGVkSWRzICAgICAgQXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZSBhZGRlZCBpdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSwgc2VuZGVySWQpIHtcbiAgdmFyIGFkZGVkSWRzID0gW10sXG4gICAgICBpZCxcbiAgICAgIG1lID0gdGhpcztcblxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIC8vIEFycmF5XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlkID0gbWUuX2FkZEl0ZW0oZGF0YVtpXSk7XG4gICAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIC8vIFNpbmdsZSBpdGVtXG4gICAgaWQgPSBtZS5fYWRkSXRlbShkYXRhKTtcbiAgICBhZGRlZElkcy5wdXNoKGlkKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGF0YVR5cGUnKTtcbiAgfVxuXG4gIGlmIChhZGRlZElkcy5sZW5ndGgpIHtcbiAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7aXRlbXM6IGFkZGVkSWRzfSwgc2VuZGVySWQpO1xuICB9XG5cbiAgcmV0dXJuIGFkZGVkSWRzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgZXhpc3RpbmcgaXRlbXMuIFdoZW4gYW4gaXRlbSBkb2VzIG5vdCBleGlzdCwgaXQgd2lsbCBiZSBjcmVhdGVkXG4gKiBAcGFyYW0ge09iamVjdCB8IEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5fSB1cGRhdGVkSWRzICAgICBUaGUgaWRzIG9mIHRoZSBhZGRlZCBvciB1cGRhdGVkIGl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBzZW5kZXJJZCkge1xuICB2YXIgYWRkZWRJZHMgPSBbXTtcbiAgdmFyIHVwZGF0ZWRJZHMgPSBbXTtcbiAgdmFyIHVwZGF0ZWREYXRhID0gW107XG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBmaWVsZElkID0gbWUuX2ZpZWxkSWQ7XG5cbiAgdmFyIGFkZE9yVXBkYXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgaWQgPSBpdGVtW2ZpZWxkSWRdO1xuICAgIGlmIChtZS5fZGF0YVtpZF0pIHtcbiAgICAgIC8vIHVwZGF0ZSBpdGVtXG4gICAgICBpZCA9IG1lLl91cGRhdGVJdGVtKGl0ZW0pO1xuICAgICAgdXBkYXRlZElkcy5wdXNoKGlkKTtcbiAgICAgIHVwZGF0ZWREYXRhLnB1c2goaXRlbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gYWRkIG5ldyBpdGVtXG4gICAgICBpZCA9IG1lLl9hZGRJdGVtKGl0ZW0pO1xuICAgICAgYWRkZWRJZHMucHVzaChpZCk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgLy8gQXJyYXlcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYWRkT3JVcGRhdGUoZGF0YVtpXSk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAvLyBTaW5nbGUgaXRlbVxuICAgIGFkZE9yVXBkYXRlKGRhdGEpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBkYXRhVHlwZScpO1xuICB9XG5cbiAgaWYgKGFkZGVkSWRzLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHtpdGVtczogYWRkZWRJZHN9LCBzZW5kZXJJZCk7XG4gIH1cbiAgaWYgKHVwZGF0ZWRJZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcigndXBkYXRlJywge2l0ZW1zOiB1cGRhdGVkSWRzLCBkYXRhOiB1cGRhdGVkRGF0YX0sIHNlbmRlcklkKTtcbiAgfVxuXG4gIHJldHVybiBhZGRlZElkcy5jb25jYXQodXBkYXRlZElkcyk7XG59O1xuXG4vKipcbiAqIEdldCBhIGRhdGEgaXRlbSBvciBtdWx0aXBsZSBpdGVtcy5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAgZ2V0KClcbiAqICAgICBnZXQob3B0aW9uczogT2JqZWN0KVxuICpcbiAqICAgICBnZXQoaWQ6IE51bWJlciB8IFN0cmluZylcbiAqICAgICBnZXQoaWQ6IE51bWJlciB8IFN0cmluZywgb3B0aW9uczogT2JqZWN0KVxuICpcbiAqICAgICBnZXQoaWRzOiBOdW1iZXJbXSB8IFN0cmluZ1tdKVxuICogICAgIGdldChpZHM6IE51bWJlcltdIHwgU3RyaW5nW10sIG9wdGlvbnM6IE9iamVjdClcbiAqXG4gKiBXaGVyZTpcbiAqXG4gKiB7TnVtYmVyIHwgU3RyaW5nfSBpZCAgICAgICAgIFRoZSBpZCBvZiBhbiBpdGVtXG4gKiB7TnVtYmVyW10gfCBTdHJpbmd7fX0gaWRzICAgIEFuIGFycmF5IHdpdGggaWRzIG9mIGl0ZW1zXG4gKiB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICoge1N0cmluZ30gW3JldHVyblR5cGVdICAgICAgICBUeXBlIG9mIGRhdGEgdG8gYmUgcmV0dXJuZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBiZSAnQXJyYXknIChkZWZhdWx0KSBvciAnT2JqZWN0Jy5cbiAqIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gKiB7U3RyaW5nW119IFtmaWVsZHNdICAgICAgICAgIGZpZWxkIG5hbWVzIHRvIGJlIHJldHVybmVkXG4gKiB7ZnVuY3Rpb259IFtmaWx0ZXJdICAgICAgICAgIGZpbHRlciBpdGVtc1xuICoge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdICBPcmRlciB0aGUgaXRlbXMgYnkgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHRocm93cyBFcnJvclxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXJncykge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIHBhcnNlIHRoZSBhcmd1bWVudHNcbiAgdmFyIGlkLCBpZHMsIG9wdGlvbnM7XG4gIHZhciBmaXJzdFR5cGUgPSB1dGlsLmdldFR5cGUoYXJndW1lbnRzWzBdKTtcbiAgaWYgKGZpcnN0VHlwZSA9PSAnU3RyaW5nJyB8fCBmaXJzdFR5cGUgPT0gJ051bWJlcicpIHtcbiAgICAvLyBnZXQoaWQgWywgb3B0aW9uc10pXG4gICAgaWQgPSBhcmd1bWVudHNbMF07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgfVxuICBlbHNlIGlmIChmaXJzdFR5cGUgPT0gJ0FycmF5Jykge1xuICAgIC8vIGdldChpZHMgWywgb3B0aW9uc10pXG4gICAgaWRzID0gYXJndW1lbnRzWzBdO1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2V0KFssIG9wdGlvbnNdKVxuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlXG4gIHZhciByZXR1cm5UeXBlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJldHVyblR5cGUpIHtcbiAgICB2YXIgYWxsb3dlZFZhbHVlcyA9IFsnQXJyYXknLCAnT2JqZWN0J107XG4gICAgcmV0dXJuVHlwZSA9IGFsbG93ZWRWYWx1ZXMuaW5kZXhPZihvcHRpb25zLnJldHVyblR5cGUpID09IC0xID8gJ0FycmF5JyA6IG9wdGlvbnMucmV0dXJuVHlwZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm5UeXBlID0gJ0FycmF5JztcbiAgfVxuXG4gIC8vIGJ1aWxkIG9wdGlvbnNcbiAgdmFyIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGU7XG4gIHZhciBmaWx0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyO1xuICB2YXIgaXRlbXMgPSBbXSwgaXRlbSwgaXRlbUlkLCBpLCBsZW47XG5cbiAgLy8gY29udmVydCBpdGVtc1xuICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gcmV0dXJuIGEgc2luZ2xlIGl0ZW1cbiAgICBpdGVtID0gbWUuX2dldEl0ZW0oaWQsIHR5cGUpO1xuICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlcihpdGVtKSkge1xuICAgICAgaXRlbSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGlkcyAhPSB1bmRlZmluZWQpIHtcbiAgICAvLyByZXR1cm4gYSBzdWJzZXQgb2YgaXRlbXNcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBtZS5fZ2V0SXRlbShpZHNbaV0sIHR5cGUpO1xuICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIHJldHVybiBhbGwgaXRlbXNcbiAgICBmb3IgKGl0ZW1JZCBpbiB0aGlzLl9kYXRhKSB7XG4gICAgICBpZiAodGhpcy5fZGF0YS5oYXNPd25Qcm9wZXJ0eShpdGVtSWQpKSB7XG4gICAgICAgIGl0ZW0gPSBtZS5fZ2V0SXRlbShpdGVtSWQsIHR5cGUpO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gb3JkZXIgdGhlIHJlc3VsdHNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlciAmJiBpZCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcHRpb25zLm9yZGVyKTtcbiAgfVxuXG4gIC8vIGZpbHRlciBmaWVsZHMgb2YgdGhlIGl0ZW1zXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmllbGRzKSB7XG4gICAgdmFyIGZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIGlmIChpZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZW0gPSB0aGlzLl9maWx0ZXJGaWVsZHMoaXRlbSwgZmllbGRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtc1tpXSA9IHRoaXMuX2ZpbHRlckZpZWxkcyhpdGVtc1tpXSwgZmllbGRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm4gdGhlIHJlc3VsdHNcbiAgaWYgKHJldHVyblR5cGUgPT0gJ09iamVjdCcpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaXRlbXNbaV0uaWRdID0gaXRlbXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKGlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYSBzaW5nbGUgaXRlbVxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8ganVzdCByZXR1cm4gb3VyIGFycmF5XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldCBpZHMgb2YgYWxsIGl0ZW1zIG9yIGZyb20gYSBmaWx0ZXJlZCBzZXQgb2YgaXRlbXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEFuIE9iamVjdCB3aXRoIG9wdGlvbnMuIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gaWRzXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmdldElkcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIsXG4gICAgICBvcmRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcixcbiAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICBpLFxuICAgICAgbGVuLFxuICAgICAgaWQsXG4gICAgICBpdGVtLFxuICAgICAgaXRlbXMsXG4gICAgICBpZHMgPSBbXTtcblxuICBpZiAoZmlsdGVyKSB7XG4gICAgLy8gZ2V0IGZpbHRlcmVkIGl0ZW1zXG4gICAgaWYgKG9yZGVyKSB7XG4gICAgICAvLyBjcmVhdGUgb3JkZXJlZCBsaXN0XG4gICAgICBpdGVtcyA9IFtdO1xuICAgICAgZm9yIChpZCBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgICBpZiAoZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcmRlcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlkc1tpXSA9IGl0ZW1zW2ldW3RoaXMuX2ZpZWxkSWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgZm9yIChpZCBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGlkLCB0eXBlKTtcbiAgICAgICAgICBpZiAoZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZHMucHVzaChpdGVtW3RoaXMuX2ZpZWxkSWRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2V0IGFsbCBpdGVtc1xuICAgIGlmIChvcmRlcikge1xuICAgICAgLy8gY3JlYXRlIGFuIG9yZGVyZWQgbGlzdFxuICAgICAgaXRlbXMgPSBbXTtcbiAgICAgIGZvciAoaWQgaW4gZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGRhdGFbaWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zb3J0KGl0ZW1zLCBvcmRlcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlkc1tpXSA9IGl0ZW1zW2ldW3RoaXMuX2ZpZWxkSWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSB1bm9yZGVyZWQgbGlzdFxuICAgICAgZm9yIChpZCBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICAgICAgICBpZHMucHVzaChpdGVtW3RoaXMuX2ZpZWxkSWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERhdGFTZXQgaXRzZWxmLiBJcyBvdmVyd3JpdHRlbiBmb3IgZXhhbXBsZSBieSB0aGUgRGF0YVZpZXcsXG4gKiB3aGljaCByZXR1cm5zIHRoZSBEYXRhU2V0IGl0IGlzIGNvbm5lY3RlZCB0byBpbnN0ZWFkLlxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5nZXREYXRhU2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBldmVyeSBpdGVtIGluIHRoZSBkYXRhc2V0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3QuPFN0cmluZywgU3RyaW5nPn0gW3R5cGVdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmdbXX0gW2ZpZWxkc10gZmlsdGVyIGZpZWxkc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IFtmaWx0ZXJdIGZpbHRlciBpdGVtc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgZnVuY3Rpb259IFtvcmRlcl0gT3JkZXIgdGhlIGl0ZW1zIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGZpZWxkIG5hbWUgb3IgY3VzdG9tIHNvcnQgZnVuY3Rpb24uXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGZpbHRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIsXG4gICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdGhpcy5fb3B0aW9ucy50eXBlLFxuICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBpdGVtLFxuICAgICAgaWQ7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vcmRlcikge1xuICAgIC8vIGV4ZWN1dGUgZm9yRWFjaCBvbiBvcmRlcmVkIGxpc3RcbiAgICB2YXIgaXRlbXMgPSB0aGlzLmdldChvcHRpb25zKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgaWQgPSBpdGVtW3RoaXMuX2ZpZWxkSWRdO1xuICAgICAgY2FsbGJhY2soaXRlbSwgaWQpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyB1bm9yZGVyZWRcbiAgICBmb3IgKGlkIGluIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBpdGVtID0gdGhpcy5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGNhbGxiYWNrKGl0ZW0sIGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNYXAgZXZlcnkgaXRlbSBpbiB0aGUgZGF0YXNldC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFt0eXBlXVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nW119IFtmaWVsZHNdIGZpbHRlciBmaWVsZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JqZWN0W119IG1hcHBlZEl0ZW1zXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgZmlsdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcixcbiAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCB0aGlzLl9vcHRpb25zLnR5cGUsXG4gICAgICBtYXBwZWRJdGVtcyA9IFtdLFxuICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICBpdGVtO1xuXG4gIC8vIGNvbnZlcnQgYW5kIGZpbHRlciBpdGVtc1xuICBmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBpdGVtID0gdGhpcy5fZ2V0SXRlbShpZCwgdHlwZSk7XG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgbWFwcGVkSXRlbXMucHVzaChjYWxsYmFjayhpdGVtLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG9yZGVyIGl0ZW1zXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3JkZXIpIHtcbiAgICB0aGlzLl9zb3J0KG1hcHBlZEl0ZW1zLCBvcHRpb25zLm9yZGVyKTtcbiAgfVxuXG4gIHJldHVybiBtYXBwZWRJdGVtcztcbn07XG5cbi8qKlxuICogRmlsdGVyIHRoZSBmaWVsZHMgb2YgYW4gaXRlbVxuICogQHBhcmFtIHtPYmplY3QgfCBudWxsfSBpdGVtXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBmaWVsZHMgICAgIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBmaWx0ZXJlZEl0ZW0gb3IgbnVsbCBpZiBubyBpdGVtIGlzIHByb3ZpZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fZmlsdGVyRmllbGRzID0gZnVuY3Rpb24gKGl0ZW0sIGZpZWxkcykge1xuICBpZiAoIWl0ZW0pIHsgLy8gaXRlbSBpcyBudWxsXG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICB2YXIgZmlsdGVyZWRJdGVtID0ge307XG5cbiAgaWYoQXJyYXkuaXNBcnJheShmaWVsZHMpKXtcbiAgICBmb3IgKHZhciBmaWVsZCBpbiBpdGVtKSB7XG4gICAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eShmaWVsZCkgJiYgKGZpZWxkcy5pbmRleE9mKGZpZWxkKSAhPSAtMSkpIHtcbiAgICAgICAgZmlsdGVyZWRJdGVtW2ZpZWxkXSA9IGl0ZW1bZmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgfWVsc2V7XG4gICAgZm9yICh2YXIgZmllbGQgaW4gaXRlbSkge1xuICAgICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkoZmllbGQpICYmIGZpZWxkcy5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgZmlsdGVyZWRJdGVtW2ZpZWxkc1tmaWVsZF1dID0gaXRlbVtmaWVsZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbHRlcmVkSXRlbTtcbn07XG5cbi8qKlxuICogU29ydCB0aGUgcHJvdmlkZWQgYXJyYXkgd2l0aCBpdGVtc1xuICogQHBhcmFtIHtPYmplY3RbXX0gaXRlbXNcbiAqIEBwYXJhbSB7U3RyaW5nIHwgZnVuY3Rpb259IG9yZGVyICAgICAgQSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuX3NvcnQgPSBmdW5jdGlvbiAoaXRlbXMsIG9yZGVyKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKG9yZGVyKSkge1xuICAgIC8vIG9yZGVyIGJ5IHByb3ZpZGVkIGZpZWxkIG5hbWVcbiAgICB2YXIgbmFtZSA9IG9yZGVyOyAvLyBmaWVsZCBuYW1lXG4gICAgaXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIGF2ID0gYVtuYW1lXTtcbiAgICAgIHZhciBidiA9IGJbbmFtZV07XG4gICAgICByZXR1cm4gKGF2ID4gYnYpID8gMSA6ICgoYXYgPCBidikgPyAtMSA6IDApO1xuICAgIH0pO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIG9yZGVyIGJ5IHNvcnQgZnVuY3Rpb25cbiAgICBpdGVtcy5zb3J0KG9yZGVyKTtcbiAgfVxuICAvLyBUT0RPOiBleHRlbmQgb3JkZXIgYnkgYW4gT2JqZWN0IHtmaWVsZDpTdHJpbmcsIGRpcmVjdGlvbjpTdHJpbmd9XG4gIC8vICAgICAgIHdoZXJlIGRpcmVjdGlvbiBjYW4gYmUgJ2FzYycgb3IgJ2Rlc2MnXG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09yZGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBvYmplY3QgYnkgcG9pbnRlciBvciBieSBpZFxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBPYmplY3QgfCBBcnJheX0gaWQgT2JqZWN0IG9yIGlkLCBvciBhbiBhcnJheSB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RzIG9yIGlkcyB0byBiZSByZW1vdmVkXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5fSByZW1vdmVkSWRzXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpZCwgc2VuZGVySWQpIHtcbiAgdmFyIHJlbW92ZWRJZHMgPSBbXSxcbiAgICAgIGksIGxlbiwgcmVtb3ZlZElkO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZW1vdmVkSWQgPSB0aGlzLl9yZW1vdmUoaWRbaV0pO1xuICAgICAgaWYgKHJlbW92ZWRJZCAhPSBudWxsKSB7XG4gICAgICAgIHJlbW92ZWRJZHMucHVzaChyZW1vdmVkSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICByZW1vdmVkSWQgPSB0aGlzLl9yZW1vdmUoaWQpO1xuICAgIGlmIChyZW1vdmVkSWQgIT0gbnVsbCkge1xuICAgICAgcmVtb3ZlZElkcy5wdXNoKHJlbW92ZWRJZCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbW92ZWRJZHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcigncmVtb3ZlJywge2l0ZW1zOiByZW1vdmVkSWRzfSwgc2VuZGVySWQpO1xuICB9XG5cbiAgcmV0dXJuIHJlbW92ZWRJZHM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGJ5IGl0cyBpZFxuICogQHBhcmFtIHtOdW1iZXIgfCBTdHJpbmcgfCBPYmplY3R9IGlkICAgaWQgb3IgaXRlbVxuICogQHJldHVybnMge051bWJlciB8IFN0cmluZyB8IG51bGx9IGlkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlmICh1dGlsLmlzTnVtYmVyKGlkKSB8fCB1dGlsLmlzU3RyaW5nKGlkKSkge1xuICAgIGlmICh0aGlzLl9kYXRhW2lkXSkge1xuICAgICAgZGVsZXRlIHRoaXMuX2RhdGFbaWRdO1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaWQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgaXRlbUlkID0gaWRbdGhpcy5fZmllbGRJZF07XG4gICAgaWYgKGl0ZW1JZCAmJiB0aGlzLl9kYXRhW2l0ZW1JZF0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9kYXRhW2l0ZW1JZF07XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgcmV0dXJuIGl0ZW1JZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBkYXRhXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NlbmRlcklkXSBPcHRpb25hbCBzZW5kZXIgaWRcbiAqIEByZXR1cm4ge0FycmF5fSByZW1vdmVkSWRzICAgIFRoZSBpZHMgb2YgYWxsIHJlbW92ZWQgaXRlbXNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoc2VuZGVySWQpIHtcbiAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2RhdGEpO1xuXG4gIHRoaXMuX2RhdGEgPSB7fTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHtpdGVtczogaWRzfSwgc2VuZGVySWQpO1xuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIGl0ZW0gd2l0aCBtYXhpbXVtIHZhbHVlIG9mIGEgc3BlY2lmaWVkIGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge09iamVjdCB8IG51bGx9IGl0ZW0gIEl0ZW0gY29udGFpbmluZyBtYXggdmFsdWUsIG9yIG51bGwgaWYgbm8gaXRlbXNcbiAqL1xuRGF0YVNldC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgIG1heCA9IG51bGwsXG4gICAgICBtYXhGaWVsZCA9IG51bGw7XG5cbiAgZm9yICh2YXIgaWQgaW4gZGF0YSkge1xuICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW2lkXTtcbiAgICAgIHZhciBpdGVtRmllbGQgPSBpdGVtW2ZpZWxkXTtcbiAgICAgIGlmIChpdGVtRmllbGQgIT0gbnVsbCAmJiAoIW1heCB8fCBpdGVtRmllbGQgPiBtYXhGaWVsZCkpIHtcbiAgICAgICAgbWF4ID0gaXRlbTtcbiAgICAgICAgbWF4RmllbGQgPSBpdGVtRmllbGQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1heDtcbn07XG5cbi8qKlxuICogRmluZCB0aGUgaXRlbSB3aXRoIG1pbmltdW0gdmFsdWUgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gaXRlbSAgSXRlbSBjb250YWluaW5nIG1heCB2YWx1ZSwgb3IgbnVsbCBpZiBubyBpdGVtc1xuICovXG5EYXRhU2V0LnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgbWluID0gbnVsbCxcbiAgICAgIG1pbkZpZWxkID0gbnVsbDtcblxuICBmb3IgKHZhciBpZCBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGFbaWRdO1xuICAgICAgdmFyIGl0ZW1GaWVsZCA9IGl0ZW1bZmllbGRdO1xuICAgICAgaWYgKGl0ZW1GaWVsZCAhPSBudWxsICYmICghbWluIHx8IGl0ZW1GaWVsZCA8IG1pbkZpZWxkKSkge1xuICAgICAgICBtaW4gPSBpdGVtO1xuICAgICAgICBtaW5GaWVsZCA9IGl0ZW1GaWVsZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufTtcblxuLyoqXG4gKiBGaW5kIGFsbCBkaXN0aW5jdCB2YWx1ZXMgb2YgYSBzcGVjaWZpZWQgZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7QXJyYXl9IHZhbHVlcyAgQXJyYXkgY29udGFpbmluZyBhbGwgZGlzdGluY3QgdmFsdWVzLiBJZiBkYXRhIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBkbyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIGZpZWxkIGFyZSBpZ25vcmVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJldHVybmVkIGFycmF5IGlzIHVub3JkZXJlZC5cbiAqL1xuRGF0YVNldC5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBmaWVsZFR5cGUgPSB0aGlzLl9vcHRpb25zLnR5cGUgJiYgdGhpcy5fb3B0aW9ucy50eXBlW2ZpZWxkXSB8fCBudWxsO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgaTtcblxuICBmb3IgKHZhciBwcm9wIGluIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhW3Byb3BdO1xuICAgICAgdmFyIHZhbHVlID0gaXRlbVtmaWVsZF07XG4gICAgICB2YXIgZXhpc3RzID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBpZiAodmFsdWVzW2ldID09IHZhbHVlKSB7XG4gICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFleGlzdHMgJiYgKHZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhbHVlc1tjb3VudF0gPSB2YWx1ZTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZmllbGRUeXBlKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gdXRpbC5jb252ZXJ0KHZhbHVlc1tpXSwgZmllbGRUeXBlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgaXRlbS4gV2lsbCBmYWlsIHdoZW4gYW4gaXRlbSB3aXRoIHRoZSBzYW1lIGlkIGFscmVhZHkgZXhpc3RzLlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAqIEByZXR1cm4ge1N0cmluZ30gaWRcbiAqIEBwcml2YXRlXG4gKi9cbkRhdGFTZXQucHJvdG90eXBlLl9hZGRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGlkID0gaXRlbVt0aGlzLl9maWVsZElkXTtcblxuICBpZiAoaWQgIT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGlzIGlkIGlzIGFscmVhZHkgdGFrZW5cbiAgICBpZiAodGhpcy5fZGF0YVtpZF0pIHtcbiAgICAgIC8vIGl0ZW0gYWxyZWFkeSBleGlzdHNcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBpdGVtOiBpdGVtIHdpdGggaWQgJyArIGlkICsgJyBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnZW5lcmF0ZSBhbiBpZFxuICAgIGlkID0gdXRpbC5yYW5kb21VVUlEKCk7XG4gICAgaXRlbVt0aGlzLl9maWVsZElkXSA9IGlkO1xuICB9XG5cbiAgdmFyIGQgPSB7fTtcbiAgZm9yICh2YXIgZmllbGQgaW4gaXRlbSkge1xuICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgdmFyIGZpZWxkVHlwZSA9IHRoaXMuX3R5cGVbZmllbGRdOyAgLy8gdHlwZSBtYXkgYmUgdW5kZWZpbmVkXG4gICAgICBkW2ZpZWxkXSA9IHV0aWwuY29udmVydChpdGVtW2ZpZWxkXSwgZmllbGRUeXBlKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fZGF0YVtpZF0gPSBkO1xuICB0aGlzLmxlbmd0aCsrO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbi8qKlxuICogR2V0IGFuIGl0ZW0uIEZpZWxkcyBjYW4gYmUgY29udmVydGVkIHRvIGEgc3BlY2lmaWMgdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBTdHJpbmc+fSBbdHlwZXNdICBmaWVsZCB0eXBlcyB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtPYmplY3QgfCBudWxsfSBpdGVtXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCwgdHlwZXMpIHtcbiAgdmFyIGZpZWxkLCB2YWx1ZTtcblxuICAvLyBnZXQgdGhlIGl0ZW0gZnJvbSB0aGUgZGF0YXNldFxuICB2YXIgcmF3ID0gdGhpcy5fZGF0YVtpZF07XG4gIGlmICghcmF3KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBjb252ZXJ0IHRoZSBpdGVtcyBmaWVsZCB0eXBlc1xuICB2YXIgY29udmVydGVkID0ge307XG4gIGlmICh0eXBlcykge1xuICAgIGZvciAoZmllbGQgaW4gcmF3KSB7XG4gICAgICBpZiAocmF3Lmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICB2YWx1ZSA9IHJhd1tmaWVsZF07XG4gICAgICAgIGNvbnZlcnRlZFtmaWVsZF0gPSB1dGlsLmNvbnZlcnQodmFsdWUsIHR5cGVzW2ZpZWxkXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vIGZpZWxkIHR5cGVzIHNwZWNpZmllZCwgbm8gY29udmVydGluZyBuZWVkZWRcbiAgICBmb3IgKGZpZWxkIGluIHJhdykge1xuICAgICAgaWYgKHJhdy5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgdmFsdWUgPSByYXdbZmllbGRdO1xuICAgICAgICBjb252ZXJ0ZWRbZmllbGRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhIHNpbmdsZSBpdGVtOiBtZXJnZSB3aXRoIGV4aXN0aW5nIGl0ZW0uXG4gKiBXaWxsIGZhaWwgd2hlbiB0aGUgaXRlbSBoYXMgbm8gaWQsIG9yIHdoZW4gdGhlcmUgZG9lcyBub3QgZXhpc3QgYW4gaXRlbVxuICogd2l0aCB0aGUgc2FtZSBpZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGlkXG4gKiBAcHJpdmF0ZVxuICovXG5EYXRhU2V0LnByb3RvdHlwZS5fdXBkYXRlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBpZCA9IGl0ZW1bdGhpcy5fZmllbGRJZF07XG4gIGlmIChpZCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgaXRlbTogaXRlbSBoYXMgbm8gaWQgKGl0ZW06ICcgKyBKU09OLnN0cmluZ2lmeShpdGVtKSArICcpJyk7XG4gIH1cbiAgdmFyIGQgPSB0aGlzLl9kYXRhW2lkXTtcbiAgaWYgKCFkKSB7XG4gICAgLy8gaXRlbSBkb2Vzbid0IGV4aXN0XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIGl0ZW06IG5vIGl0ZW0gd2l0aCBpZCAnICsgaWQgKyAnIGZvdW5kJyk7XG4gIH1cblxuICAvLyBtZXJnZSB3aXRoIGN1cnJlbnQgaXRlbVxuICBmb3IgKHZhciBmaWVsZCBpbiBpdGVtKSB7XG4gICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICB2YXIgZmllbGRUeXBlID0gdGhpcy5fdHlwZVtmaWVsZF07ICAvLyB0eXBlIG1heSBiZSB1bmRlZmluZWRcbiAgICAgIGRbZmllbGRdID0gdXRpbC5jb252ZXJ0KGl0ZW1bZmllbGRdLCBmaWVsZFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNldDtcbiJdfQ==
},{"./Queue":17,"./util":46}],16:[function(require,module,exports){
'use strict';

var util = require('./util');
var DataSet = require('./DataSet');

/**
 * DataView
 *
 * a dataview offers a filtered view on a dataset or an other dataview.
 *
 * @param {DataSet | DataView} data
 * @param {Object} [options]   Available options: see method get
 *
 * @constructor DataView
 */
function DataView(data, options) {
  this._data = null;
  this._ids = {}; // ids of the items currently in memory (just contains a boolean true)
  this.length = 0; // number of items in the DataView
  this._options = options || {};
  this._fieldId = 'id'; // name of the field containing id
  this._subscribers = {}; // event subscribers

  var me = this;
  this.listener = function () {
    me._onEvent.apply(me, arguments);
  };

  this.setData(data);
}

// TODO: implement a function .config() to dynamically update things like configured filter
// and trigger changes accordingly

/**
 * Set a data source for the view
 * @param {DataSet | DataView} data
 */
DataView.prototype.setData = function (data) {
  var ids, i, len;

  if (this._data) {
    // unsubscribe from current dataset
    if (this._data.off) {
      this._data.off('*', this.listener);
    }

    // trigger a remove of all items in memory
    ids = [];
    for (var id in this._ids) {
      if (this._ids.hasOwnProperty(id)) {
        ids.push(id);
      }
    }
    this._ids = {};
    this.length = 0;
    this._trigger('remove', { items: ids });
  }

  this._data = data;

  if (this._data) {
    // update fieldId
    this._fieldId = this._options.fieldId || this._data && this._data.options && this._data.options.fieldId || 'id';

    // trigger an add of all added items
    ids = this._data.getIds({ filter: this._options && this._options.filter });
    for (i = 0, len = ids.length; i < len; i++) {
      id = ids[i];
      this._ids[id] = true;
    }
    this.length = ids.length;
    this._trigger('add', { items: ids });

    // subscribe to new dataset
    if (this._data.on) {
      this._data.on('*', this.listener);
    }
  }
};

/**
 * Refresh the DataView. Useful when the DataView has a filter function
 * containing a variable parameter.
 */
DataView.prototype.refresh = function () {
  var id;
  var ids = this._data.getIds({ filter: this._options && this._options.filter });
  var newIds = {};
  var added = [];
  var removed = [];

  // check for additions
  for (var i = 0; i < ids.length; i++) {
    id = ids[i];
    newIds[id] = true;
    if (!this._ids[id]) {
      added.push(id);
      this._ids[id] = true;
      this.length++;
    }
  }

  // check for removals
  for (id in this._ids) {
    if (this._ids.hasOwnProperty(id)) {
      if (!newIds[id]) {
        removed.push(id);
        delete this._ids[id];
        this.length--;
      }
    }
  }

  // trigger events
  if (added.length) {
    this._trigger('add', { items: added });
  }
  if (removed.length) {
    this._trigger('remove', { items: removed });
  }
};

/**
 * Get data from the data view
 *
 * Usage:
 *
 *     get()
 *     get(options: Object)
 *     get(options: Object, data: Array | DataTable)
 *
 *     get(id: Number)
 *     get(id: Number, options: Object)
 *     get(id: Number, options: Object, data: Array | DataTable)
 *
 *     get(ids: Number[])
 *     get(ids: Number[], options: Object)
 *     get(ids: Number[], options: Object, data: Array | DataTable)
 *
 * Where:
 *
 * {Number | String} id         The id of an item
 * {Number[] | String{}} ids    An array with ids of items
 * {Object} options             An Object with options. Available options:
 *                              {String} [type] Type of data to be returned. Can
 *                                              be 'DataTable' or 'Array' (default)
 *                              {Object.<String, String>} [convert]
 *                              {String[]} [fields] field names to be returned
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * {Array | DataTable} [data]   If provided, items will be appended to this
 *                              array or table. Required in case of Google
 *                              DataTable.
 * @param args
 */
DataView.prototype.get = function (args) {
  var me = this;

  // parse the arguments
  var ids, options, data;
  var firstType = util.getType(arguments[0]);
  if (firstType == 'String' || firstType == 'Number' || firstType == 'Array') {
    // get(id(s) [, options] [, data])
    ids = arguments[0]; // can be a single id or an array with ids
    options = arguments[1];
    data = arguments[2];
  } else {
    // get([, options] [, data])
    options = arguments[0];
    data = arguments[1];
  }

  // extend the options with the default options and provided options
  var viewOptions = util.extend({}, this._options, options);

  // create a combined filter method when needed
  if (this._options.filter && options && options.filter) {
    viewOptions.filter = function (item) {
      return me._options.filter(item) && options.filter(item);
    };
  }

  // build up the call to the linked data set
  var getArguments = [];
  if (ids != undefined) {
    getArguments.push(ids);
  }
  getArguments.push(viewOptions);
  getArguments.push(data);

  return this._data && this._data.get.apply(this._data, getArguments);
};

/**
 * Get ids of all items or from a filtered set of items.
 * @param {Object} [options]    An Object with options. Available options:
 *                              {function} [filter] filter items
 *                              {String | function} [order] Order the items by
 *                                  a field name or custom sort function.
 * @return {Array} ids
 */
DataView.prototype.getIds = function (options) {
  var ids;

  if (this._data) {
    var defaultFilter = this._options.filter;
    var filter;

    if (options && options.filter) {
      if (defaultFilter) {
        filter = function (item) {
          return defaultFilter(item) && options.filter(item);
        };
      } else {
        filter = options.filter;
      }
    } else {
      filter = defaultFilter;
    }

    ids = this._data.getIds({
      filter: filter,
      order: options && options.order
    });
  } else {
    ids = [];
  }

  return ids;
};

/**
 * Get the DataSet to which this DataView is connected. In case there is a chain
 * of multiple DataViews, the root DataSet of this chain is returned.
 * @return {DataSet} dataSet
 */
DataView.prototype.getDataSet = function () {
  var dataSet = this;
  while (dataSet instanceof DataView) {
    dataSet = dataSet._data;
  }
  return dataSet || null;
};

/**
 * Event listener. Will propagate all events from the connected data set to
 * the subscribers of the DataView, but will filter the items and only trigger
 * when there are changes in the filtered data set.
 * @param {String} event
 * @param {Object | null} params
 * @param {String} senderId
 * @private
 */
DataView.prototype._onEvent = function (event, params, senderId) {
  var i, len, id, item;
  var ids = params && params.items;
  var data = this._data;
  var updatedData = [];
  var added = [];
  var updated = [];
  var removed = [];

  if (ids && data) {
    switch (event) {
      case 'add':
        // filter the ids of the added items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);
          if (item) {
            this._ids[id] = true;
            added.push(id);
          }
        }

        break;

      case 'update':
        // determine the event from the views viewpoint: an updated
        // item can be added, updated, or removed from this view.
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          item = this.get(id);

          if (item) {
            if (this._ids[id]) {
              updated.push(id);
              updatedData.push(params.data[i]);
            } else {
              this._ids[id] = true;
              added.push(id);
            }
          } else {
            if (this._ids[id]) {
              delete this._ids[id];
              removed.push(id);
            } else {
              // nothing interesting for me :-(
            }
          }
        }

        break;

      case 'remove':
        // filter the ids of the removed items
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          if (this._ids[id]) {
            delete this._ids[id];
            removed.push(id);
          }
        }

        break;
    }

    this.length += added.length - removed.length;

    if (added.length) {
      this._trigger('add', { items: added }, senderId);
    }
    if (updated.length) {
      this._trigger('update', { items: updated, data: updatedData }, senderId);
    }
    if (removed.length) {
      this._trigger('remove', { items: removed }, senderId);
    }
  }
};

// copy subscription functionality from DataSet
DataView.prototype.on = DataSet.prototype.on;
DataView.prototype.off = DataSet.prototype.off;
DataView.prototype._trigger = DataSet.prototype._trigger;

// TODO: make these functions deprecated (replaced with `on` and `off` since version 0.5)
DataView.prototype.subscribe = DataView.prototype.on;
DataView.prototype.unsubscribe = DataView.prototype.off;

module.exports = DataView;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9EYXRhVmlldy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM3QixJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7Ozs7Ozs7Ozs7OztBQVluQyxTQUFTLFFBQVEsQ0FBRSxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ2hDLE1BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0FBQ2xCLE1BQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ2YsTUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDaEIsTUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLElBQUksRUFBRSxDQUFDO0FBQzlCLE1BQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQ3JCLE1BQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDOztBQUV2QixNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUM7QUFDZCxNQUFJLENBQUMsUUFBUSxHQUFHLFlBQVk7QUFDMUIsTUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQ2xDLENBQUM7O0FBRUYsTUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUNwQjs7Ozs7Ozs7O0FBU0QsUUFBUSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsVUFBVSxJQUFJLEVBQUU7QUFDM0MsTUFBSSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQzs7QUFFaEIsTUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFOztBQUVkLFFBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUU7QUFDbEIsVUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUNwQzs7O0FB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QUFNLEVBQUU7QUFDbEIsVUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBQyxLQUFLLEVBQUUsT0FBTyxFQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7S0FDckQ7R0FDRjtDQUNGLENBQUM7OztBQUdGLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDO0FBQzdDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDO0FBQy9DLFFBQVEsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDOzs7QUFHekQsUUFBUSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUM7QUFDckQsUUFBUSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7O0FBRXhELE1BQU0sQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDIiwiZmlsZSI6Ii91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9EYXRhVmlldy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgRGF0YVNldCA9IHJlcXVpcmUoJy4vRGF0YVNldCcpO1xuXG4vKipcbiAqIERhdGFWaWV3XG4gKlxuICogYSBkYXRhdmlldyBvZmZlcnMgYSBmaWx0ZXJlZCB2aWV3IG9uIGEgZGF0YXNldCBvciBhbiBvdGhlciBkYXRhdmlldy5cbiAqXG4gKiBAcGFyYW0ge0RhdGFTZXQgfCBEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgIEF2YWlsYWJsZSBvcHRpb25zOiBzZWUgbWV0aG9kIGdldFxuICpcbiAqIEBjb25zdHJ1Y3RvciBEYXRhVmlld1xuICovXG5mdW5jdGlvbiBEYXRhVmlldyAoZGF0YSwgb3B0aW9ucykge1xuICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgdGhpcy5faWRzID0ge307IC8vIGlkcyBvZiB0aGUgaXRlbXMgY3VycmVudGx5IGluIG1lbW9yeSAoanVzdCBjb250YWlucyBhIGJvb2xlYW4gdHJ1ZSlcbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIERhdGFWaWV3XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9maWVsZElkID0gJ2lkJzsgLy8gbmFtZSBvZiB0aGUgZmllbGQgY29udGFpbmluZyBpZFxuICB0aGlzLl9zdWJzY3JpYmVycyA9IHt9OyAvLyBldmVudCBzdWJzY3JpYmVyc1xuXG4gIHZhciBtZSA9IHRoaXM7XG4gIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgbWUuX29uRXZlbnQuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdGhpcy5zZXREYXRhKGRhdGEpO1xufVxuXG4vLyBUT0RPOiBpbXBsZW1lbnQgYSBmdW5jdGlvbiAuY29uZmlnKCkgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoaW5ncyBsaWtlIGNvbmZpZ3VyZWQgZmlsdGVyXG4vLyBhbmQgdHJpZ2dlciBjaGFuZ2VzIGFjY29yZGluZ2x5XG5cbi8qKlxuICogU2V0IGEgZGF0YSBzb3VyY2UgZm9yIHRoZSB2aWV3XG4gKiBAcGFyYW0ge0RhdGFTZXQgfCBEYXRhVmlld30gZGF0YVxuICovXG5EYXRhVmlldy5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBpZHMsIGksIGxlbjtcblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gY3VycmVudCBkYXRhc2V0XG4gICAgaWYgKHRoaXMuX2RhdGEub2ZmKSB7XG4gICAgICB0aGlzLl9kYXRhLm9mZignKicsIHRoaXMubGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgYSByZW1vdmUgb2YgYWxsIGl0ZW1zIGluIG1lbW9yeVxuICAgIGlkcyA9IFtdO1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuX2lkcykge1xuICAgICAgaWYgKHRoaXMuX2lkcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgaWRzLnB1c2goaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pZHMgPSB7fTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fdHJpZ2dlcigncmVtb3ZlJywge2l0ZW1zOiBpZHN9KTtcbiAgfVxuXG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xuXG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgLy8gdXBkYXRlIGZpZWxkSWRcbiAgICB0aGlzLl9maWVsZElkID0gdGhpcy5fb3B0aW9ucy5maWVsZElkIHx8XG4gICAgICAgICh0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEub3B0aW9ucyAmJiB0aGlzLl9kYXRhLm9wdGlvbnMuZmllbGRJZCkgfHxcbiAgICAgICAgJ2lkJztcblxuICAgIC8vIHRyaWdnZXIgYW4gYWRkIG9mIGFsbCBhZGRlZCBpdGVtc1xuICAgIGlkcyA9IHRoaXMuX2RhdGEuZ2V0SWRzKHtmaWx0ZXI6IHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5maWx0ZXJ9KTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgdGhpcy5faWRzW2lkXSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gaWRzLmxlbmd0aDtcbiAgICB0aGlzLl90cmlnZ2VyKCdhZGQnLCB7aXRlbXM6IGlkc30pO1xuXG4gICAgLy8gc3Vic2NyaWJlIHRvIG5ldyBkYXRhc2V0XG4gICAgaWYgKHRoaXMuX2RhdGEub24pIHtcbiAgICAgIHRoaXMuX2RhdGEub24oJyonLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVmcmVzaCB0aGUgRGF0YVZpZXcuIFVzZWZ1bCB3aGVuIHRoZSBEYXRhVmlldyBoYXMgYSBmaWx0ZXIgZnVuY3Rpb25cbiAqIGNvbnRhaW5pbmcgYSB2YXJpYWJsZSBwYXJhbWV0ZXIuXG4gKi9cbkRhdGFWaWV3LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQ7XG4gIHZhciBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7ZmlsdGVyOiB0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMuZmlsdGVyfSk7XG4gIHZhciBuZXdJZHMgPSB7fTtcbiAgdmFyIGFkZGVkID0gW107XG4gIHZhciByZW1vdmVkID0gW107XG5cbiAgLy8gY2hlY2sgZm9yIGFkZGl0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgIGlkID0gaWRzW2ldO1xuICAgIG5ld0lkc1tpZF0gPSB0cnVlO1xuICAgIGlmICghdGhpcy5faWRzW2lkXSkge1xuICAgICAgYWRkZWQucHVzaChpZCk7XG4gICAgICB0aGlzLl9pZHNbaWRdID0gdHJ1ZTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgZm9yIHJlbW92YWxzXG4gIGZvciAoaWQgaW4gdGhpcy5faWRzKSB7XG4gICAgaWYgKHRoaXMuX2lkcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIGlmICghbmV3SWRzW2lkXSkge1xuICAgICAgICByZW1vdmVkLnB1c2goaWQpO1xuICAgICAgICBkZWxldGUgdGhpcy5faWRzW2lkXTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyB0cmlnZ2VyIGV2ZW50c1xuICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgdGhpcy5fdHJpZ2dlcignYWRkJywge2l0ZW1zOiBhZGRlZH0pO1xuICB9XG4gIGlmIChyZW1vdmVkLmxlbmd0aCkge1xuICAgIHRoaXMuX3RyaWdnZXIoJ3JlbW92ZScsIHtpdGVtczogcmVtb3ZlZH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBkYXRhIGZyb20gdGhlIGRhdGEgdmlld1xuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgICBnZXQoKVxuICogICAgIGdldChvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogICAgIGdldChpZDogTnVtYmVyKVxuICogICAgIGdldChpZDogTnVtYmVyLCBvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KGlkOiBOdW1iZXIsIG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogICAgIGdldChpZHM6IE51bWJlcltdKVxuICogICAgIGdldChpZHM6IE51bWJlcltdLCBvcHRpb25zOiBPYmplY3QpXG4gKiAgICAgZ2V0KGlkczogTnVtYmVyW10sIG9wdGlvbnM6IE9iamVjdCwgZGF0YTogQXJyYXkgfCBEYXRhVGFibGUpXG4gKlxuICogV2hlcmU6XG4gKlxuICoge051bWJlciB8IFN0cmluZ30gaWQgICAgICAgICBUaGUgaWQgb2YgYW4gaXRlbVxuICoge051bWJlcltdIHwgU3RyaW5ne319IGlkcyAgICBBbiBhcnJheSB3aXRoIGlkcyBvZiBpdGVtc1xuICoge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gW3R5cGVdIFR5cGUgb2YgZGF0YSB0byBiZSByZXR1cm5lZC4gQ2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSAnRGF0YVRhYmxlJyBvciAnQXJyYXknIChkZWZhdWx0KVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0LjxTdHJpbmcsIFN0cmluZz59IFtjb252ZXJ0XVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nW119IFtmaWVsZHNdIGZpZWxkIG5hbWVzIHRvIGJlIHJldHVybmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtmdW5jdGlvbn0gW2ZpbHRlcl0gZmlsdGVyIGl0ZW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBmdW5jdGlvbn0gW29yZGVyXSBPcmRlciB0aGUgaXRlbXMgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgZmllbGQgbmFtZSBvciBjdXN0b20gc29ydCBmdW5jdGlvbi5cbiAqIHtBcnJheSB8IERhdGFUYWJsZX0gW2RhdGFdICAgSWYgcHJvdmlkZWQsIGl0ZW1zIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheSBvciB0YWJsZS4gUmVxdWlyZWQgaW4gY2FzZSBvZiBHb29nbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGF0YVRhYmxlLlxuICogQHBhcmFtIGFyZ3NcbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gcGFyc2UgdGhlIGFyZ3VtZW50c1xuICB2YXIgaWRzLCBvcHRpb25zLCBkYXRhO1xuICB2YXIgZmlyc3RUeXBlID0gdXRpbC5nZXRUeXBlKGFyZ3VtZW50c1swXSk7XG4gIGlmIChmaXJzdFR5cGUgPT0gJ1N0cmluZycgfHwgZmlyc3RUeXBlID09ICdOdW1iZXInIHx8IGZpcnN0VHlwZSA9PSAnQXJyYXknKSB7XG4gICAgLy8gZ2V0KGlkKHMpIFssIG9wdGlvbnNdIFssIGRhdGFdKVxuICAgIGlkcyA9IGFyZ3VtZW50c1swXTsgIC8vIGNhbiBiZSBhIHNpbmdsZSBpZCBvciBhbiBhcnJheSB3aXRoIGlkc1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgZGF0YSA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnZXQoWywgb3B0aW9uc10gWywgZGF0YV0pXG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICBkYXRhID0gYXJndW1lbnRzWzFdO1xuICB9XG5cbiAgLy8gZXh0ZW5kIHRoZSBvcHRpb25zIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucyBhbmQgcHJvdmlkZWQgb3B0aW9uc1xuICB2YXIgdmlld09wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgLy8gY3JlYXRlIGEgY29tYmluZWQgZmlsdGVyIG1ldGhvZCB3aGVuIG5lZWRlZFxuICBpZiAodGhpcy5fb3B0aW9ucy5maWx0ZXIgJiYgb3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikge1xuICAgIHZpZXdPcHRpb25zLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gbWUuX29wdGlvbnMuZmlsdGVyKGl0ZW0pICYmIG9wdGlvbnMuZmlsdGVyKGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJ1aWxkIHVwIHRoZSBjYWxsIHRvIHRoZSBsaW5rZWQgZGF0YSBzZXRcbiAgdmFyIGdldEFyZ3VtZW50cyA9IFtdO1xuICBpZiAoaWRzICE9IHVuZGVmaW5lZCkge1xuICAgIGdldEFyZ3VtZW50cy5wdXNoKGlkcyk7XG4gIH1cbiAgZ2V0QXJndW1lbnRzLnB1c2godmlld09wdGlvbnMpO1xuICBnZXRBcmd1bWVudHMucHVzaChkYXRhKTtcblxuICByZXR1cm4gdGhpcy5fZGF0YSAmJiB0aGlzLl9kYXRhLmdldC5hcHBseSh0aGlzLl9kYXRhLCBnZXRBcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBHZXQgaWRzIG9mIGFsbCBpdGVtcyBvciBmcm9tIGEgZmlsdGVyZWQgc2V0IG9mIGl0ZW1zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICBBbiBPYmplY3Qgd2l0aCBvcHRpb25zLiBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBbZmlsdGVyXSBmaWx0ZXIgaXRlbXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZyB8IGZ1bmN0aW9ufSBbb3JkZXJdIE9yZGVyIHRoZSBpdGVtcyBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBmaWVsZCBuYW1lIG9yIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLlxuICogQHJldHVybiB7QXJyYXl9IGlkc1xuICovXG5EYXRhVmlldy5wcm90b3R5cGUuZ2V0SWRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIGlkcztcblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIHZhciBkZWZhdWx0RmlsdGVyID0gdGhpcy5fb3B0aW9ucy5maWx0ZXI7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICBpZiAoZGVmYXVsdEZpbHRlcikge1xuICAgICAgICBmaWx0ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0RmlsdGVyKGl0ZW0pICYmIG9wdGlvbnMuZmlsdGVyKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmlsdGVyID0gZGVmYXVsdEZpbHRlcjtcbiAgICB9XG5cbiAgICBpZHMgPSB0aGlzLl9kYXRhLmdldElkcyh7XG4gICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgIG9yZGVyOiBvcHRpb25zICYmIG9wdGlvbnMub3JkZXJcbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZHMgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBpZHM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgRGF0YVNldCB0byB3aGljaCB0aGlzIERhdGFWaWV3IGlzIGNvbm5lY3RlZC4gSW4gY2FzZSB0aGVyZSBpcyBhIGNoYWluXG4gKiBvZiBtdWx0aXBsZSBEYXRhVmlld3MsIHRoZSByb290IERhdGFTZXQgb2YgdGhpcyBjaGFpbiBpcyByZXR1cm5lZC5cbiAqIEByZXR1cm4ge0RhdGFTZXR9IGRhdGFTZXRcbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLmdldERhdGFTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhU2V0ID0gdGhpcztcbiAgd2hpbGUgKGRhdGFTZXQgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIGRhdGFTZXQgPSBkYXRhU2V0Ll9kYXRhO1xuICB9XG4gIHJldHVybiBkYXRhU2V0IHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEV2ZW50IGxpc3RlbmVyLiBXaWxsIHByb3BhZ2F0ZSBhbGwgZXZlbnRzIGZyb20gdGhlIGNvbm5lY3RlZCBkYXRhIHNldCB0b1xuICogdGhlIHN1YnNjcmliZXJzIG9mIHRoZSBEYXRhVmlldywgYnV0IHdpbGwgZmlsdGVyIHRoZSBpdGVtcyBhbmQgb25seSB0cmlnZ2VyXG4gKiB3aGVuIHRoZXJlIGFyZSBjaGFuZ2VzIGluIHRoZSBmaWx0ZXJlZCBkYXRhIHNldC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3QgfCBudWxsfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZW5kZXJJZFxuICogQHByaXZhdGVcbiAqL1xuRGF0YVZpZXcucHJvdG90eXBlLl9vbkV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gIHZhciBpLCBsZW4sIGlkLCBpdGVtO1xuICB2YXIgaWRzID0gcGFyYW1zICYmIHBhcmFtcy5pdGVtcztcbiAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuICB2YXIgdXBkYXRlZERhdGEgPSBbXTtcbiAgdmFyIGFkZGVkID0gW107XG4gIHZhciB1cGRhdGVkID0gW107XG4gIHZhciByZW1vdmVkID0gW107XG5cbiAgaWYgKGlkcyAmJiBkYXRhKSB7XG4gICAgc3dpdGNoIChldmVudCkge1xuICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIGFkZGVkIGl0ZW1zXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlkID0gaWRzW2ldO1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgYWRkZWQucHVzaChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgZXZlbnQgZnJvbSB0aGUgdmlld3Mgdmlld3BvaW50OiBhbiB1cGRhdGVkXG4gICAgICAgIC8vIGl0ZW0gY2FuIGJlIGFkZGVkLCB1cGRhdGVkLCBvciByZW1vdmVkIGZyb20gdGhpcyB2aWV3LlxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZCA9IGlkc1tpXTtcbiAgICAgICAgICBpdGVtID0gdGhpcy5nZXQoaWQpO1xuXG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pZHNbaWRdKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChpZCk7XG4gICAgICAgICAgICAgIHVwZGF0ZWREYXRhLnB1c2gocGFyYW1zLmRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICBhZGRlZC5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faWRzW2lkXSkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faWRzW2lkXTtcbiAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBub3RoaW5nIGludGVyZXN0aW5nIGZvciBtZSA6LShcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgLy8gZmlsdGVyIHRoZSBpZHMgb2YgdGhlIHJlbW92ZWQgaXRlbXNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgICAgaWYgKHRoaXMuX2lkc1tpZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZHNbaWRdO1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCArPSBhZGRlZC5sZW5ndGggLSByZW1vdmVkLmxlbmd0aDtcblxuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2FkZCcsIHtpdGVtczogYWRkZWR9LCBzZW5kZXJJZCk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpZ2dlcigndXBkYXRlJywge2l0ZW1zOiB1cGRhdGVkLCBkYXRhOiB1cGRhdGVkRGF0YX0sIHNlbmRlcklkKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyKCdyZW1vdmUnLCB7aXRlbXM6IHJlbW92ZWR9LCBzZW5kZXJJZCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBjb3B5IHN1YnNjcmlwdGlvbiBmdW5jdGlvbmFsaXR5IGZyb20gRGF0YVNldFxuRGF0YVZpZXcucHJvdG90eXBlLm9uID0gRGF0YVNldC5wcm90b3R5cGUub247XG5EYXRhVmlldy5wcm90b3R5cGUub2ZmID0gRGF0YVNldC5wcm90b3R5cGUub2ZmO1xuRGF0YVZpZXcucHJvdG90eXBlLl90cmlnZ2VyID0gRGF0YVNldC5wcm90b3R5cGUuX3RyaWdnZXI7XG5cbi8vIFRPRE86IG1ha2UgdGhlc2UgZnVuY3Rpb25zIGRlcHJlY2F0ZWQgKHJlcGxhY2VkIHdpdGggYG9uYCBhbmQgYG9mZmAgc2luY2UgdmVyc2lvbiAwLjUpXG5EYXRhVmlldy5wcm90b3R5cGUuc3Vic2NyaWJlID0gRGF0YVZpZXcucHJvdG90eXBlLm9uO1xuRGF0YVZpZXcucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gRGF0YVZpZXcucHJvdG90eXBlLm9mZjtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldzsiXX0=
},{"./DataSet":15,"./util":46}],17:[function(require,module,exports){
/**
 * A queue
 * @param {Object} options
 *            Available options:
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @constructor
 */
'use strict';

function Queue(options) {
  // options
  this.delay = null;
  this.max = Infinity;

  // properties
  this._queue = [];
  this._timeout = null;
  this._extended = null;

  this.setOptions(options);
}

/**
 * Update the configuration of the queue
 * @param {Object} options
 *            Available options:
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @param options
 */
Queue.prototype.setOptions = function (options) {
  if (options && typeof options.delay !== 'undefined') {
    this.delay = options.delay;
  }
  if (options && typeof options.max !== 'undefined') {
    this.max = options.max;
  }

  this._flushIfNeeded();
};

/**
 * Extend an object with queuing functionality.
 * The object will be extended with a function flush, and the methods provided
 * in options.replace will be replaced with queued ones.
 * @param {Object} object
 * @param {Object} options
 *            Available options:
 *            - replace: Array.<string>
 *                               A list with method names of the methods
 *                               on the object to be replaced with queued ones.
 *            - delay: number    When provided, the queue will be flushed
 *                               automatically after an inactivity of this delay
 *                               in milliseconds.
 *                               Default value is null.
 *            - max: number      When the queue exceeds the given maximum number
 *                               of entries, the queue is flushed automatically.
 *                               Default value of max is Infinity.
 * @return {Queue} Returns the created queue
 */
Queue.extend = function (object, options) {
  var queue = new Queue(options);

  if (object.flush !== undefined) {
    throw new Error('Target object already has a property flush');
  }
  object.flush = function () {
    queue.flush();
  };

  var methods = [{
    name: 'flush',
    original: undefined
  }];

  if (options && options.replace) {
    for (var i = 0; i < options.replace.length; i++) {
      var name = options.replace[i];
      methods.push({
        name: name,
        original: object[name]
      });
      queue.replace(object, name);
    }
  }

  queue._extended = {
    object: object,
    methods: methods
  };

  return queue;
};

/**
 * Destroy the queue. The queue will first flush all queued actions, and in
 * case it has extended an object, will restore the original object.
 */
Queue.prototype.destroy = function () {
  this.flush();

  if (this._extended) {
    var object = this._extended.object;
    var methods = this._extended.methods;
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      if (method.original) {
        object[method.name] = method.original;
      } else {
        delete object[method.name];
      }
    }
    this._extended = null;
  }
};

/**
 * Replace a method on an object with a queued version
 * @param {Object} object   Object having the method
 * @param {string} method   The method name
 */
Queue.prototype.replace = function (object, method) {
  var me = this;
  var original = object[method];
  if (!original) {
    throw new Error('Method ' + method + ' undefined');
  }

  object[method] = function () {
    // create an Array with the arguments
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    // add this call to the queue
    me.queue({
      args: args,
      fn: original,
      context: this
    });
  };
};

/**
 * Queue a call
 * @param {function | {fn: function, args: Array} | {fn: function, args: Array, context: Object}} entry
 */
Queue.prototype.queue = function (entry) {
  if (typeof entry === 'function') {
    this._queue.push({ fn: entry });
  } else {
    this._queue.push(entry);
  }

  this._flushIfNeeded();
};

/**
 * Check whether the queue needs to be flushed
 * @private
 */
Queue.prototype._flushIfNeeded = function () {
  // flush when the maximum is exceeded.
  if (this._queue.length > this.max) {
    this.flush();
  }

  // flush after a period of inactivity when a delay is configured
  clearTimeout(this._timeout);
  if (this.queue.length > 0 && typeof this.delay === 'number') {
    var me = this;
    this._timeout = setTimeout(function () {
      me.flush();
    }, this.delay);
  }
};

/**
 * Flush all queued calls
 */
Queue.prototype.flush = function () {
  while (this._queue.length > 0) {
    var entry = this._queue.shift();
    entry.fn.apply(entry.context || entry.fn, entry.args || []);
  }
};

module.exports = Queue;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9RdWV1ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFhQSxTQUFTLEtBQUssQ0FBQyxPQUFPLEVBQUU7O0FBRXRCLE1BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0FBQ2xCLE1BQUksQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDOzs7QUFHcEIsTUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDakIsTUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7QUFDckIsTUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7O0FBRXRCLE1BQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDMUI7Ozs7Ozs7Ozs7Ozs7OztBQWVELEtBQUssQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLFVBQVUsT0FBTyxFQUFFO0FBQzlDLE1BQUksT0FBTyxJQUFJLE9BQU8sT0FBTyxDQUFDLEtBQUssS0FBSyxXQUFXLEVBQUU7QUFDbkQsUUFBSSxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO0dBQzVCO0FBQ0QsTUFBSSxPQUFPLElBQUksT0FBTyxPQUFPLENBQUMsR0FBRyxLQUFLLFdBQVcsRUFBRTtBQUNqRCxRQUFJLENBQUMsR0FBRyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUM7R0FDeEI7O0FBRUQsTUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO0NBQ3ZCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCRixLQUFLLENBQUMsTUFBTSxHQUFHLFVBQVUsTUFBTSxFQUFFLE9BQU8sRUFBRTtBQUN4QyxNQUFJLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFL0IsTUFBSSxNQUFNLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRTtBQUM5QixVQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7R0FD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RUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL1F1ZXVlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIHF1ZXVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgLSBkZWxheTogbnVtYmVyICAgIFdoZW4gcHJvdmlkZWQsIHRoZSBxdWV1ZSB3aWxsIGJlIGZsdXNoZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgYW4gaW5hY3Rpdml0eSBvZiB0aGlzIGRlbGF5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBtaWxsaXNlY29uZHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzIG51bGwuXG4gKiAgICAgICAgICAgIC0gbWF4OiBudW1iZXIgICAgICBXaGVuIHRoZSBxdWV1ZSBleGNlZWRzIHRoZSBnaXZlbiBtYXhpbXVtIG51bWJlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgZW50cmllcywgdGhlIHF1ZXVlIGlzIGZsdXNoZWQgYXV0b21hdGljYWxseS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgb2YgbWF4IGlzIEluZmluaXR5LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFF1ZXVlKG9wdGlvbnMpIHtcbiAgLy8gb3B0aW9uc1xuICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgdGhpcy5tYXggPSBJbmZpbml0eTtcblxuICAvLyBwcm9wZXJ0aWVzXG4gIHRoaXMuX3F1ZXVlID0gW107XG4gIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICB0aGlzLl9leHRlbmRlZCA9IG51bGw7XG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY29uZmlndXJhdGlvbiBvZiB0aGUgcXVldWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAtIGRlbGF5OiBudW1iZXIgICAgV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljYWxseSBhZnRlciBhbiBpbmFjdGl2aXR5IG9mIHRoaXMgZGVsYXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG1pbGxpc2Vjb25kcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgbnVsbC5cbiAqICAgICAgICAgICAgLSBtYXg6IG51bWJlciAgICAgIFdoZW4gdGhlIHF1ZXVlIGV4Y2VlZHMgdGhlIGdpdmVuIG1heGltdW0gbnVtYmVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBlbnRyaWVzLCB0aGUgcXVldWUgaXMgZmx1c2hlZCBhdXRvbWF0aWNhbGx5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBtYXggaXMgSW5maW5pdHkuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5RdWV1ZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLmRlbGF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICB9XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLm1heCA9IG9wdGlvbnMubWF4O1xuICB9XG5cbiAgdGhpcy5fZmx1c2hJZk5lZWRlZCgpO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgYW4gb2JqZWN0IHdpdGggcXVldWluZyBmdW5jdGlvbmFsaXR5LlxuICogVGhlIG9iamVjdCB3aWxsIGJlIGV4dGVuZGVkIHdpdGggYSBmdW5jdGlvbiBmbHVzaCwgYW5kIHRoZSBtZXRob2RzIHByb3ZpZGVkXG4gKiBpbiBvcHRpb25zLnJlcGxhY2Ugd2lsbCBiZSByZXBsYWNlZCB3aXRoIHF1ZXVlZCBvbmVzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgIC0gcmVwbGFjZTogQXJyYXkuPHN0cmluZz5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgbGlzdCB3aXRoIG1ldGhvZCBuYW1lcyBvZiB0aGUgbWV0aG9kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdGhlIG9iamVjdCB0byBiZSByZXBsYWNlZCB3aXRoIHF1ZXVlZCBvbmVzLlxuICogICAgICAgICAgICAtIGRlbGF5OiBudW1iZXIgICAgV2hlbiBwcm92aWRlZCwgdGhlIHF1ZXVlIHdpbGwgYmUgZmx1c2hlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljYWxseSBhZnRlciBhbiBpbmFjdGl2aXR5IG9mIHRoaXMgZGVsYXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG1pbGxpc2Vjb25kcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdmFsdWUgaXMgbnVsbC5cbiAqICAgICAgICAgICAgLSBtYXg6IG51bWJlciAgICAgIFdoZW4gdGhlIHF1ZXVlIGV4Y2VlZHMgdGhlIGdpdmVuIG1heGltdW0gbnVtYmVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBlbnRyaWVzLCB0aGUgcXVldWUgaXMgZmx1c2hlZCBhdXRvbWF0aWNhbGx5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBvZiBtYXggaXMgSW5maW5pdHkuXG4gKiBAcmV0dXJuIHtRdWV1ZX0gUmV0dXJucyB0aGUgY3JlYXRlZCBxdWV1ZVxuICovXG5RdWV1ZS5leHRlbmQgPSBmdW5jdGlvbiAob2JqZWN0LCBvcHRpb25zKSB7XG4gIHZhciBxdWV1ZSA9IG5ldyBRdWV1ZShvcHRpb25zKTtcblxuICBpZiAob2JqZWN0LmZsdXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBvYmplY3QgYWxyZWFkeSBoYXMgYSBwcm9wZXJ0eSBmbHVzaCcpO1xuICB9XG4gIG9iamVjdC5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBxdWV1ZS5mbHVzaCgpO1xuICB9O1xuXG4gIHZhciBtZXRob2RzID0gW3tcbiAgICBuYW1lOiAnZmx1c2gnLFxuICAgIG9yaWdpbmFsOiB1bmRlZmluZWRcbiAgfV07XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnJlcGxhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5yZXBsYWNlW2ldO1xuICAgICAgbWV0aG9kcy5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgb3JpZ2luYWw6IG9iamVjdFtuYW1lXVxuICAgICAgfSk7XG4gICAgICBxdWV1ZS5yZXBsYWNlKG9iamVjdCwgbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcXVldWUuX2V4dGVuZGVkID0ge1xuICAgIG9iamVjdDogb2JqZWN0LFxuICAgIG1ldGhvZHM6IG1ldGhvZHNcbiAgfTtcblxuICByZXR1cm4gcXVldWU7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIHF1ZXVlLiBUaGUgcXVldWUgd2lsbCBmaXJzdCBmbHVzaCBhbGwgcXVldWVkIGFjdGlvbnMsIGFuZCBpblxuICogY2FzZSBpdCBoYXMgZXh0ZW5kZWQgYW4gb2JqZWN0LCB3aWxsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAqL1xuUXVldWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZmx1c2goKTtcblxuICBpZiAodGhpcy5fZXh0ZW5kZWQpIHtcbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5fZXh0ZW5kZWQub2JqZWN0O1xuICAgIHZhciBtZXRob2RzID0gdGhpcy5fZXh0ZW5kZWQubWV0aG9kcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzW2ldO1xuICAgICAgaWYgKG1ldGhvZC5vcmlnaW5hbCkge1xuICAgICAgICBvYmplY3RbbWV0aG9kLm5hbWVdID0gbWV0aG9kLm9yaWdpbmFsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBvYmplY3RbbWV0aG9kLm5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9leHRlbmRlZCA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwbGFjZSBhIG1ldGhvZCBvbiBhbiBvYmplY3Qgd2l0aCBhIHF1ZXVlZCB2ZXJzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICAgT2JqZWN0IGhhdmluZyB0aGUgbWV0aG9kXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kICAgVGhlIG1ldGhvZCBuYW1lXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24ob2JqZWN0LCBtZXRob2QpIHtcbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIG9yaWdpbmFsID0gb2JqZWN0W21ldGhvZF07XG4gIGlmICghb3JpZ2luYWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCAnICsgbWV0aG9kICsgJyB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIG9iamVjdFttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGNyZWF0ZSBhbiBBcnJheSB3aXRoIHRoZSBhcmd1bWVudHNcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIC8vIGFkZCB0aGlzIGNhbGwgdG8gdGhlIHF1ZXVlXG4gICAgbWUucXVldWUoe1xuICAgICAgYXJnczogYXJncyxcbiAgICAgIGZuOiBvcmlnaW5hbCxcbiAgICAgIGNvbnRleHQ6IHRoaXNcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogUXVldWUgYSBjYWxsXG4gKiBAcGFyYW0ge2Z1bmN0aW9uIHwge2ZuOiBmdW5jdGlvbiwgYXJnczogQXJyYXl9IHwge2ZuOiBmdW5jdGlvbiwgYXJnczogQXJyYXksIGNvbnRleHQ6IE9iamVjdH19IGVudHJ5XG4gKi9cblF1ZXVlLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gIGlmICh0eXBlb2YgZW50cnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKHtmbjogZW50cnl9KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIHRoaXMuX2ZsdXNoSWZOZWVkZWQoKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgcXVldWUgbmVlZHMgdG8gYmUgZmx1c2hlZFxuICogQHByaXZhdGVcbiAqL1xuUXVldWUucHJvdG90eXBlLl9mbHVzaElmTmVlZGVkID0gZnVuY3Rpb24gKCkge1xuICAvLyBmbHVzaCB3aGVuIHRoZSBtYXhpbXVtIGlzIGV4Y2VlZGVkLlxuICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gdGhpcy5tYXgpIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cblxuICAvLyBmbHVzaCBhZnRlciBhIHBlcmlvZCBvZiBpbmFjdGl2aXR5IHdoZW4gYSBkZWxheSBpcyBjb25maWd1cmVkXG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCAmJiB0eXBlb2YgdGhpcy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLmZsdXNoKCk7XG4gICAgfSwgdGhpcy5kZWxheSk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggYWxsIHF1ZXVlZCBjYWxsc1xuICovXG5RdWV1ZS5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICBlbnRyeS5mbi5hcHBseShlbnRyeS5jb250ZXh0IHx8IGVudHJ5LmZuLCBlbnRyeS5hcmdzIHx8IFtdKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcbiJdfQ==
},{}],18:[function(require,module,exports){
'use strict';

var Hammer = require('./module/hammer');

/**
 * Register a touch event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.onTouch = function (hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFirst && !isTouching) {
      callback(event);

      isTouching = true;
      setTimeout(function () {
        isTouching = false;
      }, 0);
    }
  };

  hammer.on('hammer.input', callback.inputHandler);
};

// isTouching is true while a touch action is being emitted
// this is a hack to prevent `touch` from being fired twice
var isTouching = false;

/**
 * Register a release event, taking place after a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.onRelease = function (hammer, callback) {
  callback.inputHandler = function (event) {
    if (event.isFinal && !isReleasing) {
      callback(event);

      isReleasing = true;
      setTimeout(function () {
        isReleasing = false;
      }, 0);
    }
  };

  return hammer.on('hammer.input', callback.inputHandler);
};

// isReleasing is true while a release action is being emitted
// this is a hack to prevent `release` from being fired twice
var isReleasing = false;

/**
 * Unregister a touch event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.offTouch = function (hammer, callback) {
  hammer.off('hammer.input', callback.inputHandler);
};

/**
 * Unregister a release event, taking place before a gesture
 * @param {Hammer} hammer       A hammer instance
 * @param {function} callback   Callback, called as callback(event)
 */
exports.offRelease = exports.offTouch;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9oYW1tZXJVdGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7Ozs7Ozs7QUFPeEMsT0FBTyxDQUFDLE9BQU8sR0FBRyxVQUFVLE1BQU0sRUFBRSxRQUFRLEVBQUU7QUFDNUMsVUFBUSxDQUFDLFlBQVksR0FBRyxVQUFVLEtBQUssRUFBRTtBQUN2QyxRQUFJLEtBQUssQ0FBQyxPQUFPLElBQUksQ0FBQyxVQUFVLEVBQUU7QUFDaEMsY0FBUSxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUVoQixnQkFBVSxHQUFHLElBQUksQ0FBQztBQUNsQixnQkFBVSxDQUFDLFlBQVk7QUFDckIsa0JBQVUsR0FBRyxLQUFLLENBQUM7T0FDcEIsRUFBRSxDQUFDLENBQUMsQ0FBQztLQUNQO0dBQ0YsQ0FBQzs7QUFFRixRQUFNLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRSxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUM7Q0FDbEQsQ0FBQzs7OztBQUlGLElBQUksVUFBVSxHQUFHLEtBQUssQ0FBQzs7Ozs7OztBQU92QixPQUFPLENBQUMsU0FBUyxHQUFHLFVBQVUsTUFBTSxFQUFFLFFBQVEsRUFBRTtBQUM5QyxVQUFRLENBQUMsWUFBWSxHQUFHLFVBQVUsS0FBSyxFQUFFO0FBQ3ZDLFFBQUksS0FBSyxDQUFDLE9BQU8sSUFBSSxDQUFDLFdBQVcsRUFBRTtBQUNqQyxjQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRWhCLGlCQUFXLEdBQUcsSUFBSSxDQUFDO0FBQ25CLGdCQUFVLENBQUMsWUFBWTtBQUNyQixtQkFBVyxHQUFHLEtBQUssQ0FBQztPQUNyQixFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ1A7R0FDRixDQUFDOztBQUVGLFNBQU8sTUFBTSxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO0NBQ3pELENBQUM7Ozs7QUFLRixJQUFJLFdBQVcsR0FBRyxLQUFLLENBQUM7Ozs7Ozs7QUFReEIsT0FBTyxDQUFDLFFBQVEsR0FBRyxVQUFVLE1BQU0sRUFBRSxRQUFRLEVBQUU7QUFDN0MsUUFBTSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO0NBQ25ELENBQUM7Ozs7Ozs7QUFPRixPQUFPLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL2hhbW1lclV0aWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSGFtbWVyID0gcmVxdWlyZSgnLi9tb2R1bGUvaGFtbWVyJyk7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSB0b3VjaCBldmVudCwgdGFraW5nIHBsYWNlIGJlZm9yZSBhIGdlc3R1cmVcbiAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAqL1xuZXhwb3J0cy5vblRvdWNoID0gZnVuY3Rpb24gKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2suaW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlzRmlyc3QgJiYgIWlzVG91Y2hpbmcpIHtcbiAgICAgIGNhbGxiYWNrKGV2ZW50KTtcblxuICAgICAgaXNUb3VjaGluZyA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNUb3VjaGluZyA9IGZhbHNlO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbW1lci5vbignaGFtbWVyLmlucHV0JywgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbn07XG5cbi8vIGlzVG91Y2hpbmcgaXMgdHJ1ZSB3aGlsZSBhIHRvdWNoIGFjdGlvbiBpcyBiZWluZyBlbWl0dGVkXG4vLyB0aGlzIGlzIGEgaGFjayB0byBwcmV2ZW50IGB0b3VjaGAgZnJvbSBiZWluZyBmaXJlZCB0d2ljZVxudmFyIGlzVG91Y2hpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHJlbGVhc2UgZXZlbnQsIHRha2luZyBwbGFjZSBhZnRlciBhIGdlc3R1cmVcbiAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAqL1xuZXhwb3J0cy5vblJlbGVhc2UgPSBmdW5jdGlvbiAoaGFtbWVyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjay5pbnB1dEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNGaW5hbCAmJiAhaXNSZWxlYXNpbmcpIHtcbiAgICAgIGNhbGxiYWNrKGV2ZW50KTtcblxuICAgICAgaXNSZWxlYXNpbmcgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzUmVsZWFzaW5nID0gZmFsc2U7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGhhbW1lci5vbignaGFtbWVyLmlucHV0JywgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbn07XG5cblxuLy8gaXNSZWxlYXNpbmcgaXMgdHJ1ZSB3aGlsZSBhIHJlbGVhc2UgYWN0aW9uIGlzIGJlaW5nIGVtaXR0ZWRcbi8vIHRoaXMgaXMgYSBoYWNrIHRvIHByZXZlbnQgYHJlbGVhc2VgIGZyb20gYmVpbmcgZmlyZWQgdHdpY2VcbnZhciBpc1JlbGVhc2luZyA9IGZhbHNlO1xuXG5cbi8qKlxuICogVW5yZWdpc3RlciBhIHRvdWNoIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICogQHBhcmFtIHtIYW1tZXJ9IGhhbW1lciAgICAgICBBIGhhbW1lciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBDYWxsYmFjaywgY2FsbGVkIGFzIGNhbGxiYWNrKGV2ZW50KVxuICovXG5leHBvcnRzLm9mZlRvdWNoID0gZnVuY3Rpb24gKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgaGFtbWVyLm9mZignaGFtbWVyLmlucHV0JywgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbn07XG5cbi8qKlxuICogVW5yZWdpc3RlciBhIHJlbGVhc2UgZXZlbnQsIHRha2luZyBwbGFjZSBiZWZvcmUgYSBnZXN0dXJlXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKi9cbmV4cG9ydHMub2ZmUmVsZWFzZSA9IGV4cG9ydHMub2ZmVG91Y2g7XG4iXX0=
},{"./module/hammer":19}],19:[function(require,module,exports){
// Only load hammer.js when in a browser environment
// (loading hammer.js in a node.js environment gives errors)
'use strict';

if (typeof window !== 'undefined') {
  var propagating = require('propagating-hammerjs');
  var Hammer = window['Hammer'] || require('hammerjs');
  module.exports = propagating(Hammer, {
    preventDefault: 'mouse'
  });
} else {
  module.exports = function () {
    throw Error('hammer.js is only available in a browser, not in node.js.');
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9tb2R1bGUvaGFtbWVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFFQSxJQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVcsRUFBRTtBQUNqQyxNQUFJLFdBQVcsR0FBRyxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUNsRCxNQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3JELFFBQU0sQ0FBQyxPQUFPLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRTtBQUNuQyxrQkFBYyxFQUFFLE9BQU87R0FDeEIsQ0FBQyxDQUFDO0NBQ0osTUFDSTtBQUNILFFBQU0sQ0FBQyxPQUFPLEdBQUcsWUFBWTtBQUMzQixVQUFNLEtBQUssQ0FBQywyREFBMkQsQ0FBQyxDQUFDO0dBQzFFLENBQUE7Q0FDRiIsImZpbGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvbW9kdWxlL2hhbW1lci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIE9ubHkgbG9hZCBoYW1tZXIuanMgd2hlbiBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbi8vIChsb2FkaW5nIGhhbW1lci5qcyBpbiBhIG5vZGUuanMgZW52aXJvbm1lbnQgZ2l2ZXMgZXJyb3JzKVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBwcm9wYWdhdGluZyA9IHJlcXVpcmUoJ3Byb3BhZ2F0aW5nLWhhbW1lcmpzJyk7XG4gIHZhciBIYW1tZXIgPSB3aW5kb3dbJ0hhbW1lciddIHx8IHJlcXVpcmUoJ2hhbW1lcmpzJyk7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvcGFnYXRpbmcoSGFtbWVyLCB7XG4gICAgcHJldmVudERlZmF1bHQ6ICdtb3VzZSdcbiAgfSk7XG59XG5lbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2hhbW1lci5qcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBhIGJyb3dzZXIsIG5vdCBpbiBub2RlLmpzLicpO1xuICB9XG59XG4iXX0=
},{"hammerjs":11,"propagating-hammerjs":14}],20:[function(require,module,exports){
// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.
'use strict';

module.exports = typeof window !== 'undefined' && window['moment'] || require('moment');
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9tb2R1bGUvbW9tZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFFQSxNQUFNLENBQUMsT0FBTyxHQUFHLEFBQUMsT0FBTyxNQUFNLEtBQUssV0FBVyxJQUFLLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL21vZHVsZS9tb21lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmaXJzdCBjaGVjayBpZiBtb21lbnQuanMgaXMgYWxyZWFkeSBsb2FkZWQgaW4gdGhlIGJyb3dzZXIgd2luZG93LCBpZiBzbyxcbi8vIHVzZSB0aGlzIGluc3RhbmNlLiBFbHNlLCBsb2FkIHZpYSBjb21tb25qcy5cbm1vZHVsZS5leHBvcnRzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiB3aW5kb3dbJ21vbWVudCddIHx8IHJlcXVpcmUoJ21vbWVudCcpO1xuIl19
},{"moment":13}],21:[function(require,module,exports){
(function (global){
'use strict';

var _rng;

var globalVar = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : null;

if (globalVar && globalVar.crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  _rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!_rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var _rnds = new Array(16);
  _rng = function () {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required

//var _rng = require('./rng');

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = buf && offset || 0,
      ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {
    if (ii < 16) {
      // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0,
      bth = _byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0,
    _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9tb2R1bGUvdXVpZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksSUFBSSxDQUFDOztBQUVULElBQUksU0FBUyxHQUFHLE9BQU8sTUFBTSxLQUFLLFdBQVcsR0FDdkMsTUFBTSxHQUNOLE9BQU8sTUFBTSxLQUFLLFdBQVcsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDOztBQUVwRCxJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUU7OztBQUczRCxNQUFJLE1BQU0sR0FBRyxJQUFJLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNoQyxNQUFJLEdBQUcsU0FBUyxTQUFTLEdBQUc7QUFDMUIsVUFBTSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMvQixXQUFPLE1BQU0sQ0FBQztHQUNmLENBQUM7Q0FDSDs7QUFFRCxJQUFJLENBQUMsSUFBSSxFQUFFOzs7OztBQUtULE1BQUksS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzFCLE1BQUksR0FBRyxZQUFZO0FBQ2pCLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzlCLFVBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFBLEtBQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsV0FBVyxDQUFDO0FBQ3RELFdBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFBLElBQUssQ0FBQyxDQUFBLEFBQUMsR0FBRyxJQUFJLENBQUM7S0FDM0M7O0FBRUQsV0FBTyxLQUFLLENBQUM7R0FDZCxDQUFDO0NBQ0g7Ozs7Ozs7Ozs7Ozs7O0FBY0QsSUFBSSxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLElBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUNwQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzVCLFlBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUEsQ0FBRSxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ25ELFlBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDL0I7OztBQUdELFNBQVMsS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFO0FBQzdCLE1BQUksQ0FBQyxHQUFHLEFBQUMsR0FBRyxJQUFJLE1BQU0sSUFBSyxDQUFDO01BQUUsRUFBRSxHQUFHLENBQUMsQ0FBQzs7QUFFckMsS0FBRyxHQUFHLEdBQUcsSUFBSSxFQUFFLENBQUM7QUFDaEIsR0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUUsVUFBVSxHQUFHLEVBQUU7QUFDckQsUUFBSSxFQUFFLEdBQUcsRUFBRSxFQUFFOztBQUNYLFNBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDakM7R0FDRixDQUFDLENBQUM7OztBQUdILFNBQU8sRUFBRSxHQUFHLEVBQUUsRUFBRTtBQUNkLE9BQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7R0FDbkI7O0FBRUQsU0FBTyxHQUFHLENBQUM7Q0FDWjs7O0FBR0QsU0FBUyxPQUFPLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRTtBQUM1QixNQUFJLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQztNQUFFLEdBQUcsR0FBRyxVQUFVLENBQUM7QUFDdEMsU0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FDaEMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUNuQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQ25DLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FDbkMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUNuQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FDN0IsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQzdCLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQ25DOzs7Ozs7OztBQVFELElBQUksVUFBVSxHQUFHLElBQUksRUFBRSxDQUFDOzs7QUFHeEIsSUFBSSxPQUFPLEdBQUcsQ0FDWixVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUNwQixVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUMxRSxDQUFDOzs7QUFHRixJQUFJLFNBQVMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFBLEdBQUksTUFBTSxDQUFDOzs7QUFHOUQsSUFBSSxVQUFVLEdBQUcsQ0FBQztJQUFFLFVBQVUsR0FBRyxDQUFDLENBQUM7OztBQUduQyxTQUFTLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRTtBQUNoQyxNQUFJLENBQUMsR0FBRyxHQUFHLElBQUksTUFBTSxJQUFJLENBQUMsQ0FBQztBQUMzQixNQUFJLENBQUMsR0FBRyxHQUFHLElBQUksRUFBRSxDQUFDOztBQUVsQixTQUFPLEdBQUcsT0FBTyxJQUFJLEVBQUUsQ0FBQzs7QUFFeEIsTUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsS0FBSyxTQUFTLEdBQUcsT0FBTyxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7Ozs7OztBQU03RSxNQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxLQUFLLFNBQVMsR0FBRyxPQUFPLENBQUMsS0FBSyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7Ozs7QUFJL0UsTUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssS0FBSyxTQUFTLEdBQUcsT0FBTyxDQUFDLEtBQUssR0FBRyxVQUFVLEdBQUcsQ0FBQyxDQUFDOzs7QUFHekUsTUFBSSxFQUFFLEdBQUcsQUFBQyxLQUFLLEdBQUcsVUFBVSxHQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQSxHQUFJLEtBQUssQ0FBQzs7O0FBRzdELE1BQUksRUFBRSxHQUFHLENBQUMsSUFBSSxPQUFPLENBQUMsUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUM1QyxZQUFRLEdBQUcsUUFBUSxHQUFHLENBQUMsR0FBRyxNQUFNLENB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LElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUksSUFBSSxDQUFDO0FBQ2xDLE1BQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxBQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUksSUFBSSxDQUFDOzs7QUFHbEMsTUFBSSxHQUFHLEVBQUU7QUFDUCxTQUFLLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQzlCLFNBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ3hCO0dBQ0Y7O0FBRUQsU0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQzdCOzs7QUFHRCxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDZCxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUNiLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO0FBQ2IsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDbkIsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7O0FBRXZCLE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDIiwiZmlsZSI6Ii91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9tb2R1bGUvdXVpZC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfcm5nO1xuXG52YXIgZ2xvYmFsVmFyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBudWxsO1xuXG5pZiAoZ2xvYmFsVmFyICYmIGdsb2JhbFZhci5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvLWJhc2VkIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgdmFyIF9ybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgX3JuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzOCk7XG4gICAgcmV0dXJuIF9ybmRzODtcbiAgfTtcbn1cblxuaWYgKCFfcm5nKSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyIF9ybmRzID0gbmV3IEFycmF5KDE2KTtcbiAgX3JuZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgX3JuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9ybmRzO1xuICB9O1xufVxuXG4vLyAgICAgdXVpZC5qc1xuLy9cbi8vICAgICBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiBSb2JlcnQgS2llZmZlclxuLy8gICAgIE1JVCBMaWNlbnNlIC0gaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXG4vLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgV2UgZmVhdHVyZVxuLy8gZGV0ZWN0IHRvIGRldGVybWluZSB0aGUgYmVzdCBSTkcgc291cmNlLCBub3JtYWxpemluZyB0byBhIGZ1bmN0aW9uIHRoYXRcbi8vIHJldHVybnMgMTI4LWJpdHMgb2YgcmFuZG9tbmVzcywgc2luY2UgdGhhdCdzIHdoYXQncyB1c3VhbGx5IHJlcXVpcmVkXG5cbi8vdmFyIF9ybmcgPSByZXF1aXJlKCcuL3JuZycpO1xuXG4vLyBNYXBzIGZvciBudW1iZXIgPC0+IGhleCBzdHJpbmcgY29udmVyc2lvblxudmFyIF9ieXRlVG9IZXggPSBbXTtcbnZhciBfaGV4VG9CeXRlID0ge307XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIF9ieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xuICBfaGV4VG9CeXRlW19ieXRlVG9IZXhbaV1dID0gaTtcbn1cblxuLy8gKipgcGFyc2UoKWAgLSBQYXJzZSBhIFVVSUQgaW50byBpdCdzIGNvbXBvbmVudCBieXRlcyoqXG5mdW5jdGlvbiBwYXJzZShzLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IChidWYgJiYgb2Zmc2V0KSB8fCAwLCBpaSA9IDA7XG5cbiAgYnVmID0gYnVmIHx8IFtdO1xuICBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZywgZnVuY3Rpb24gKG9jdCkge1xuICAgIGlmIChpaSA8IDE2KSB7IC8vIERvbid0IG92ZXJmbG93IVxuICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG4gIHdoaWxlIChpaSA8IDE2KSB7XG4gICAgYnVmW2kgKyBpaSsrXSA9IDA7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG4vLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcbmZ1bmN0aW9uIHVucGFyc2UoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMCwgYnRoID0gX2J5dGVUb0hleDtcbiAgcmV0dXJuIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dO1xufVxuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbi8vIHJhbmRvbSAjJ3Mgd2UgbmVlZCB0byBpbml0IG5vZGUgYW5kIGNsb2Nrc2VxXG52YXIgX3NlZWRCeXRlcyA9IF9ybmcoKTtcblxuLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG52YXIgX25vZGVJZCA9IFtcbiAgX3NlZWRCeXRlc1swXSB8IDB4MDEsXG4gIF9zZWVkQnl0ZXNbMV0sIF9zZWVkQnl0ZXNbMl0sIF9zZWVkQnl0ZXNbM10sIF9zZWVkQnl0ZXNbNF0sIF9zZWVkQnl0ZXNbNV1cbl07XG5cbi8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG52YXIgX2Nsb2Nrc2VxID0gKF9zZWVkQnl0ZXNbNl0gPDwgOCB8IF9zZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbnZhciBfbGFzdE1TZWNzID0gMCwgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyBuKyspIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogdW5wYXJzZShiKTtcbn1cblxuLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7IGlpKyspIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCB1bnBhcnNlKHJuZHMpO1xufVxuXG4vLyBFeHBvcnQgcHVibGljIEFQSVxudmFyIHV1aWQgPSB2NDtcbnV1aWQudjEgPSB2MTtcbnV1aWQudjQgPSB2NDtcbnV1aWQucGFyc2UgPSBwYXJzZTtcbnV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiJdfQ==
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],22:[function(require,module,exports){
'use strict';

var keycharm = require('keycharm');
var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var util = require('../util');

/**
 * Turn an element into an clickToUse element.
 * When not active, the element has a transparent overlay. When the overlay is
 * clicked, the mode is changed to active.
 * When active, the element is displayed with a blue border around it, and
 * the interactive contents of the element can be used. When clicked outside
 * the element, the elements mode is changed to inactive.
 * @param {Element} container
 * @constructor
 */
function Activator(container) {
  this.active = false;

  this.dom = {
    container: container
  };

  this.dom.overlay = document.createElement('div');
  this.dom.overlay.className = 'vis-overlay';

  this.dom.container.appendChild(this.dom.overlay);

  this.hammer = Hammer(this.dom.overlay);
  this.hammer.on('tap', this._onTapOverlay.bind(this));

  // block all touch events (except tap)
  var me = this;
  var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'];
  events.forEach(function (event) {
    me.hammer.on(event, function (event) {
      event.stopPropagation();
    });
  });

  // attach a click event to the window, in order to deactivate when clicking outside the timeline
  if (document && document.body) {
    this.onClick = function (event) {
      if (!_hasParent(event.target, container)) {
        me.deactivate();
      }
    };
    document.body.addEventListener('click', this.onClick);
  }

  if (this.keycharm !== undefined) {
    this.keycharm.destroy();
  }
  this.keycharm = keycharm();

  // keycharm listener only bounded when active)
  this.escListener = this.deactivate.bind(this);
}

// turn into an event emitter
Emitter(Activator.prototype);

// The currently active activator
Activator.current = null;

/**
 * Destroy the activator. Cleans up all created DOM and event listeners
 */
Activator.prototype.destroy = function () {
  this.deactivate();

  // remove dom
  this.dom.overlay.parentNode.removeChild(this.dom.overlay);

  // remove global event listener
  if (this.onClick) {
    document.body.removeEventListener('click', this.onClick);
  }

  // cleanup hammer instances
  this.hammer.destroy();
  this.hammer = null;
  // FIXME: cleaning up hammer instances doesn't work (Timeline not removed from memory)
};

/**
 * Activate the element
 * Overlay is hidden, element is decorated with a blue shadow border
 */
Activator.prototype.activate = function () {
  // we allow only one active activator at a time
  if (Activator.current) {
    Activator.current.deactivate();
  }
  Activator.current = this;

  this.active = true;
  this.dom.overlay.style.display = 'none';
  util.addClassName(this.dom.container, 'vis-active');

  this.emit('change');
  this.emit('activate');

  // ugly hack: bind ESC after emitting the events, as the Network rebinds all
  // keyboard events on a 'change' event
  this.keycharm.bind('esc', this.escListener);
};

/**
 * Deactivate the element
 * Overlay is displayed on top of the element
 */
Activator.prototype.deactivate = function () {
  this.active = false;
  this.dom.overlay.style.display = '';
  util.removeClassName(this.dom.container, 'vis-active');
  this.keycharm.unbind('esc', this.escListener);

  this.emit('change');
  this.emit('deactivate');
};

/**
 * Handle a tap event: activate the container
 * @param event
 * @private
 */
Activator.prototype._onTapOverlay = function (event) {
  // activate the container
  this.activate();
  event.stopPropagation();
};

/**
 * Test whether the element has the requested parent element somewhere in
 * its chain of parent nodes.
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @returns {boolean} Returns true when the parent is found somewhere in the
 *                    chain of parent nodes.
 * @private
 */
function _hasParent(element, parent) {
  while (element) {
    if (element === parent) {
      return true;
    }
    element = element.parentNode;
  }
  return false;
}

module.exports = Activator;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9zaGFyZWQvQWN0aXZhdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ25DLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQzNDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3pDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7O0FBWTlCLFNBQVMsU0FBUyxDQUFDLFNBQVMsRUFBRTtBQUM1QixNQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQzs7QUFFcEIsTUFBSSxDQUFDLEdBQUcsR0FBRztBQUNULGFBQVMsRUFBRSxTQUFTO0dBQ3JCLENBQUM7O0FBRUYsTUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNqRCxNQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsYUFBYSxDQUFDOztBQUUzQyxNQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFakQsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN2QyxNQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzs7O0FBR3JELE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQztBQUNkLE1BQUksTUFBTSxHQUFHLENBQ1gsS0FBSyxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQzNCLE9BQU8s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Q0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDLENBQUM7QUFDdkQsTUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQzs7QUFFOUMsTUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNwQixNQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0NBQ3pCLENBQUM7Ozs7Ozs7QUFPRixTQUFTLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxVQUFVLEtBQUssRUFBRTs7QUFFbkQsTUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ2hCLE9BQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztDQUN6QixDQUFDOzs7Ozs7Ozs7OztBQVdGLFNBQVMsVUFBVSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUU7QUFDbkMsU0FBTyxPQUFPLEVBQUU7QUFDZCxRQUFJLE9BQU8sS0FBSyxNQUFNLEVBQUU7QUFDdEIsYUFBTyxJQUFJLENBQUE7S0FDWjtBQUNELFdBQU8sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO0dBQzlCO0FBQ0QsU0FBTyxLQUFLLENBQUM7Q0FDZDs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyIsImZpbGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvc2hhcmVkL0FjdGl2YXRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBrZXljaGFybSA9IHJlcXVpcmUoJ2tleWNoYXJtJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2VtaXR0ZXItY29tcG9uZW50Jyk7XG52YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8qKlxuICogVHVybiBhbiBlbGVtZW50IGludG8gYW4gY2xpY2tUb1VzZSBlbGVtZW50LlxuICogV2hlbiBub3QgYWN0aXZlLCB0aGUgZWxlbWVudCBoYXMgYSB0cmFuc3BhcmVudCBvdmVybGF5LiBXaGVuIHRoZSBvdmVybGF5IGlzXG4gKiBjbGlja2VkLCB0aGUgbW9kZSBpcyBjaGFuZ2VkIHRvIGFjdGl2ZS5cbiAqIFdoZW4gYWN0aXZlLCB0aGUgZWxlbWVudCBpcyBkaXNwbGF5ZWQgd2l0aCBhIGJsdWUgYm9yZGVyIGFyb3VuZCBpdCwgYW5kXG4gKiB0aGUgaW50ZXJhY3RpdmUgY29udGVudHMgb2YgdGhlIGVsZW1lbnQgY2FuIGJlIHVzZWQuIFdoZW4gY2xpY2tlZCBvdXRzaWRlXG4gKiB0aGUgZWxlbWVudCwgdGhlIGVsZW1lbnRzIG1vZGUgaXMgY2hhbmdlZCB0byBpbmFjdGl2ZS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQWN0aXZhdG9yKGNvbnRhaW5lcikge1xuICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXG4gIHRoaXMuZG9tID0ge1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyXG4gIH07XG5cbiAgdGhpcy5kb20ub3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5vdmVybGF5LmNsYXNzTmFtZSA9ICd2aXMtb3ZlcmxheSc7XG5cbiAgdGhpcy5kb20uY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLm92ZXJsYXkpO1xuXG4gIHRoaXMuaGFtbWVyID0gSGFtbWVyKHRoaXMuZG9tLm92ZXJsYXkpO1xuICB0aGlzLmhhbW1lci5vbigndGFwJywgdGhpcy5fb25UYXBPdmVybGF5LmJpbmQodGhpcykpO1xuXG4gIC8vIGJsb2NrIGFsbCB0b3VjaCBldmVudHMgKGV4Y2VwdCB0YXApXG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBldmVudHMgPSBbXG4gICAgJ3RhcCcsICdkb3VibGV0YXAnLCAncHJlc3MnLFxuICAgICdwaW5jaCcsXG4gICAgJ3BhbicsICdwYW5zdGFydCcsICdwYW5tb3ZlJywgJ3BhbmVuZCdcbiAgXTtcbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbWUuaGFtbWVyLm9uKGV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBhdHRhY2ggYSBjbGljayBldmVudCB0byB0aGUgd2luZG93LCBpbiBvcmRlciB0byBkZWFjdGl2YXRlIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSB0aGUgdGltZWxpbmVcbiAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICB0aGlzLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX2hhc1BhcmVudChldmVudC50YXJnZXQsIGNvbnRhaW5lcikpIHtcbiAgICAgICAgbWUuZGVhY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gIH1cblxuICBpZiAodGhpcy5rZXljaGFybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gIH1cbiAgdGhpcy5rZXljaGFybSA9IGtleWNoYXJtKCk7XG5cbiAgLy8ga2V5Y2hhcm0gbGlzdGVuZXIgb25seSBib3VuZGVkIHdoZW4gYWN0aXZlKVxuICB0aGlzLmVzY0xpc3RlbmVyID0gdGhpcy5kZWFjdGl2YXRlLmJpbmQodGhpcyk7XG59XG5cbi8vIHR1cm4gaW50byBhbiBldmVudCBlbWl0dGVyXG5FbWl0dGVyKEFjdGl2YXRvci5wcm90b3R5cGUpO1xuXG4vLyBUaGUgY3VycmVudGx5IGFjdGl2ZSBhY3RpdmF0b3JcbkFjdGl2YXRvci5jdXJyZW50ID0gbnVsbDtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBhY3RpdmF0b3IuIENsZWFucyB1cCBhbGwgY3JlYXRlZCBET00gYW5kIGV2ZW50IGxpc3RlbmVyc1xuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGVhY3RpdmF0ZSgpO1xuXG4gIC8vIHJlbW92ZSBkb21cbiAgdGhpcy5kb20ub3ZlcmxheS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLm92ZXJsYXkpO1xuXG4gIC8vIHJlbW92ZSBnbG9iYWwgZXZlbnQgbGlzdGVuZXJcbiAgaWYgKHRoaXMub25DbGljaykge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICB9XG5cbiAgLy8gY2xlYW51cCBoYW1tZXIgaW5zdGFuY2VzXG4gIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgdGhpcy5oYW1tZXIgPSBudWxsO1xuICAvLyBGSVhNRTogY2xlYW5pbmcgdXAgaGFtbWVyIGluc3RhbmNlcyBkb2Vzbid0IHdvcmsgKFRpbWVsaW5lIG5vdCByZW1vdmVkIGZyb20gbWVtb3J5KVxufTtcblxuLyoqXG4gKiBBY3RpdmF0ZSB0aGUgZWxlbWVudFxuICogT3ZlcmxheSBpcyBoaWRkZW4sIGVsZW1lbnQgaXMgZGVjb3JhdGVkIHdpdGggYSBibHVlIHNoYWRvdyBib3JkZXJcbiAqL1xuQWN0aXZhdG9yLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gd2UgYWxsb3cgb25seSBvbmUgYWN0aXZlIGFjdGl2YXRvciBhdCBhIHRpbWVcbiAgaWYgKEFjdGl2YXRvci5jdXJyZW50KSB7XG4gICAgQWN0aXZhdG9yLmN1cnJlbnQuZGVhY3RpdmF0ZSgpO1xuICB9XG4gIEFjdGl2YXRvci5jdXJyZW50ID0gdGhpcztcblxuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uY29udGFpbmVyLCAndmlzLWFjdGl2ZScpO1xuXG4gIHRoaXMuZW1pdCgnY2hhbmdlJyk7XG4gIHRoaXMuZW1pdCgnYWN0aXZhdGUnKTtcblxuICAvLyB1Z2x5IGhhY2s6IGJpbmQgRVNDIGFmdGVyIGVtaXR0aW5nIHRoZSBldmVudHMsIGFzIHRoZSBOZXR3b3JrIHJlYmluZHMgYWxsXG4gIC8vIGtleWJvYXJkIGV2ZW50cyBvbiBhICdjaGFuZ2UnIGV2ZW50XG4gIHRoaXMua2V5Y2hhcm0uYmluZCgnZXNjJywgdGhpcy5lc2NMaXN0ZW5lcik7XG59O1xuXG4vKipcbiAqIERlYWN0aXZhdGUgdGhlIGVsZW1lbnRcbiAqIE92ZXJsYXkgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgZWxlbWVudFxuICovXG5BY3RpdmF0b3IucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIHRoaXMuZG9tLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICcnO1xuICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5jb250YWluZXIsICd2aXMtYWN0aXZlJyk7XG4gIHRoaXMua2V5Y2hhcm0udW5iaW5kKCdlc2MnLCB0aGlzLmVzY0xpc3RlbmVyKTtcblxuICB0aGlzLmVtaXQoJ2NoYW5nZScpO1xuICB0aGlzLmVtaXQoJ2RlYWN0aXZhdGUnKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGEgdGFwIGV2ZW50OiBhY3RpdmF0ZSB0aGUgY29udGFpbmVyXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkFjdGl2YXRvci5wcm90b3R5cGUuX29uVGFwT3ZlcmxheSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBhY3RpdmF0ZSB0aGUgY29udGFpbmVyXG4gIHRoaXMuYWN0aXZhdGUoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciB0aGUgZWxlbWVudCBoYXMgdGhlIHJlcXVlc3RlZCBwYXJlbnQgZWxlbWVudCBzb21ld2hlcmUgaW5cbiAqIGl0cyBjaGFpbiBvZiBwYXJlbnQgbm9kZXMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgd2hlbiB0aGUgcGFyZW50IGlzIGZvdW5kIHNvbWV3aGVyZSBpbiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICBjaGFpbiBvZiBwYXJlbnQgbm9kZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaGFzUGFyZW50KGVsZW1lbnQsIHBhcmVudCkge1xuICB3aGlsZSAoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50ID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFjdGl2YXRvcjtcbiJdfQ==
},{"../module/hammer":19,"../util":46,"emitter-component":10,"keycharm":12}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Hammer = require('../module/hammer');
var hammerUtil = require('../hammerUtil');
var util = require('../util');

var ColorPicker = (function () {
  function ColorPicker() {
    var pixelRatio = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

    _classCallCheck(this, ColorPicker);

    this.pixelRatio = pixelRatio;
    this.generated = false;
    this.centerCoordinates = { x: 289 / 2, y: 289 / 2 };
    this.r = 289 * 0.49;
    this.color = { r: 255, g: 255, b: 255, a: 1.0 };
    this.hueCircle = undefined;
    this.initialColor = { r: 255, g: 255, b: 255, a: 1.0 };
    this.previousColor = undefined;
    this.applied = false;

    // bound by
    this.updateCallback = function () {};

    // create all DOM elements
    this._create();
  }

  /**
   * this inserts the colorPicker into a div from the DOM
   * @param container
   */

  _createClass(ColorPicker, [{
    key: 'insertTo',
    value: function insertTo(container) {
      if (this.hammer !== undefined) {
        this.hammer.destroy();
        this.hammer = undefined;
      }
      this.container = container;
      this.container.appendChild(this.frame);
      this._bindHammer();

      this._setSize();
    }

    /**
     * the callback is executed on apply and save. Bind it to the application
     * @param callback
     */
  }, {
    key: 'setCallback',
    value: function setCallback(callback) {
      if (typeof callback === 'function') {
        this.updateCallback = callback;
      } else {
        throw new Error("Function attempted to set as colorPicker callback is not a function.");
      }
    }
  }, {
    key: '_isColorString',
    value: function _isColorString(color) {
      var htmlColors = { black: '#000000', navy: '#000080', darkblue: '#00008B', mediumblue: '#0000CD', blue: '#0000FF', darkgreen: '#006400', green: '#008000', teal: '#008080', darkcyan: '#008B8B', deepskyblue: '#00BFFF', darkturquoise: '#00CED1', mediumspringgreen: '#00FA9A', lime: '#00FF00', springgreen: '#00FF7F', aqua: '#00FFFF', cyan: '#00FFFF', midnightblue: '#191970', dodgerblue: '#1E90FF', lightseagreen: '#20B2AA', forestgreen: '#228B22', seagreen: '#2E8B57', darkslategray: '#2F4F4F', limegreen: '#32CD32', mediumseagreen: '#3CB371', turquoise: '#40E0D0', royalblue: '#4169E1', steelblue: '#4682B4', darkslateblue: '#483D8B', mediumturquoise: '#48D1CC', indigo: '#4B0082', darkolivegreen: '#556B2F', cadetblue: '#5F9EA0', cornflowerblue: '#6495ED', mediumaquamarine: '#66CDAA', dimgray: '#696969', slateblue: '#6A5ACD', olivedrab: '#6B8E23', slategray: '#708090', lightslategray: '#778899', mediumslateblue: '#7B68EE', lawngreen: '#7CFC00', chartreuse: '#7FFF00', aquamarine: '#7FFFD4', maroon: '#800000', purple: '#800080', olive: '#808000', gray: '#808080', skyblue: '#87CEEB', lightskyblue: '#87CEFA', blueviolet: '#8A2BE2', darkred: '#8B0000', darkmagenta: '#8B008B', saddlebrown: '#8B4513', darkseagreen: '#8FBC8F', lightgreen: '#90EE90', mediumpurple: '#9370D8', darkviolet: '#9400D3', palegreen: '#98FB98', darkorchid: '#9932CC', yellowgreen: '#9ACD32', sienna: '#A0522D', brown: '#A52A2A', darkgray: '#A9A9A9', lightblue: '#ADD8E6', greenyellow: '#ADFF2F', paleturquoise: '#AFEEEE', lightsteelblue: '#B0C4DE', powderblue: '#B0E0E6', firebrick: '#B22222', darkgoldenrod: '#B8860B', mediumorchid: '#BA55D3', rosybrown: '#BC8F8F', darkkhaki: '#BDB76B', silver: '#C0C0C0', mediumvioletred: '#C71585', indianred: '#CD5C5C', peru: '#CD853F', chocolate: '#D2691E', tan: '#D2B48C', lightgrey: '#D3D3D3', palevioletred: '#D87093', thistle: '#D8BFD8', orchid: '#DA70D6', goldenrod: '#DAA520', crimson: '#DC143C', gainsboro: '#DCDCDC', plum: '#DDA0DD', burlywood: '#DEB887', lightcyan: '#E0FFFF', lavender: '#E6E6FA', darksalmon: '#E9967A', violet: '#EE82EE', palegoldenrod: '#EEE8AA', lightcoral: '#F08080', khaki: '#F0E68C', aliceblue: '#F0F8FF', honeydew: '#F0FFF0', azure: '#F0FFFF', sandybrown: '#F4A460', wheat: '#F5DEB3', beige: '#F5F5DC', whitesmoke: '#F5F5F5', mintcream: '#F5FFFA', ghostwhite: '#F8F8FF', salmon: '#FA8072', antiquewhite: '#FAEBD7', linen: '#FAF0E6', lightgoldenrodyellow: '#FAFAD2', oldlace: '#FDF5E6', red: '#FF0000', fuchsia: '#FF00FF', magenta: '#FF00FF', deeppink: '#FF1493', orangered: '#FF4500', tomato: '#FF6347', hotpink: '#FF69B4', coral: '#FF7F50', darkorange: '#FF8C00', lightsalmon: '#FFA07A', orange: '#FFA500', lightpink: '#FFB6C1', pink: '#FFC0CB', gold: '#FFD700', peachpuff: '#FFDAB9', navajowhite: '#FFDEAD', moccasin: '#FFE4B5', bisque: '#FFE4C4', mistyrose: '#FFE4E1', blanchedalmond: '#FFEBCD', papayawhip: '#FFEFD5', lavenderblush: '#FFF0F5', seashell: '#FFF5EE', cornsilk: '#FFF8DC', lemonchiffon: '#FFFACD', floralwhite: '#FFFAF0', snow: '#FFFAFA', yellow: '#FFFF00', lightyellow: '#FFFFE0', ivory: '#FFFFF0', white: '#FFFFFF' };
      if (typeof color === 'string') {
        return htmlColors[color];
      }
    }

    /**
     * Set the color of the colorPicker
     * Supported formats:
     * 'red'                   --> HTML color string
     * '#ffffff'               --> hex string
     * 'rbg(255,255,255)'      --> rgb string
     * 'rgba(255,255,255,1.0)' --> rgba string
     * {r:255,g:255,b:255}     --> rgb object
     * {r:255,g:255,b:255,a:1.0} --> rgba object
     * @param color
     * @param setInitial
     */
  }, {
    key: 'setColor',
    value: function setColor(color) {
      var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      if (color === 'none') {
        return;
      }

      var rgba = undefined;

      // if a html color shorthand is used, convert to hex
      var htmlColor = this._isColorString(color);
      if (htmlColor !== undefined) {
        color = htmlColor;
      }

      // check format
      if (util.isString(color) === true) {
        if (util.isValidRGB(color) === true) {
          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(',');
          rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: 1.0 };
        } else if (util.isValidRGBA(color) === true) {
          var rgbaArray = color.substr(5).substr(0, color.length - 6).split(',');
          rgba = { r: rgbaArray[0], g: rgbaArray[1], b: rgbaArray[2], a: rgbaArray[3] };
        } else if (util.isValidHex(color) === true) {
          var rgbObj = util.hexToRGB(color);
          rgba = { r: rgbObj.r, g: rgbObj.g, b: rgbObj.b, a: 1.0 };
        }
      } else {
        if (color instanceof Object) {
          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {
            var alpha = color.a !== undefined ? color.a : '1.0';
            rgba = { r: color.r, g: color.g, b: color.b, a: alpha };
          }
        }
      }

      // set color
      if (rgba === undefined) {
        throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: " + JSON.stringify(color));
      } else {
        this._setColor(rgba, setInitial);
      }
    }

    /**
     * this shows the color picker at a location. The hue circle is constructed once and stored.
     * @param x
     * @param y
     */
  }, {
    key: 'show',
    value: function show(x, y) {
      this.applied = false;
      this.frame.style.display = 'block';
      this.frame.style.top = y + 'px';
      this.frame.style.left = x + 'px';
      this._generateHueCircle();
    }

    // ------------------------------------------ PRIVATE ----------------------------- //

    /**
     * Hide the picker. Is called by the cancel button.
     * Optional boolean to store the previous color for easy access later on.
     * @param storePrevious
     * @private
     */
  }, {
    key: '_hide',
    value: function _hide() {
      var storePrevious = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      // store the previous color for next time;
      if (storePrevious === true) {
        this.previousColor = util.extend({}, this.color);
      }

      if (this.applied === true) {
        this.updateCallback(this.initialColor);
      }

      this.frame.style.display = 'none';
    }

    /**
     * bound to the save button. Saves and hides.
     * @private
     */
  }, {
    key: '_save',
    value: function _save() {
      this.updateCallback(this.color);
      this.applied = false;
      this._hide();
    }

    /**
     * Bound to apply button. Saves but does not close. Is undone by the cancel button.
     * @private
     */
  }, {
    key: '_apply',
    value: function _apply() {
      this.applied = true;
      this.updateCallback(this.color);
      this._updatePicker(this.color);
    }

    /**
     * load the color from the previous session.
     * @private
     */
  }, {
    key: '_loadLast',
    value: function _loadLast() {
      if (this.previousColor !== undefined) {
        this.setColor(this.previousColor, false);
      } else {
        alert("There is no last color to load...");
      }
    }

    /**
     * set the color, place the picker
     * @param rgba
     * @param setInitial
     * @private
     */
  }, {
    key: '_setColor',
    value: function _setColor(rgba) {
      var setInitial = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      // store the initial color
      if (setInitial === true) {
        this.initialColor = util.extend({}, rgba);
      }

      this.color = rgba;
      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);

      var angleConvert = 2 * Math.PI;
      var radius = this.r * hsv.s;
      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);
      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);

      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + 'px';
      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + 'px';

      this._updatePicker(rgba);
    }

    /**
     * bound to opacity control
     * @param value
     * @private
     */
  }, {
    key: '_setOpacity',
    value: function _setOpacity(value) {
      this.color.a = value / 100;
      this._updatePicker(this.color);
    }

    /**
     * bound to brightness control
     * @param value
     * @private
     */
  }, {
    key: '_setBrightness',
    value: function _setBrightness(value) {
      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.v = value / 100;
      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba;
      this._updatePicker();
    }

    /**
     * update the colorpicker. A black circle overlays the hue circle to mimic the brightness decreasing.
     * @param rgba
     * @private
     */
  }, {
    key: '_updatePicker',
    value: function _updatePicker() {
      var rgba = arguments.length <= 0 || arguments[0] === undefined ? this.color : arguments[0];

      var hsv = util.RGBToHSV(rgba.r, rgba.g, rgba.b);
      var ctx = this.colorPickerCanvas.getContext('2d');
      if (this.pixelRation === undefined) {
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
      }
      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

      // clear the canvas
      var w = this.colorPickerCanvas.clientWidth;
      var h = this.colorPickerCanvas.clientHeight;
      ctx.clearRect(0, 0, w, h);

      ctx.putImageData(this.hueCircle, 0, 0);
      ctx.fillStyle = 'rgba(0,0,0,' + (1 - hsv.v) + ')';
      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
      ctx.fill();

      this.brightnessRange.value = 100 * hsv.v;
      this.opacityRange.value = 100 * rgba.a;

      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }

    /**
     * used by create to set the size of the canvas.
     * @private
     */
  }, {
    key: '_setSize',
    value: function _setSize() {
      this.colorPickerCanvas.style.width = '100%';
      this.colorPickerCanvas.style.height = '100%';

      this.colorPickerCanvas.width = 289 * this.pixelRatio;
      this.colorPickerCanvas.height = 289 * this.pixelRatio;
    }

    /**
     * create all dom elements
     * TODO: cleanup, lots of similar dom elements
     * @private
     */
  }, {
    key: '_create',
    value: function _create() {
      this.frame = document.createElement('div');
      this.frame.className = 'vis-color-picker';

      this.colorPickerDiv = document.createElement('div');
      this.colorPickerSelector = document.createElement('div');
      this.colorPickerSelector.className = 'vis-selector';
      this.colorPickerDiv.appendChild(this.colorPickerSelector);

      this.colorPickerCanvas = document.createElement('canvas');
      this.colorPickerDiv.appendChild(this.colorPickerCanvas);

      if (!this.colorPickerCanvas.getContext) {
        var noCanvas = document.createElement('DIV');
        noCanvas.style.color = 'red';
        noCanvas.style.fontWeight = 'bold';
        noCanvas.style.padding = '10px';
        noCanvas.innerHTML = 'Error: your browser does not support HTML canvas';
        this.colorPickerCanvas.appendChild(noCanvas);
      } else {
        var ctx = this.colorPickerCanvas.getContext("2d");
        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);

        this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
      }

      this.colorPickerDiv.className = 'vis-color';

      this.opacityDiv = document.createElement('div');
      this.opacityDiv.className = 'vis-opacity';

      this.brightnessDiv = document.createElement('div');
      this.brightnessDiv.className = 'vis-brightness';

      this.arrowDiv = document.createElement('div');
      this.arrowDiv.className = 'vis-arrow';

      this.opacityRange = document.createElement('input');
      try {
        this.opacityRange.type = 'range'; // Not supported on IE9
        this.opacityRange.min = '0';
        this.opacityRange.max = '100';
      } catch (err) {}
      this.opacityRange.value = '100';
      this.opacityRange.className = 'vis-range';

      this.brightnessRange = document.createElement('input');
      try {
        this.brightnessRange.type = 'range'; // Not supported on IE9
        this.brightnessRange.min = '0';
        this.brightnessRange.max = '100';
      } catch (err) {}
      this.brightnessRange.value = '100';
      this.brightnessRange.className = 'vis-range';

      this.opacityDiv.appendChild(this.opacityRange);
      this.brightnessDiv.appendChild(this.brightnessRange);

      var me = this;
      this.opacityRange.onchange = function () {
        me._setOpacity(this.value);
      };
      this.opacityRange.oninput = function () {
        me._setOpacity(this.value);
      };
      this.brightnessRange.onchange = function () {
        me._setBrightness(this.value);
      };
      this.brightnessRange.oninput = function () {
        me._setBrightness(this.value);
      };

      this.brightnessLabel = document.createElement("div");
      this.brightnessLabel.className = "vis-label vis-brightness";
      this.brightnessLabel.innerHTML = 'brightness:';

      this.opacityLabel = document.createElement("div");
      this.opacityLabel.className = "vis-label vis-opacity";
      this.opacityLabel.innerHTML = 'opacity:';

      this.newColorDiv = document.createElement("div");
      this.newColorDiv.className = "vis-new-color";
      this.newColorDiv.innerHTML = 'new';

      this.initialColorDiv = document.createElement("div");
      this.initialColorDiv.className = "vis-initial-color";
      this.initialColorDiv.innerHTML = 'initial';

      this.cancelButton = document.createElement("div");
      this.cancelButton.className = "vis-button vis-cancel";
      this.cancelButton.innerHTML = 'cancel';
      this.cancelButton.onclick = this._hide.bind(this, false);

      this.applyButton = document.createElement("div");
      this.applyButton.className = "vis-button vis-apply";
      this.applyButton.innerHTML = 'apply';
      this.applyButton.onclick = this._apply.bind(this);

      this.saveButton = document.createElement("div");
      this.saveButton.className = "vis-button vis-save";
      this.saveButton.innerHTML = 'save';
      this.saveButton.onclick = this._save.bind(this);

      this.loadButton = document.createElement("div");
      this.loadButton.className = "vis-button vis-load";
      this.loadButton.innerHTML = 'load last';
      this.loadButton.onclick = this._loadLast.bind(this);

      this.frame.appendChild(this.colorPickerDiv);
      this.frame.appendChild(this.arrowDiv);
      this.frame.appendChild(this.brightnessLabel);
      this.frame.appendChild(this.brightnessDiv);
      this.frame.appendChild(this.opacityLabel);
      this.frame.appendChild(this.opacityDiv);
      this.frame.appendChild(this.newColorDiv);
      this.frame.appendChild(this.initialColorDiv);

      this.frame.appendChild(this.cancelButton);
      this.frame.appendChild(this.applyButton);
      this.frame.appendChild(this.saveButton);
      this.frame.appendChild(this.loadButton);
    }

    /**
     * bind hammer to the color picker
     * @private
     */
  }, {
    key: '_bindHammer',
    value: function _bindHammer() {
      var _this = this;

      this.drag = {};
      this.pinch = {};
      this.hammer = new Hammer(this.colorPickerCanvas);
      this.hammer.get('pinch').set({ enable: true });

      hammerUtil.onTouch(this.hammer, function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('tap', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panstart', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panmove', function (event) {
        _this._moveSelector(event);
      });
      this.hammer.on('panend', function (event) {
        _this._moveSelector(event);
      });
    }

    /**
     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
     * @private
     */
  }, {
    key: '_generateHueCircle',
    value: function _generateHueCircle() {
      if (this.generated === false) {
        var ctx = this.colorPickerCanvas.getContext('2d');
        if (this.pixelRation === undefined) {
          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);
        }
        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);

        // clear the canvas
        var w = this.colorPickerCanvas.clientWidth;
        var h = this.colorPickerCanvas.clientHeight;
        ctx.clearRect(0, 0, w, h);

        // draw hue circle
        var x = undefined,
            y = undefined,
            hue = undefined,
            sat = undefined;
        this.centerCoordinates = { x: w * 0.5, y: h * 0.5 };
        this.r = 0.49 * w;
        var angleConvert = 2 * Math.PI / 360;
        var hfac = 1 / 360;
        var sfac = 1 / this.r;
        var rgb = undefined;
        for (hue = 0; hue < 360; hue++) {
          for (sat = 0; sat < this.r; sat++) {
            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);
            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);
            rgb = util.HSVToRGB(hue * hfac, sat * sfac, 1);
            ctx.fillStyle = 'rgb(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ')';
            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);
          }
        }
        ctx.strokeStyle = 'rgba(0,0,0,1)';
        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);
        ctx.stroke();

        this.hueCircle = ctx.getImageData(0, 0, w, h);
      }
      this.generated = true;
    }

    /**
     * move the selector. This is called by hammer functions.
     *
     * @param event
     * @private
     */
  }, {
    key: '_moveSelector',
    value: function _moveSelector(event) {
      var rect = this.colorPickerDiv.getBoundingClientRect();
      var left = event.center.x - rect.left;
      var top = event.center.y - rect.top;

      var centerY = 0.5 * this.colorPickerDiv.clientHeight;
      var centerX = 0.5 * this.colorPickerDiv.clientWidth;

      var x = left - centerX;
      var y = top - centerY;

      var angle = Math.atan2(x, y);
      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);

      var newTop = Math.cos(angle) * radius + centerY;
      var newLeft = Math.sin(angle) * radius + centerX;

      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + 'px';
      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + 'px';

      // set color
      var h = angle / (2 * Math.PI);
      h = h < 0 ? h + 1 : h;
      var s = radius / this.r;
      var hsv = util.RGBToHSV(this.color.r, this.color.g, this.color.b);
      hsv.h = h;
      hsv.s = s;
      var rgba = util.HSVToRGB(hsv.h, hsv.s, hsv.v);
      rgba['a'] = this.color.a;
      this.color = rgba;

      // update previews
      this.initialColorDiv.style.backgroundColor = 'rgba(' + this.initialColor.r + ',' + this.initialColor.g + ',' + this.initialColor.b + ',' + this.initialColor.a + ')';
      this.newColorDiv.style.backgroundColor = 'rgba(' + this.color.r + ',' + this.color.g + ',' + this.color.b + ',' + this.color.a + ')';
    }
  }]);

  return ColorPicker;
})();

exports['default'] = ColorPicker;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9zaGFyZWQvQ29sb3JQaWNrZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3pDLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUMxQyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7O0lBRXhCLFdBQVc7QUFDSixXQURQLFdBQVcsR0FDYTtRQUFoQixVQUFVLHlEQUFHLENBQUM7OzBCQUR0QixXQUFXOztBQUViLFFBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO0FBQzdCLFFBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0FBQ3ZCLFFBQUksQ0FBQyxpQkFBaUIsR0FBRyxFQUFDLENBQUMsRUFBQyxHQUFHLEdBQUMsQ0FBQyxFQUFFLENBQUMsRUFBQyxHQUFHLEdBQUMsQ0FBQyxFQUFDLENBQUM7QUFDNUMsUUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLFFBQUksQ0FBQyxLQUFLLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUM7QUFDdkMsUUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7QUFDM0IsUUFBSSxDQUFDLFlBQVksR0FBRyxFQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQztBQUM5QyxRQUFJLENBQUMsYUFBYSxHQUFFLFNBQVMsQ0FBQztBQUM5QixRQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzs7O0FBR3JCLFFBQUksQ0FBQyxjQUFjLEdBQUcsWUFBTSxFQUFFLENBQUM7OztBQUcvQixRQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7R0FDaEI7Ozs7Ozs7ZUFqQkcsV0FBVzs7V0F3QlAsa0JBQUMsU0FBUyxFQUFFO0FBQ2xCLFVBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7QUFDN0IsWUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUN0QixZQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQztPQUN6QjtBQUNELFVBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQzNCLFVBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN2QyxVQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7O0FBRW5CLFVBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztLQUNqQjs7Ozs7Ozs7V0FNVSxxQkFBQyxRQUFRLEVBQUU7QUFDcEIsVUFBSSxPQUFPLFFBQVEsS0FBSyxVQUFVLEVBQUU7QUFDbEMsWUFBSSxDQUFDLGNBQWMsR0FBRyxRQUFRLENBQUM7T0FDaEMsTUFDSTtBQUNILGNBQU0sSUFBSSxLQUFLLENBQUMsc0VBQXNFLENBQUMsQ0FBQztPQUN6RjtLQUNGOzs7V0FFYSx3QkFBQyxLQUFLLEVBQUU7QUFDcEIsVUFBSSxVQUFVLEdBQUcsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUMsUUFBUSxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUMsUUFBUSxFQUFFLFNBQVMsRUFBQyxXQUFXLEVBQUUsU0FBUyxFQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUMsaUJBQWlCLEVBQUUsU0FBUyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUMsV0FBVyxFQUFFLFNBQVMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUMsWUFBWSxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUMsV0FBVyxFQUFFLFNBQVMsRUFBQyxRQUFRLEVBQUUsU0FBUyxFQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxjQUFjLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUMsZUFBZSxFQUFFLFNBQVMsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxjQUFjLEVBQUUsU0FBUyxFQUFDLGdCQUFnQixFQUFFLFNBQVMsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUMsZUFBZSxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUMsWUFBWSxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUMsV0FBVyxFQUFFLFNBQVMsRUFBQyxXQUFXLEVBQUUsU0FBUyxFQUFDLFlBQVksRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxZQUFZLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxXQUFXLEVBQUUsU0FBUyxFQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUMsY0FBYyxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsYUFBYSxFQUFFLFNBQVMsRUFBQyxZQUFZLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFDLGVBQWUsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsR0FBRyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUMsT0FBTyxFQUFFLFNBQVMsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsT0FBTyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUMsUUFBUSxFQUFFLFNBQVMsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUMsU0FBUyxFQUFFLFNBQVMsRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFDLE1BQU0sRUFBRSxTQUFT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QUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0tBQ3RJOzs7U0E1Z0JHLFdBQVc7OztxQkErZ0JGLFdBQVciLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL3NoYXJlZC9Db2xvclBpY2tlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImxldCBIYW1tZXIgPSByZXF1aXJlKCcuLi9tb2R1bGUvaGFtbWVyJyk7XG5sZXQgaGFtbWVyVXRpbCA9IHJlcXVpcmUoJy4uL2hhbW1lclV0aWwnKTtcbmxldCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5jbGFzcyBDb2xvclBpY2tlciB7XG4gIGNvbnN0cnVjdG9yKHBpeGVsUmF0aW8gPSAxKSB7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICB0aGlzLmdlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMgPSB7eDoyODkvMiwgeToyODkvMn07XG4gICAgdGhpcy5yID0gMjg5ICogMC40OTtcbiAgICB0aGlzLmNvbG9yID0ge3I6MjU1LGc6MjU1LGI6MjU1LGE6MS4wfTtcbiAgICB0aGlzLmh1ZUNpcmNsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluaXRpYWxDb2xvciA9IHtyOjI1NSxnOjI1NSxiOjI1NSxhOjEuMH07XG4gICAgdGhpcy5wcmV2aW91c0NvbG9yPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG5cbiAgICAvLyBib3VuZCBieVxuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSAoKSA9PiB7fTtcblxuICAgIC8vIGNyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiB0aGlzIGluc2VydHMgdGhlIGNvbG9yUGlja2VyIGludG8gYSBkaXYgZnJvbSB0aGUgRE9NXG4gICAqIEBwYXJhbSBjb250YWluZXJcbiAgICovXG4gIGluc2VydFRvKGNvbnRhaW5lcikge1xuICAgIGlmICh0aGlzLmhhbW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhhbW1lci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmhhbW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gICAgdGhpcy5fYmluZEhhbW1lcigpO1xuXG4gICAgdGhpcy5fc2V0U2l6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBvbiBhcHBseSBhbmQgc2F2ZS4gQmluZCBpdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBzZXRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBhdHRlbXB0ZWQgdG8gc2V0IGFzIGNvbG9yUGlja2VyIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gIH1cblxuICBfaXNDb2xvclN0cmluZyhjb2xvcikge1xuICAgIHZhciBodG1sQ29sb3JzID0ge2JsYWNrOiAnIzAwMDAwMCcsbmF2eTogJyMwMDAwODAnLGRhcmtibHVlOiAnIzAwMDA4QicsbWVkaXVtYmx1ZTogJyMwMDAwQ0QnLGJsdWU6ICcjMDAwMEZGJyxkYXJrZ3JlZW46ICcjMDA2NDAwJyxncmVlbjogJyMwMDgwMDAnLHRlYWw6ICcjMDA4MDgwJyxkYXJrY3lhbjogJyMwMDhCOEInLGRlZXBza3libHVlOiAnIzAwQkZGRicsZGFya3R1cnF1b2lzZTogJyMwMENFRDEnLG1lZGl1bXNwcmluZ2dyZWVuOiAnIzAwRkE5QScsbGltZTogJyMwMEZGMDAnLHNwcmluZ2dyZWVuOiAnIzAwRkY3RicsYXF1YTogJyMwMEZGRkYnLGN5YW46ICcjMDBGRkZGJyxtaWRuaWdodGJsdWU6ICcjMTkxOTcwJyxkb2RnZXJibHVlOiAnIzFFOTBGRicsbGlnaHRzZWFncmVlbjogJyMyMEIyQUEnLGZvcmVzdGdyZWVuOiAnIzIyOEIyMicsc2VhZ3JlZW46ICcjMkU4QjU3JyxkYXJrc2xhdGVncmF5OiAnIzJGNEY0RicsbGltZWdyZWVuOiAnIzMyQ0QzMicsbWVkaXVtc2VhZ3JlZW46ICcjM0NCMzcxJyx0dXJxdW9pc2U6ICcjNDBFMEQwJyxyb3lhbGJsdWU6ICcjNDE2OUUxJyxzdGVlbGJsdWU6ICcjNDY4MkI0JyxkYXJrc2xhdGVibHVlOiAnIzQ4M0Q4QicsbWVkaXVtdHVycXVvaXNlOiAnIzQ4RDFDQycsaW5kaWdvOiAnIzRCMDA4MicsZGFya29saXZlZ3JlZW46ICcjNTU2QjJGJyxjYWRldGJsdWU6ICcjNUY5RUEwJyxjb3JuZmxvd2VyYmx1ZTogJyM2NDk1RUQnLG1lZGl1bWFxdWFtYXJpbmU6ICcjNjZDREFBJyxkaW1ncmF5OiAnIzY5Njk2OScsc2xhdGVibHVlOiAnIzZBNUFDRCcsb2xpdmVkcmFiOiAnIzZCOEUyMycsc2xhdGVncmF5OiAnIzcwODA5MCcsbGlnaHRzbGF0ZWdyYXk6ICcjNzc4ODk5JyxtZWRpdW1zbGF0ZWJsdWU6ICcjN0I2OEVFJyxsYXduZ3JlZW46ICcjN0NGQzAwJyxjaGFydHJldXNlOiAnIzdGRkYwMCcsYXF1YW1hcmluZTogJyM3RkZGRDQnLG1hcm9vbjogJyM4MDAwMDAnLHB1cnBsZTogJyM4MDAwODAnLG9saXZlOiAnIzgwODAwMCcsZ3JheTogJyM4MDgwODAnLHNreWJsdWU6ICcjODdDRUVCJyxsaWdodHNreWJsdWU6ICcjODdDRUZBJyxibHVldmlvbGV0OiAnIzhBMkJFMicsZGFya3JlZDogJyM4QjAwMDAnLGRhcmttYWdlbnRhOiAnIzhCMDA4Qicsc2FkZGxlYnJvd246ICcjOEI0NTEzJyxkYXJrc2VhZ3JlZW46ICcjOEZCQzhGJyxsaWdodGdyZWVuOiAnIzkwRUU5MCcsbWVkaXVtcHVycGxlOiAnIzkzNzBEOCcsZGFya3Zpb2xldDogJyM5NDAwRDMnLHBhbGVncmVlbjogJyM5OEZCOTgnLGRhcmtvcmNoaWQ6ICcjOTkzMkNDJyx5ZWxsb3dncmVlbjogJyM5QUNEMzInLHNpZW5uYTogJyNBMDUyMkQnLGJyb3duOiAnI0E1MkEyQScsZGFya2dyYXk6ICcjQTlBOUE5JyxsaWdodGJsdWU6ICcjQUREOEU2JyxncmVlbnllbGxvdzogJyNBREZGMkYnLHBhbGV0dXJxdW9pc2U6ICcjQUZFRUVFJyxsaWdodHN0ZWVsYmx1ZTogJyNCMEM0REUnLHBvd2RlcmJsdWU6ICcjQjBFMEU2JyxmaXJlYnJpY2s6ICcjQjIyMjIyJyxkYXJrZ29sZGVucm9kOiAnI0I4ODYwQicsbWVkaXVtb3JjaGlkOiAnI0JBNTVEMycscm9zeWJyb3duOiAnI0JDOEY4RicsZGFya2toYWtpOiAnI0JEQjc2Qicsc2lsdmVyOiAnI0MwQzBDMCcsbWVkaXVtdmlvbGV0cmVkOiAnI0M3MTU4NScsaW5kaWFucmVkOiAnI0NENUM1QycscGVydTogJyNDRDg1M0YnLGNob2NvbGF0ZTogJyNEMjY5MUUnLHRhbjogJyNEMkI0OEMnLGxpZ2h0Z3JleTogJyNEM0QzRDMnLHBhbGV2aW9sZXRyZWQ6ICcjRDg3MDkzJyx0aGlzdGxlOiAnI0Q4QkZEOCcsb3JjaGlkOiAnI0RBNzBENicsZ29sZGVucm9kOiAnI0RBQTUyMCcsY3JpbXNvbjogJyNEQzE0M0MnLGdhaW5zYm9ybzogJyNEQ0RDREMnLHBsdW06ICcjRERBMEREJyxidXJseXdvb2Q6ICcjREVCODg3JyxsaWdodGN5YW46ICcjRTBGRkZGJyxsYXZlbmRlcjogJyNFNkU2RkEnLGRhcmtzYWxtb246ICcjRTk5NjdBJyx2aW9sZXQ6ICcjRUU4MkVFJyxwYWxlZ29sZGVucm9kOiAnI0VFRThBQScsbGlnaHRjb3JhbDogJyNGMDgwODAnLGtoYWtpOiAnI0YwRTY4QycsYWxpY2VibHVlOiAnI0YwRjhGRicsaG9uZXlkZXc6ICcjRjBGRkYwJyxhenVyZTogJyNGMEZGRkYnLHNhbmR5YnJvd246ICcjRjRBNDYwJyx3aGVhdDogJyNGNURFQjMnLGJlaWdlOiAnI0Y1RjVEQycsd2hpdGVzbW9rZTogJyNGNUY1RjUnLG1pbnRjcmVhbTogJyNGNUZGRkEnLGdob3N0d2hpdGU6ICcjRjhGOEZGJyxzYWxtb246ICcjRkE4MDcyJyxhbnRpcXVld2hpdGU6ICcjRkFFQkQ3JyxsaW5lbjogJyNGQUYwRTYnLGxpZ2h0Z29sZGVucm9keWVsbG93OiAnI0ZBRkFEMicsb2xkbGFjZTogJyNGREY1RTYnLHJlZDogJyNGRjAwMDAnLGZ1Y2hzaWE6ICcjRkYwMEZGJyxtYWdlbnRhOiAnI0ZGMDBGRicsZGVlcHBpbms6ICcjRkYxNDkzJyxvcmFuZ2VyZWQ6ICcjRkY0NTAwJyx0b21hdG86ICcjRkY2MzQ3Jyxob3RwaW5rOiAnI0ZGNjlCNCcsY29yYWw6ICcjRkY3RjUwJyxkYXJrb3JhbmdlOiAnI0ZGOEMwMCcsbGlnaHRzYWxtb246ICcjRkZBMDdBJyxvcmFuZ2U6ICcjRkZBNTAwJyxsaWdodHBpbms6ICcjRkZCNkMxJyxwaW5rOiAnI0ZGQzBDQicsZ29sZDogJyNGRkQ3MDAnLHBlYWNocHVmZjogJyNGRkRBQjknLG5hdmFqb3doaXRlOiAnI0ZGREVBRCcsbW9jY2FzaW46ICcjRkZFNEI1JyxiaXNxdWU6ICcjRkZFNEM0JyxtaXN0eXJvc2U6ICcjRkZFNEUxJyxibGFuY2hlZGFsbW9uZDogJyNGRkVCQ0QnLHBhcGF5YXdoaXA6ICcjRkZFRkQ1JyxsYXZlbmRlcmJsdXNoOiAnI0ZGRjBGNScsc2Vhc2hlbGw6ICcjRkZGNUVFJyxjb3Juc2lsazogJyNGRkY4REMnLGxlbW9uY2hpZmZvbjogJyNGRkZBQ0QnLGZsb3JhbHdoaXRlOiAnI0ZGRkFGMCcsc25vdzogJyNGRkZBRkEnLHllbGxvdzogJyNGRkZGMDAnLGxpZ2h0eWVsbG93OiAnI0ZGRkZFMCcsaXZvcnk6ICcjRkZGRkYwJyx3aGl0ZTogJyNGRkZGRkYnfTtcbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGh0bWxDb2xvcnNbY29sb3JdO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29sb3Igb2YgdGhlIGNvbG9yUGlja2VyXG4gICAqIFN1cHBvcnRlZCBmb3JtYXRzOlxuICAgKiAncmVkJyAgICAgICAgICAgICAgICAgICAtLT4gSFRNTCBjb2xvciBzdHJpbmdcbiAgICogJyNmZmZmZmYnICAgICAgICAgICAgICAgLS0+IGhleCBzdHJpbmdcbiAgICogJ3JiZygyNTUsMjU1LDI1NSknICAgICAgLS0+IHJnYiBzdHJpbmdcbiAgICogJ3JnYmEoMjU1LDI1NSwyNTUsMS4wKScgLS0+IHJnYmEgc3RyaW5nXG4gICAqIHtyOjI1NSxnOjI1NSxiOjI1NX0gICAgIC0tPiByZ2Igb2JqZWN0XG4gICAqIHtyOjI1NSxnOjI1NSxiOjI1NSxhOjEuMH0gLS0+IHJnYmEgb2JqZWN0XG4gICAqIEBwYXJhbSBjb2xvclxuICAgKiBAcGFyYW0gc2V0SW5pdGlhbFxuICAgKi9cbiAgc2V0Q29sb3IoY29sb3IsIHNldEluaXRpYWwgPSB0cnVlKSB7XG4gICAgaWYgKGNvbG9yID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmdiYTtcblxuICAgIC8vIGlmIGEgaHRtbCBjb2xvciBzaG9ydGhhbmQgaXMgdXNlZCwgY29udmVydCB0byBoZXhcbiAgICB2YXIgaHRtbENvbG9yID0gdGhpcy5faXNDb2xvclN0cmluZyhjb2xvcik7XG4gICAgaWYgKGh0bWxDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2xvciA9IGh0bWxDb2xvcjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3JtYXRcbiAgICBpZiAodXRpbC5pc1N0cmluZyhjb2xvcikgPT09IHRydWUpIHtcbiAgICAgIGlmICh1dGlsLmlzVmFsaWRSR0IoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgIGxldCByZ2JhQXJyYXkgPSBjb2xvci5zdWJzdHIoNCkuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDUpLnNwbGl0KCcsJyk7XG4gICAgICAgIHJnYmEgPSB7cjpyZ2JhQXJyYXlbMF0sIGc6cmdiYUFycmF5WzFdLCBiOnJnYmFBcnJheVsyXSwgYToxLjB9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodXRpbC5pc1ZhbGlkUkdCQShjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgbGV0IHJnYmFBcnJheSA9IGNvbG9yLnN1YnN0cig1KS5zdWJzdHIoMCwgY29sb3IubGVuZ3RoIC0gNikuc3BsaXQoJywnKTtcbiAgICAgICAgcmdiYSA9IHtyOnJnYmFBcnJheVswXSwgZzpyZ2JhQXJyYXlbMV0sIGI6cmdiYUFycmF5WzJdLCBhOnJnYmFBcnJheVszXX07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh1dGlsLmlzVmFsaWRIZXgoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgIGxldCByZ2JPYmogPSB1dGlsLmhleFRvUkdCKGNvbG9yKTtcbiAgICAgICAgcmdiYSA9IHtyOnJnYk9iai5yLCBnOnJnYk9iai5nLCBiOnJnYk9iai5iLCBhOjEuMH07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIGlmIChjb2xvci5yICE9PSB1bmRlZmluZWQgJiYgY29sb3IuZyAhPT0gdW5kZWZpbmVkICYmIGNvbG9yLmIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxldCBhbHBoYSA9IGNvbG9yLmEgIT09IHVuZGVmaW5lZCA/IGNvbG9yLmEgOiAnMS4wJztcbiAgICAgICAgICByZ2JhID0ge3I6Y29sb3IuciwgZzpjb2xvci5nLCBiOmNvbG9yLmIsIGE6YWxwaGF9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0IGNvbG9yXG4gICAgaWYgKHJnYmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb2xvciBwYXNzZWQgdG8gdGhlIGNvbG9yUGlja2VyLiBTdXBwb3J0ZWQgYXJlIHN0cmluZ3M6IHJnYiwgaGV4LCByZ2JhLiBPYmplY3Q6IHJnYiAoe3I6cixnOmcsYjpiLFthOmFdfSkuIFN1cHBsaWVkOiBcIiArIEpTT04uc3RyaW5naWZ5KGNvbG9yKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fc2V0Q29sb3IocmdiYSwgc2V0SW5pdGlhbCk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogdGhpcyBzaG93cyB0aGUgY29sb3IgcGlja2VyIGF0IGEgbG9jYXRpb24uIFRoZSBodWUgY2lyY2xlIGlzIGNvbnN0cnVjdGVkIG9uY2UgYW5kIHN0b3JlZC5cbiAgICogQHBhcmFtIHhcbiAgICogQHBhcmFtIHlcbiAgICovXG4gIHNob3coeCx5KSB7XG4gICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgdGhpcy5mcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0aGlzLmZyYW1lLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xuICAgIHRoaXMuZnJhbWUuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgIHRoaXMuX2dlbmVyYXRlSHVlQ2lyY2xlKCk7XG4gIH1cblxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQUklWQVRFIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIHBpY2tlci4gSXMgY2FsbGVkIGJ5IHRoZSBjYW5jZWwgYnV0dG9uLlxuICAgKiBPcHRpb25hbCBib29sZWFuIHRvIHN0b3JlIHRoZSBwcmV2aW91cyBjb2xvciBmb3IgZWFzeSBhY2Nlc3MgbGF0ZXIgb24uXG4gICAqIEBwYXJhbSBzdG9yZVByZXZpb3VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGlkZShzdG9yZVByZXZpb3VzID0gdHJ1ZSkge1xuICAgIC8vIHN0b3JlIHRoZSBwcmV2aW91cyBjb2xvciBmb3IgbmV4dCB0aW1lO1xuICAgIGlmIChzdG9yZVByZXZpb3VzID09PSB0cnVlKSB7XG4gICAgICB0aGlzLnByZXZpb3VzQ29sb3IgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5jb2xvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXBwbGllZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmluaXRpYWxDb2xvcik7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG5cblxuICAvKipcbiAgICogYm91bmQgdG8gdGhlIHNhdmUgYnV0dG9uLiBTYXZlcyBhbmQgaGlkZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2F2ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuY29sb3IpO1xuICAgIHRoaXMuYXBwbGllZCA9IGZhbHNlO1xuICAgIHRoaXMuX2hpZGUoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEJvdW5kIHRvIGFwcGx5IGJ1dHRvbi4gU2F2ZXMgYnV0IGRvZXMgbm90IGNsb3NlLiBJcyB1bmRvbmUgYnkgdGhlIGNhbmNlbCBidXR0b24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHkoKSB7XG4gICAgdGhpcy5hcHBsaWVkID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuY29sb3IpO1xuICAgIHRoaXMuX3VwZGF0ZVBpY2tlcih0aGlzLmNvbG9yKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGxvYWQgdGhlIGNvbG9yIGZyb20gdGhlIHByZXZpb3VzIHNlc3Npb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbG9hZExhc3QoKSB7XG4gICAgaWYgKHRoaXMucHJldmlvdXNDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldENvbG9yKHRoaXMucHJldmlvdXNDb2xvciwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFsZXJ0KFwiVGhlcmUgaXMgbm8gbGFzdCBjb2xvciB0byBsb2FkLi4uXCIpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIHNldCB0aGUgY29sb3IsIHBsYWNlIHRoZSBwaWNrZXJcbiAgICogQHBhcmFtIHJnYmFcbiAgICogQHBhcmFtIHNldEluaXRpYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRDb2xvcihyZ2JhLCBzZXRJbml0aWFsID0gdHJ1ZSkge1xuICAgIC8vIHN0b3JlIHRoZSBpbml0aWFsIGNvbG9yXG4gICAgaWYgKHNldEluaXRpYWwgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuaW5pdGlhbENvbG9yID0gdXRpbC5leHRlbmQoe30sIHJnYmEpO1xuICAgIH1cblxuICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuICAgIGxldCBoc3YgPSB1dGlsLlJHQlRvSFNWKHJnYmEuciwgcmdiYS5nLCByZ2JhLmIpO1xuXG4gICAgbGV0IGFuZ2xlQ29udmVydCA9IDIgKiBNYXRoLlBJO1xuICAgIGxldCByYWRpdXMgPSB0aGlzLnIgKiBoc3YucztcbiAgICBsZXQgeCA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlQ29udmVydCAqIGhzdi5oKTtcbiAgICBsZXQgeSA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlQ29udmVydCAqIGhzdi5oKTtcblxuICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS5sZWZ0ID0geCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCArICdweCc7XG4gICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLnRvcCA9IHkgLSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IuY2xpZW50SGVpZ2h0ICsgJ3B4JztcblxuICAgIHRoaXMuX3VwZGF0ZVBpY2tlcihyZ2JhKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGJvdW5kIHRvIG9wYWNpdHkgY29udHJvbFxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRPcGFjaXR5KHZhbHVlKSB7XG4gICAgdGhpcy5jb2xvci5hID0gdmFsdWUgLyAxMDA7XG4gICAgdGhpcy5fdXBkYXRlUGlja2VyKHRoaXMuY29sb3IpO1xuICB9XG5cblxuICAvKipcbiAgICogYm91bmQgdG8gYnJpZ2h0bmVzcyBjb250cm9sXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldEJyaWdodG5lc3ModmFsdWUpIHtcbiAgICBsZXQgaHN2ID0gdXRpbC5SR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICBoc3YudiA9IHZhbHVlIC8gMTAwO1xuICAgIGxldCByZ2JhID0gdXRpbC5IU1ZUb1JHQihoc3YuaCwgaHN2LnMsIGhzdi52KTtcbiAgICByZ2JhWydhJ10gPSB0aGlzLmNvbG9yLmE7XG4gICAgdGhpcy5jb2xvciA9IHJnYmE7XG4gICAgdGhpcy5fdXBkYXRlUGlja2VyKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiB1cGRhdGUgdGhlIGNvbG9ycGlja2VyLiBBIGJsYWNrIGNpcmNsZSBvdmVybGF5cyB0aGUgaHVlIGNpcmNsZSB0byBtaW1pYyB0aGUgYnJpZ2h0bmVzcyBkZWNyZWFzaW5nLlxuICAgKiBAcGFyYW0gcmdiYVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZVBpY2tlcihyZ2JhID0gdGhpcy5jb2xvcikge1xuICAgIGxldCBoc3YgPSB1dGlsLlJHQlRvSFNWKHJnYmEuciwgcmdiYS5nLCByZ2JhLmIpO1xuICAgIGxldCBjdHggPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKHRoaXMucGl4ZWxSYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICB9XG4gICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAvLyBjbGVhciB0aGUgY2FudmFzXG4gICAgbGV0IHcgPSB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmNsaWVudFdpZHRoO1xuICAgIGxldCBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcblxuICAgIGN0eC5wdXRJbWFnZURhdGEodGhpcy5odWVDaXJjbGUsIDAsMCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLCcgKyAoMS0gaHN2LnYpICsgJyknO1xuICAgIGN0eC5jaXJjbGUodGhpcy5jZW50ZXJDb29yZGluYXRlcy54LCB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnksIHRoaXMucik7XG4gICAgY3R4LmZpbGwoKTtcblxuICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnZhbHVlID0gMTAwICogaHN2LnY7XG4gICAgdGhpcy5vcGFjaXR5UmFuZ2UudmFsdWUgICAgPSAxMDAgKiByZ2JhLmE7XG5cbiAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5pbml0aWFsQ29sb3IuciArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmcgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5iICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuYSArICcpJztcbiAgICB0aGlzLm5ld0NvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmNvbG9yLnIgKyAnLCcgKyB0aGlzLmNvbG9yLmcgKyAnLCcgKyB0aGlzLmNvbG9yLmIgKyAnLCcgKyB0aGlzLmNvbG9yLmEgKyAnKSc7XG4gIH1cblxuXG4gIC8qKlxuICAgKiB1c2VkIGJ5IGNyZWF0ZSB0byBzZXQgdGhlIHNpemUgb2YgdGhlIGNhbnZhcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRTaXplKCkge1xuICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cbiAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLndpZHRoID0gMjg5ICogdGhpcy5waXhlbFJhdGlvO1xuICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuaGVpZ2h0ID0gMjg5ICogdGhpcy5waXhlbFJhdGlvO1xuICB9XG5cblxuICAvKipcbiAgICogY3JlYXRlIGFsbCBkb20gZWxlbWVudHNcbiAgICogVE9ETzogY2xlYW51cCwgbG90cyBvZiBzaW1pbGFyIGRvbSBlbGVtZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZSgpIHtcbiAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSAndmlzLWNvbG9yLXBpY2tlcic7XG5cbiAgICB0aGlzLmNvbG9yUGlja2VyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsYXNzTmFtZSA9ICd2aXMtc2VsZWN0b3InO1xuICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlclNlbGVjdG9yKTtcblxuICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJDYW52YXMpO1xuXG4gICAgaWYgKCF0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQpIHtcbiAgICAgIGxldCBub0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdESVYnICk7XG4gICAgICBub0NhbnZhcy5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgbm9DYW52YXMuc3R5bGUuZm9udFdlaWdodCA9ICAnYm9sZCcgO1xuICAgICAgbm9DYW52YXMuc3R5bGUucGFkZGluZyA9ICAnMTBweCc7XG4gICAgICBub0NhbnZhcy5pbm5lckhUTUwgPSAgJ0Vycm9yOiB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIGNhbnZhcyc7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmFwcGVuZENoaWxkKG5vQ2FudmFzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsZXQgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuXG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgIH1cblxuICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb2xvcic7XG5cbiAgICB0aGlzLm9wYWNpdHlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLm9wYWNpdHlEaXYuY2xhc3NOYW1lID0gJ3Zpcy1vcGFjaXR5JztcblxuICAgIHRoaXMuYnJpZ2h0bmVzc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5jbGFzc05hbWUgPSAndmlzLWJyaWdodG5lc3MnO1xuXG4gICAgdGhpcy5hcnJvd0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuYXJyb3dEaXYuY2xhc3NOYW1lID0gJ3Zpcy1hcnJvdyc7XG5cbiAgICB0aGlzLm9wYWNpdHlSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnR5cGUgPSAncmFuZ2UnOyAvLyBOb3Qgc3VwcG9ydGVkIG9uIElFOVxuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UubWluID0gJzAnO1xuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UubWF4ID0gJzEwMCc7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHt9XG4gICAgdGhpcy5vcGFjaXR5UmFuZ2UudmFsdWUgPSAnMTAwJztcbiAgICB0aGlzLm9wYWNpdHlSYW5nZS5jbGFzc05hbWUgPSAndmlzLXJhbmdlJztcblxuICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudHlwZSA9ICdyYW5nZSc7IC8vIE5vdCBzdXBwb3J0ZWQgb24gSUU5XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5taW4gPSAnMCc7XG4gICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5tYXggPSAnMTAwJztcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge31cbiAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS52YWx1ZSA9ICcxMDAnO1xuICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLmNsYXNzTmFtZSA9ICd2aXMtcmFuZ2UnO1xuXG4gICAgdGhpcy5vcGFjaXR5RGl2LmFwcGVuZENoaWxkKHRoaXMub3BhY2l0eVJhbmdlKTtcbiAgICB0aGlzLmJyaWdodG5lc3NEaXYuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzUmFuZ2UpO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB0aGlzLm9wYWNpdHlSYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHttZS5fc2V0T3BhY2l0eSh0aGlzLnZhbHVlKTt9O1xuICAgIHRoaXMub3BhY2l0eVJhbmdlLm9uaW5wdXQgID0gZnVuY3Rpb24gKCkge21lLl9zZXRPcGFjaXR5KHRoaXMudmFsdWUpO307XG4gICAgdGhpcy5icmlnaHRuZXNzUmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7bWUuX3NldEJyaWdodG5lc3ModGhpcy52YWx1ZSk7fTtcbiAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5vbmlucHV0ICA9IGZ1bmN0aW9uICgpIHttZS5fc2V0QnJpZ2h0bmVzcyh0aGlzLnZhbHVlKTt9O1xuXG4gICAgdGhpcy5icmlnaHRuZXNzTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsLmNsYXNzTmFtZSA9IFwidmlzLWxhYmVsIHZpcy1icmlnaHRuZXNzXCI7XG4gICAgdGhpcy5icmlnaHRuZXNzTGFiZWwuaW5uZXJIVE1MID0gJ2JyaWdodG5lc3M6JztcblxuICAgIHRoaXMub3BhY2l0eUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLm9wYWNpdHlMYWJlbC5jbGFzc05hbWUgPSBcInZpcy1sYWJlbCB2aXMtb3BhY2l0eVwiO1xuICAgIHRoaXMub3BhY2l0eUxhYmVsLmlubmVySFRNTCA9ICdvcGFjaXR5Oic7XG5cbiAgICB0aGlzLm5ld0NvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLm5ld0NvbG9yRGl2LmNsYXNzTmFtZSA9IFwidmlzLW5ldy1jb2xvclwiO1xuICAgIHRoaXMubmV3Q29sb3JEaXYuaW5uZXJIVE1MID0gJ25ldyc7XG5cbiAgICB0aGlzLmluaXRpYWxDb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuY2xhc3NOYW1lID0gXCJ2aXMtaW5pdGlhbC1jb2xvclwiO1xuICAgIHRoaXMuaW5pdGlhbENvbG9yRGl2LmlubmVySFRNTCA9ICdpbml0aWFsJztcblxuICAgIHRoaXMuY2FuY2VsQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWNhbmNlbFwiO1xuICAgIHRoaXMuY2FuY2VsQnV0dG9uLmlubmVySFRNTCA9ICdjYW5jZWwnO1xuICAgIHRoaXMuY2FuY2VsQnV0dG9uLm9uY2xpY2sgPSB0aGlzLl9oaWRlLmJpbmQodGhpcywgZmFsc2UpO1xuXG4gICAgdGhpcy5hcHBseUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5hcHBseUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWFwcGx5XCI7XG4gICAgdGhpcy5hcHBseUJ1dHRvbi5pbm5lckhUTUwgPSAnYXBwbHknO1xuICAgIHRoaXMuYXBwbHlCdXR0b24ub25jbGljayA9IHRoaXMuX2FwcGx5LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnNhdmVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuc2F2ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLXNhdmVcIjtcbiAgICB0aGlzLnNhdmVCdXR0b24uaW5uZXJIVE1MID0gJ3NhdmUnO1xuICAgIHRoaXMuc2F2ZUJ1dHRvbi5vbmNsaWNrID0gdGhpcy5fc2F2ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5sb2FkQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmxvYWRCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1sb2FkXCI7XG4gICAgdGhpcy5sb2FkQnV0dG9uLmlubmVySFRNTCA9ICdsb2FkIGxhc3QnO1xuICAgIHRoaXMubG9hZEJ1dHRvbi5vbmNsaWNrID0gdGhpcy5fbG9hZExhc3QuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jb2xvclBpY2tlckRpdik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmFycm93RGl2KTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0xhYmVsKTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0Rpdik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlMYWJlbCk7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlEaXYpO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5uZXdDb2xvckRpdik7XG4gICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmluaXRpYWxDb2xvckRpdik7XG5cbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuY2FuY2VsQnV0dG9uKTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYXBwbHlCdXR0b24pO1xuICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5zYXZlQnV0dG9uKTtcbiAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubG9hZEJ1dHRvbik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBiaW5kIGhhbW1lciB0byB0aGUgY29sb3IgcGlja2VyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYmluZEhhbW1lcigpIHtcbiAgICB0aGlzLmRyYWcgPSB7fTtcbiAgICB0aGlzLnBpbmNoID0ge307XG4gICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyKHRoaXMuY29sb3JQaWNrZXJDYW52YXMpO1xuICAgIHRoaXMuaGFtbWVyLmdldCgncGluY2gnKS5zZXQoe2VuYWJsZTogdHJ1ZX0pO1xuXG4gICAgaGFtbWVyVXRpbC5vblRvdWNoKHRoaXMuaGFtbWVyLCAoZXZlbnQpID0+IHt0aGlzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpfSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3RhcCcsICAgICAgIChldmVudCkgPT4ge3RoaXMuX21vdmVTZWxlY3RvcihldmVudCl9KTtcbiAgICB0aGlzLmhhbW1lci5vbigncGFuc3RhcnQnLCAgKGV2ZW50KSA9PiB7dGhpcy5fbW92ZVNlbGVjdG9yKGV2ZW50KX0pO1xuICAgIHRoaXMuaGFtbWVyLm9uKCdwYW5tb3ZlJywgICAoZXZlbnQpID0+IHt0aGlzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpfSk7XG4gICAgdGhpcy5oYW1tZXIub24oJ3BhbmVuZCcsICAgIChldmVudCkgPT4ge3RoaXMuX21vdmVTZWxlY3RvcihldmVudCl9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGdlbmVyYXRlIHRoZSBodWUgY2lyY2xlLiBUaGlzIGlzIHJlbGF0aXZlbHkgaGVhdnkgKDIwMG1zKSBhbmQgaXMgZG9uZSBvbmx5IG9uY2Ugb24gdGhlIGZpcnN0IHRpbWUgaXQgaXMgc2hvd24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2VuZXJhdGVIdWVDaXJjbGUoKSB7XG4gICAgaWYgKHRoaXMuZ2VuZXJhdGVkID09PSBmYWxzZSkge1xuICAgICAgbGV0IGN0eCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gKGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgfVxuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAgIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgIGxldCB3ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIGxldCBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuXG5cbiAgICAgIC8vIGRyYXcgaHVlIGNpcmNsZVxuICAgICAgbGV0IHgsIHksIGh1ZSwgc2F0O1xuICAgICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHt4OiB3ICogMC41LCB5OiBoICogMC41fTtcbiAgICAgIHRoaXMuciA9IDAuNDkgKiB3O1xuICAgICAgbGV0IGFuZ2xlQ29udmVydCA9ICgyICogTWF0aC5QSSkgLyAzNjA7XG4gICAgICBsZXQgaGZhYyA9IDEgLyAzNjA7XG4gICAgICBsZXQgc2ZhYyA9IDEgLyB0aGlzLnI7XG4gICAgICBsZXQgcmdiO1xuICAgICAgZm9yIChodWUgPSAwOyBodWUgPCAzNjA7IGh1ZSsrKSB7XG4gICAgICAgIGZvciAoc2F0ID0gMDsgc2F0IDwgdGhpcy5yOyBzYXQrKykge1xuICAgICAgICAgIHggPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnggKyBzYXQgKiBNYXRoLnNpbihhbmdsZUNvbnZlcnQgKiBodWUpO1xuICAgICAgICAgIHkgPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnkgKyBzYXQgKiBNYXRoLmNvcyhhbmdsZUNvbnZlcnQgKiBodWUpO1xuICAgICAgICAgIHJnYiA9IHV0aWwuSFNWVG9SR0IoaHVlICogaGZhYywgc2F0ICogc2ZhYywgMSk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2IoJyArIHJnYi5yICsgJywnICsgcmdiLmcgKyAnLCcgKyByZ2IuYiArICcpJztcbiAgICAgICAgICBjdHguZmlsbFJlY3QoeCAtIDAuNSwgeSAtIDAuNSwgMiwgMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDEpJztcbiAgICAgIGN0eC5jaXJjbGUodGhpcy5jZW50ZXJDb29yZGluYXRlcy54LCB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnksIHRoaXMucik7XG4gICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgIHRoaXMuaHVlQ2lyY2xlID0gY3R4LmdldEltYWdlRGF0YSgwLDAsdyxoKTtcbiAgICB9XG4gICAgdGhpcy5nZW5lcmF0ZWQgPSB0cnVlO1xuICB9XG5cblxuICAvKipcbiAgICogbW92ZSB0aGUgc2VsZWN0b3IuIFRoaXMgaXMgY2FsbGVkIGJ5IGhhbW1lciBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVTZWxlY3RvcihldmVudCkge1xuICAgIGxldCByZWN0ID0gdGhpcy5jb2xvclBpY2tlckRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgbGVmdCA9IGV2ZW50LmNlbnRlci54IC0gcmVjdC5sZWZ0O1xuICAgIGxldCB0b3AgPSBldmVudC5jZW50ZXIueSAtIHJlY3QudG9wO1xuXG4gICAgbGV0IGNlbnRlclkgPSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyRGl2LmNsaWVudEhlaWdodDtcbiAgICBsZXQgY2VudGVyWCA9IDAuNSAqIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xpZW50V2lkdGg7XG5cbiAgICBsZXQgeCA9IGxlZnQgLSBjZW50ZXJYO1xuICAgIGxldCB5ID0gdG9wIC0gY2VudGVyWTtcblxuICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoeCx5KTtcbiAgICBsZXQgcmFkaXVzID0gMC45OCAqIE1hdGgubWluKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSwgY2VudGVyWCk7XG5cbiAgICBsZXQgbmV3VG9wID0gTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzICsgY2VudGVyWTtcbiAgICBsZXQgbmV3TGVmdCA9IE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyArIGNlbnRlclg7XG5cbiAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0gbmV3VG9wIC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudEhlaWdodCArICdweCc7XG4gICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLnN0eWxlLmxlZnQgPSBuZXdMZWZ0IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudFdpZHRoICsgJ3B4JztcblxuICAgIC8vIHNldCBjb2xvclxuICAgIGxldCBoID0gYW5nbGUgLyAoMiAqIE1hdGguUEkpO1xuICAgIGggPSBoIDwgMCA/IGggKyAxIDogaDtcbiAgICBsZXQgcyA9IHJhZGl1cyAvIHRoaXMucjtcbiAgICBsZXQgaHN2ID0gdXRpbC5SR0JUb0hTVih0aGlzLmNvbG9yLnIsIHRoaXMuY29sb3IuZywgdGhpcy5jb2xvci5iKTtcbiAgICBoc3YuaCA9IGg7XG4gICAgaHN2LnMgPSBzO1xuICAgIGxldCByZ2JhID0gdXRpbC5IU1ZUb1JHQihoc3YuaCwgaHN2LnMsIGhzdi52KTtcbiAgICByZ2JhWydhJ10gPSB0aGlzLmNvbG9yLmE7XG4gICAgdGhpcy5jb2xvciA9IHJnYmE7XG5cbiAgICAvLyB1cGRhdGUgcHJldmlld3NcbiAgICB0aGlzLmluaXRpYWxDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgnICsgdGhpcy5pbml0aWFsQ29sb3IuciArICcsJyArIHRoaXMuaW5pdGlhbENvbG9yLmcgKyAnLCcgKyB0aGlzLmluaXRpYWxDb2xvci5iICsgJywnICsgdGhpcy5pbml0aWFsQ29sb3IuYSArICcpJztcbiAgICB0aGlzLm5ld0NvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKCcgKyB0aGlzLmNvbG9yLnIgKyAnLCcgKyB0aGlzLmNvbG9yLmcgKyAnLCcgKyB0aGlzLmNvbG9yLmIgKyAnLCcgKyB0aGlzLmNvbG9yLmEgKyAnKSc7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29sb3JQaWNrZXI7Il19
},{"../hammerUtil":18,"../module/hammer":19,"../util":46}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _ColorPicker = require('./ColorPicker');

var _ColorPicker2 = _interopRequireDefault(_ColorPicker);

/**
 * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
 * Boolean options are recognised as Boolean
 * Number options should be written as array: [default value, min value, max value, stepsize]
 * Colors should be written as array: ['color', '#ffffff']
 * Strings with should be written as array: [option1, option2, option3, ..]
 *
 * The options are matched with their counterparts in each of the modules and the values used in the configuration are
 *
 * @param parentModule        | the location where parentModule.setOptions() can be called
 * @param defaultContainer    | the default container of the module
 * @param configureOptions    | the fully configured and predefined options set found in allOptions.js
 * @param pixelRatio          | canvas pixel ratio
 */
var util = require('../util');

var Configurator = (function () {
  function Configurator(parentModule, defaultContainer, configureOptions) {
    var pixelRatio = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];

    _classCallCheck(this, Configurator);

    this.parent = parentModule;
    this.changedOptions = [];
    this.container = defaultContainer;
    this.allowCreation = false;

    this.options = {};
    this.initialized = false;
    this.popupCounter = 0;
    this.defaultOptions = {
      enabled: false,
      filter: true,
      container: undefined,
      showButton: true
    };
    util.extend(this.options, this.defaultOptions);

    this.configureOptions = configureOptions;
    this.moduleOptions = {};
    this.domElements = [];
    this.popupDiv = {};
    this.popupLimit = 5;
    this.popupHistory = {};
    this.colorPicker = new _ColorPicker2['default'](pixelRatio);
    this.wrapper = undefined;
  }

  /**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   *
   * @param options
   */

  _createClass(Configurator, [{
    key: 'setOptions',
    value: function setOptions(options) {
      if (options !== undefined) {
        // reset the popup history because the indices may have been changed.
        this.popupHistory = {};
        this._removePopup();

        var enabled = true;
        if (typeof options === 'string') {
          this.options.filter = options;
        } else if (options instanceof Array) {
          this.options.filter = options.join();
        } else if (typeof options === 'object') {
          if (options.container !== undefined) {
            this.options.container = options.container;
          }
          if (options.filter !== undefined) {
            this.options.filter = options.filter;
          }
          if (options.showButton !== undefined) {
            this.options.showButton = options.showButton;
          }
          if (options.enabled !== undefined) {
            enabled = options.enabled;
          }
        } else if (typeof options === 'boolean') {
          this.options.filter = true;
          enabled = options;
        } else if (typeof options === 'function') {
          this.options.filter = options;
          enabled = true;
        }
        if (this.options.filter === false) {
          enabled = false;
        }

        this.options.enabled = enabled;
      }
      this._clean();
    }
  }, {
    key: 'setModuleOptions',
    value: function setModuleOptions(moduleOptions) {
      this.moduleOptions = moduleOptions;
      if (this.options.enabled === true) {
        this._clean();
        if (this.options.container !== undefined) {
          this.container = this.options.container;
        }
        this._create();
      }
    }

    /**
     * Create all DOM elements
     * @private
     */
  }, {
    key: '_create',
    value: function _create() {
      var _this = this;

      this._clean();
      this.changedOptions = [];

      var filter = this.options.filter;
      var counter = 0;
      var show = false;
      for (var option in this.configureOptions) {
        if (this.configureOptions.hasOwnProperty(option)) {
          this.allowCreation = false;
          show = false;
          if (typeof filter === 'function') {
            show = filter(option, []);
            show = show || this._handleObject(this.configureOptions[option], [option], true);
          } else if (filter === true || filter.indexOf(option) !== -1) {
            show = true;
          }

          if (show !== false) {
            this.allowCreation = true;

            // linebreak between categories
            if (counter > 0) {
              this._makeItem([]);
            }
            // a header for the category
            this._makeHeader(option);

            // get the suboptions
            this._handleObject(this.configureOptions[option], [option]);
          }
          counter++;
        }
      }

      if (this.options.showButton === true) {
        (function () {
          var generateButton = document.createElement('div');
          generateButton.className = 'vis-configuration vis-config-button';
          generateButton.innerHTML = 'generate options';
          generateButton.onclick = function () {
            _this._printOptions();
          };
          generateButton.onmouseover = function () {
            generateButton.className = 'vis-configuration vis-config-button hover';
          };
          generateButton.onmouseout = function () {
            generateButton.className = 'vis-configuration vis-config-button';
          };

          _this.optionsContainer = document.createElement('div');
          _this.optionsContainer.className = 'vis-configuration vis-config-option-container';

          _this.domElements.push(_this.optionsContainer);
          _this.domElements.push(generateButton);
        })();
      }

      this._push();
      this.colorPicker.insertTo(this.container);
    }

    /**
     * draw all DOM elements on the screen
     * @private
     */
  }, {
    key: '_push',
    value: function _push() {
      this.wrapper = document.createElement('div');
      this.wrapper.className = 'vis-configuration-wrapper';
      this.container.appendChild(this.wrapper);
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.appendChild(this.domElements[i]);
      }

      this._showPopupIfNeeded();
    }

    /**
     * delete all DOM elements
     * @private
     */
  }, {
    key: '_clean',
    value: function _clean() {
      for (var i = 0; i < this.domElements.length; i++) {
        this.wrapper.removeChild(this.domElements[i]);
      }

      if (this.wrapper !== undefined) {
        this.container.removeChild(this.wrapper);
        this.wrapper = undefined;
      }
      this.domElements = [];

      this._removePopup();
    }

    /**
     * get the value from the actualOptions if it exists
     * @param {array} path    | where to look for the actual option
     * @returns {*}
     * @private
     */
  }, {
    key: '_getValue',
    value: function _getValue(path) {
      var base = this.moduleOptions;
      for (var i = 0; i < path.length; i++) {
        if (base[path[i]] !== undefined) {
          base = base[path[i]];
        } else {
          base = undefined;
          break;
        }
      }
      return base;
    }

    /**
     * all option elements are wrapped in an item
     * @param path
     * @param domElements
     * @private
     */
  }, {
    key: '_makeItem',
    value: function _makeItem(path) {
      var _arguments = arguments,
          _this2 = this;

      if (this.allowCreation === true) {
        var _len, domElements, _key;

        var _ret2 = (function () {
          var item = document.createElement('div');
          item.className = 'vis-configuration vis-config-item vis-config-s' + path.length;

          for (_len = _arguments.length, domElements = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            domElements[_key - 1] = _arguments[_key];
          }

          domElements.forEach(function (element) {
            item.appendChild(element);
          });
          _this2.domElements.push(item);
          return {
            v: _this2.domElements.length
          };
        })();

        if (typeof _ret2 === 'object') return _ret2.v;
      }
      return 0;
    }

    /**
     * header for major subjects
     * @param name
     * @private
     */
  }, {
    key: '_makeHeader',
    value: function _makeHeader(name) {
      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-header';
      div.innerHTML = name;
      this._makeItem([], div);
    }

    /**
     * make a label, if it is an object label, it gets different styling.
     * @param name
     * @param path
     * @param objectLabel
     * @returns {HTMLElement}
     * @private
     */
  }, {
    key: '_makeLabel',
    value: function _makeLabel(name, path) {
      var objectLabel = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var div = document.createElement('div');
      div.className = 'vis-configuration vis-config-label vis-config-s' + path.length;
      if (objectLabel === true) {
        div.innerHTML = '<i><b>' + name + ':</b></i>';
      } else {
        div.innerHTML = name + ':';
      }
      return div;
    }

    /**
     * make a dropdown list for multiple possible string optoins
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeDropdown',
    value: function _makeDropdown(arr, value, path) {
      var select = document.createElement('select');
      select.className = 'vis-configuration vis-config-select';
      var selectedValue = 0;
      if (value !== undefined) {
        if (arr.indexOf(value) !== -1) {
          selectedValue = arr.indexOf(value);
        }
      }

      for (var i = 0; i < arr.length; i++) {
        var option = document.createElement('option');
        option.value = arr[i];
        if (i === selectedValue) {
          option.selected = 'selected';
        }
        option.innerHTML = arr[i];
        select.appendChild(option);
      }

      var me = this;
      select.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, select);
    }

    /**
     * make a range object for numeric options
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeRange',
    value: function _makeRange(arr, value, path) {
      var defaultValue = arr[0];
      var min = arr[1];
      var max = arr[2];
      var step = arr[3];
      var range = document.createElement('input');
      range.className = 'vis-configuration vis-config-range';
      try {
        range.type = 'range'; // not supported on IE9
        range.min = min;
        range.max = max;
      } catch (err) {}
      range.step = step;

      // set up the popup settings in case they are needed.
      var popupString = '';
      var popupValue = 0;

      if (value !== undefined) {
        var factor = 1.20;
        if (value < 0 && value * factor < min) {
          range.min = Math.ceil(value * factor);
          popupValue = range.min;
          popupString = 'range increased';
        } else if (value / factor < min) {
          range.min = Math.ceil(value / factor);
          popupValue = range.min;
          popupString = 'range increased';
        }
        if (value * factor > max && max !== 1) {
          range.max = Math.ceil(value * factor);
          popupValue = range.max;
          popupString = 'range increased';
        }
        range.value = value;
      } else {
        range.value = defaultValue;
      }

      var input = document.createElement('input');
      input.className = 'vis-configuration vis-config-rangeinput';
      input.value = range.value;

      var me = this;
      range.onchange = function () {
        input.value = this.value;me._update(Number(this.value), path);
      };
      range.oninput = function () {
        input.value = this.value;
      };

      var label = this._makeLabel(path[path.length - 1], path);
      var itemIndex = this._makeItem(path, label, range, input);

      // if a popup is needed AND it has not been shown for this value, show it.
      if (popupString !== '' && this.popupHistory[itemIndex] !== popupValue) {
        this.popupHistory[itemIndex] = popupValue;
        this._setupPopup(popupString, itemIndex);
      }
    }

    /**
     * prepare the popup
     * @param string
     * @param index
     * @private
     */
  }, {
    key: '_setupPopup',
    value: function _setupPopup(string, index) {
      var _this3 = this;

      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {
        var div = document.createElement("div");
        div.id = "vis-configuration-popup";
        div.className = "vis-configuration-popup";
        div.innerHTML = string;
        div.onclick = function () {
          _this3._removePopup();
        };
        this.popupCounter += 1;
        this.popupDiv = { html: div, index: index };
      }
    }

    /**
     * remove the popup from the dom
     * @private
     */
  }, {
    key: '_removePopup',
    value: function _removePopup() {
      if (this.popupDiv.html !== undefined) {
        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);
        clearTimeout(this.popupDiv.hideTimeout);
        clearTimeout(this.popupDiv.deleteTimeout);
        this.popupDiv = {};
      }
    }

    /**
     * Show the popup if it is needed.
     * @private
     */
  }, {
    key: '_showPopupIfNeeded',
    value: function _showPopupIfNeeded() {
      var _this4 = this;

      if (this.popupDiv.html !== undefined) {
        var correspondingElement = this.domElements[this.popupDiv.index];
        var rect = correspondingElement.getBoundingClientRect();
        this.popupDiv.html.style.left = rect.left + "px";
        this.popupDiv.html.style.top = rect.top - 30 + "px"; // 30 is the height;
        document.body.appendChild(this.popupDiv.html);
        this.popupDiv.hideTimeout = setTimeout(function () {
          _this4.popupDiv.html.style.opacity = 0;
        }, 1500);
        this.popupDiv.deleteTimeout = setTimeout(function () {
          _this4._removePopup();
        }, 1800);
      }
    }

    /**
     * make a checkbox for boolean options.
     * @param defaultValue
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeCheckbox',
    value: function _makeCheckbox(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'vis-configuration vis-config-checkbox';
      checkbox.checked = defaultValue;
      if (value !== undefined) {
        checkbox.checked = value;
        if (value !== defaultValue) {
          if (typeof defaultValue === 'object') {
            if (value !== defaultValue.enabled) {
              this.changedOptions.push({ path: path, value: value });
            }
          } else {
            this.changedOptions.push({ path: path, value: value });
          }
        }
      }

      var me = this;
      checkbox.onchange = function () {
        me._update(this.checked, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, checkbox);
    }

    /**
     * make a text input field for string options.
     * @param defaultValue
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeTextInput',
    value: function _makeTextInput(defaultValue, value, path) {
      var checkbox = document.createElement('input');
      checkbox.type = 'text';
      checkbox.className = 'vis-configuration vis-config-text';
      checkbox.value = value;
      if (value !== defaultValue) {
        this.changedOptions.push({ path: path, value: value });
      }

      var me = this;
      checkbox.onchange = function () {
        me._update(this.value, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, checkbox);
    }

    /**
     * make a color field with a color picker for color fields
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_makeColorField',
    value: function _makeColorField(arr, value, path) {
      var _this5 = this;

      var defaultColor = arr[1];
      var div = document.createElement('div');
      value = value === undefined ? defaultColor : value;

      if (value !== 'none') {
        div.className = 'vis-configuration vis-config-colorBlock';
        div.style.backgroundColor = value;
      } else {
        div.className = 'vis-configuration vis-config-colorBlock none';
      }

      value = value === undefined ? defaultColor : value;
      div.onclick = function () {
        _this5._showColorPicker(value, div, path);
      };

      var label = this._makeLabel(path[path.length - 1], path);
      this._makeItem(path, label, div);
    }

    /**
     * used by the color buttons to call the color picker.
     * @param event
     * @param value
     * @param div
     * @param path
     * @private
     */
  }, {
    key: '_showColorPicker',
    value: function _showColorPicker(value, div, path) {
      var _this6 = this;

      var rect = div.getBoundingClientRect();
      var bodyRect = document.body.getBoundingClientRect();
      var pickerX = rect.left + rect.width + 5;
      var pickerY = rect.top - bodyRect.top + rect.height + 2;
      this.colorPicker.show(pickerX, pickerY);
      this.colorPicker.setColor(value);
      this.colorPicker.setCallback(function (color) {
        var colorString = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + color.a + ')';
        div.style.backgroundColor = colorString;
        _this6._update(colorString, path);
      });
    }

    /**
     * parse an object and draw the correct items
     * @param obj
     * @param path
     * @private
     */
  }, {
    key: '_handleObject',
    value: function _handleObject(obj) {
      var path = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
      var checkOnly = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var show = false;
      var filter = this.options.filter;
      var visibleInSet = false;
      for (var subObj in obj) {
        if (obj.hasOwnProperty(subObj)) {
          show = true;
          var item = obj[subObj];
          var newPath = util.copyAndExtendArray(path, subObj);
          if (typeof filter === 'function') {
            show = filter(subObj, path);

            // if needed we must go deeper into the object.
            if (show === false) {
              if (!(item instanceof Array) && typeof item !== 'string' && typeof item !== 'boolean' && item instanceof Object) {
                this.allowCreation = false;
                show = this._handleObject(item, newPath, true);
                this.allowCreation = checkOnly === false;
              }
            }
          }

          if (show !== false) {
            visibleInSet = true;
            var value = this._getValue(newPath);

            if (item instanceof Array) {
              this._handleArray(item, value, newPath);
            } else if (typeof item === 'string') {
              this._makeTextInput(item, value, newPath);
            } else if (typeof item === 'boolean') {
              this._makeCheckbox(item, value, newPath);
            } else if (item instanceof Object) {
              // collapse the physics options that are not enabled
              var draw = true;
              if (path.indexOf('physics') !== -1) {
                if (this.moduleOptions.physics.solver !== subObj) {
                  draw = false;
                }
              }

              if (draw === true) {
                // initially collapse options with an disabled enabled option.
                if (item.enabled !== undefined) {
                  var enabledPath = util.copyAndExtendArray(newPath, 'enabled');
                  var enabledValue = this._getValue(enabledPath);
                  if (enabledValue === true) {
                    var label = this._makeLabel(subObj, newPath, true);
                    this._makeItem(newPath, label);
                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                  } else {
                    this._makeCheckbox(item, enabledValue, newPath);
                  }
                } else {
                  var label = this._makeLabel(subObj, newPath, true);
                  this._makeItem(newPath, label);
                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;
                }
              }
            } else {
              console.error('dont know how to handle', item, subObj, newPath);
            }
          }
        }
      }
      return visibleInSet;
    }

    /**
     * handle the array type of option
     * @param optionName
     * @param arr
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_handleArray',
    value: function _handleArray(arr, value, path) {
      if (typeof arr[0] === 'string' && arr[0] === 'color') {
        this._makeColorField(arr, value, path);
        if (arr[1] !== value) {
          this.changedOptions.push({ path: path, value: value });
        }
      } else if (typeof arr[0] === 'string') {
        this._makeDropdown(arr, value, path);
        if (arr[0] !== value) {
          this.changedOptions.push({ path: path, value: value });
        }
      } else if (typeof arr[0] === 'number') {
        this._makeRange(arr, value, path);
        if (arr[0] !== value) {
          this.changedOptions.push({ path: path, value: Number(value) });
        }
      }
    }

    /**
     * called to update the network with the new settings.
     * @param value
     * @param path
     * @private
     */
  }, {
    key: '_update',
    value: function _update(value, path) {
      var options = this._constructOptions(value, path);

      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {
        this.parent.body.emitter.emit("configChange", options);
      }
      this.initialized = true;
      this.parent.setOptions(options);
    }
  }, {
    key: '_constructOptions',
    value: function _constructOptions(value, path) {
      var optionsObj = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var pointer = optionsObj;

      // when dropdown boxes can be string or boolean, we typecast it into correct types
      value = value === 'true' ? true : value;
      value = value === 'false' ? false : value;

      for (var i = 0; i < path.length; i++) {
        if (path[i] !== 'global') {
          if (pointer[path[i]] === undefined) {
            pointer[path[i]] = {};
          }
          if (i !== path.length - 1) {
            pointer = pointer[path[i]];
          } else {
            pointer[path[i]] = value;
          }
        }
      }
      return optionsObj;
    }
  }, {
    key: '_printOptions',
    value: function _printOptions() {
      var options = this.getOptions();
      this.optionsContainer.innerHTML = '<pre>var options = ' + JSON.stringify(options, null, 2) + '</pre>';
    }
  }, {
    key: 'getOptions',
    value: function getOptions() {
      var options = {};
      for (var i = 0; i < this.changedOptions.length; i++) {
        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);
      }
      return options;
    }
  }]);

  return Configurator;
})();

exports['default'] = Configurator;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9zaGFyZWQvQ29uZmlndXJhdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzsyQkFFd0IsZUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRnZDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzs7SUFrQnhCLFlBQVk7QUFDTCxXQURQLFlBQVksQ0FDSixZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQWtCO1FBQWhCLFVBQVUseURBQUcsQ0FBQzs7MEJBRHhFLFlBQVk7O0FBRWQsUUFBSSxDQUFDLE1BQU0sR0FBRyxZQUFZLENBQUM7QUFDM0IsUUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFDekIsUUFBSSxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQztBQUNsQyxRQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQzs7QUFFM0IsUUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7QUFDbEIsUUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7QUFDekIsUUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7QUFDdEIsUUFBSSxDQUFDLGNBQWMsR0FBRztBQUNwQixhQUFPLEVBQUUsS0FBSztBQUNkLFlBQU0sRUFBRSxJQUFJO0FBQ1osZUFBUyxFQUFFLFNBQVM7QUFDcEIsZ0JBQVUsRUFBRSxJQUFJO0tBQ2pCLENBQUM7QUFDRixRQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDOztBQUUvQyxRQUFJLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7QUFDekMsUUFBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUM7QUFDeEIsUUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7QUFDdEIsUUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7QUFDbkIsUUFB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bGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvc2hhcmVkL0NvbmZpZ3VyYXRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5pbXBvcnQgQ29sb3JQaWNrZXIgZnJvbSAnLi9Db2xvclBpY2tlcidcblxuLyoqXG4gKiBUaGUgd2F5IHRoaXMgd29ya3MgaXMgZm9yIGFsbCBwcm9wZXJ0aWVzIG9mIHRoaXMucG9zc2libGUgb3B0aW9ucywgeW91IGNhbiBzdXBwbHkgdGhlIHByb3BlcnR5IG5hbWUgaW4gYW55IGZvcm0gdG8gbGlzdCB0aGUgb3B0aW9ucy5cbiAqIEJvb2xlYW4gb3B0aW9ucyBhcmUgcmVjb2duaXNlZCBhcyBCb29sZWFuXG4gKiBOdW1iZXIgb3B0aW9ucyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW2RlZmF1bHQgdmFsdWUsIG1pbiB2YWx1ZSwgbWF4IHZhbHVlLCBzdGVwc2l6ZV1cbiAqIENvbG9ycyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogWydjb2xvcicsICcjZmZmZmZmJ11cbiAqIFN0cmluZ3Mgd2l0aCBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW29wdGlvbjEsIG9wdGlvbjIsIG9wdGlvbjMsIC4uXVxuICpcbiAqIFRoZSBvcHRpb25zIGFyZSBtYXRjaGVkIHdpdGggdGhlaXIgY291bnRlcnBhcnRzIGluIGVhY2ggb2YgdGhlIG1vZHVsZXMgYW5kIHRoZSB2YWx1ZXMgdXNlZCBpbiB0aGUgY29uZmlndXJhdGlvbiBhcmVcbiAqXG4gKiBAcGFyYW0gcGFyZW50TW9kdWxlICAgICAgICB8IHRoZSBsb2NhdGlvbiB3aGVyZSBwYXJlbnRNb2R1bGUuc2V0T3B0aW9ucygpIGNhbiBiZSBjYWxsZWRcbiAqIEBwYXJhbSBkZWZhdWx0Q29udGFpbmVyICAgIHwgdGhlIGRlZmF1bHQgY29udGFpbmVyIG9mIHRoZSBtb2R1bGVcbiAqIEBwYXJhbSBjb25maWd1cmVPcHRpb25zICAgIHwgdGhlIGZ1bGx5IGNvbmZpZ3VyZWQgYW5kIHByZWRlZmluZWQgb3B0aW9ucyBzZXQgZm91bmQgaW4gYWxsT3B0aW9ucy5qc1xuICogQHBhcmFtIHBpeGVsUmF0aW8gICAgICAgICAgfCBjYW52YXMgcGl4ZWwgcmF0aW9cbiAqL1xuY2xhc3MgQ29uZmlndXJhdG9yIHtcbiAgY29uc3RydWN0b3IocGFyZW50TW9kdWxlLCBkZWZhdWx0Q29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zLCBwaXhlbFJhdGlvID0gMSkge1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50TW9kdWxlO1xuICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXI7XG4gICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gZmFsc2U7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5wb3B1cENvdW50ZXIgPSAwO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGZpbHRlcjogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lcjogdW5kZWZpbmVkLFxuICAgICAgc2hvd0J1dHRvbjogdHJ1ZVxuICAgIH07XG4gICAgdXRpbC5leHRlbmQodGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgIHRoaXMuY29uZmlndXJlT3B0aW9ucyA9IGNvbmZpZ3VyZU9wdGlvbnM7XG4gICAgdGhpcy5tb2R1bGVPcHRpb25zID0ge307XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICB0aGlzLnBvcHVwTGltaXQgPSA1O1xuICAgIHRoaXMucG9wdXBIaXN0b3J5ID0ge307XG4gICAgdGhpcy5jb2xvclBpY2tlciA9IG5ldyBDb2xvclBpY2tlcihwaXhlbFJhdGlvKTtcbiAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiByZWZyZXNoIGFsbCBvcHRpb25zLlxuICAgKiBCZWNhdXNlIGFsbCBtb2R1bGVzIHBhcnNlIHRoZWlyIG9wdGlvbnMgYnkgdGhlbXNlbHZlcywgd2UganVzdCB1c2UgdGhlaXIgb3B0aW9ucy4gV2UgY29weSB0aGVtIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXNldCB0aGUgcG9wdXAgaGlzdG9yeSBiZWNhdXNlIHRoZSBpbmRpY2VzIG1heSBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICAgIHRoaXMucG9wdXBIaXN0b3J5ID0ge307XG4gICAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuXG4gICAgICBsZXQgZW5hYmxlZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmpvaW4oKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAob3B0aW9ucy5jb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zaG93QnV0dG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9IG9wdGlvbnMuc2hvd0J1dHRvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlbmFibGVkID0gb3B0aW9ucy5lbmFibGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSB0cnVlO1xuICAgICAgICBlbmFibGVkID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zO1xuICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsdGVyID09PSBmYWxzZSkge1xuICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICB9XG4gICAgdGhpcy5fY2xlYW4oKTtcbiAgfVxuXG5cbiAgc2V0TW9kdWxlT3B0aW9ucyhtb2R1bGVPcHRpb25zKSB7XG4gICAgdGhpcy5tb2R1bGVPcHRpb25zID0gbW9kdWxlT3B0aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYWxsIERPTSBlbGVtZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZSgpIHtcbiAgICB0aGlzLl9jbGVhbigpO1xuICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMgPSBbXTtcblxuICAgIGxldCBmaWx0ZXIgPSB0aGlzLm9wdGlvbnMuZmlsdGVyO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBsZXQgc2hvdyA9IGZhbHNlO1xuICAgIGZvciAobGV0IG9wdGlvbiBpbiB0aGlzLmNvbmZpZ3VyZU9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZ3VyZU9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcbiAgICAgICAgc2hvdyA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHNob3cgPSBmaWx0ZXIob3B0aW9uLFtdKTtcbiAgICAgICAgICBzaG93ID0gc2hvdyB8fCB0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW29wdGlvbl0sIFtvcHRpb25dLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWx0ZXIgPT09IHRydWUgfHwgZmlsdGVyLmluZGV4T2Yob3B0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICBzaG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAvLyBsaW5lYnJlYWsgYmV0d2VlbiBjYXRlZ29yaWVzXG4gICAgICAgICAgaWYgKGNvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShbXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGEgaGVhZGVyIGZvciB0aGUgY2F0ZWdvcnlcbiAgICAgICAgICB0aGlzLl9tYWtlSGVhZGVyKG9wdGlvbik7XG5cbiAgICAgICAgICAvLyBnZXQgdGhlIHN1Ym9wdGlvbnNcbiAgICAgICAgICB0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW29wdGlvbl0sIFtvcHRpb25dKTtcbiAgICAgICAgfVxuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93QnV0dG9uID09PSB0cnVlKSB7XG4gICAgICBsZXQgZ2VuZXJhdGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWJ1dHRvbic7XG4gICAgICBnZW5lcmF0ZUJ1dHRvbi5pbm5lckhUTUwgPSAnZ2VuZXJhdGUgb3B0aW9ucyc7XG4gICAgICBnZW5lcmF0ZUJ1dHRvbi5vbmNsaWNrID0gICAgICgpID0+IHt0aGlzLl9wcmludE9wdGlvbnMoKTt9O1xuICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW92ZXIgPSAoKSA9PiB7Z2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uIGhvdmVyJzt9O1xuICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW91dCA9ICAoKSA9PiB7Z2VuZXJhdGVCdXR0b24uY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uJzt9O1xuXG4gICAgICB0aGlzLm9wdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lci5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1vcHRpb24tY29udGFpbmVyJztcblxuICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKHRoaXMub3B0aW9uc0NvbnRhaW5lcik7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLnB1c2goZ2VuZXJhdGVCdXR0b24pO1xuICAgIH1cblxuICAgIHRoaXMuX3B1c2goKTtcbiAgICB0aGlzLmNvbG9yUGlja2VyLmluc2VydFRvKHRoaXMuY29udGFpbmVyKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGRyYXcgYWxsIERPTSBlbGVtZW50cyBvbiB0aGUgc2NyZWVuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHVzaCgpIHtcbiAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLndyYXBwZXIuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uLXdyYXBwZXInO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlcik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2hvd1BvcHVwSWZOZWVkZWQoKVxuICB9XG5cblxuICAvKipcbiAgICogZGVsZXRlIGFsbCBET00gZWxlbWVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbGVhbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZG9tRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud3JhcHBlci5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy53cmFwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlcik7XG4gICAgICB0aGlzLndyYXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuZG9tRWxlbWVudHMgPSBbXTtcblxuICAgIHRoaXMuX3JlbW92ZVBvcHVwKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIGFjdHVhbE9wdGlvbnMgaWYgaXQgZXhpc3RzXG4gICAqIEBwYXJhbSB7YXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRWYWx1ZShwYXRoKSB7XG4gICAgbGV0IGJhc2UgPSB0aGlzLm1vZHVsZU9wdGlvbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYmFzZVtwYXRoW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJhc2UgPSBiYXNlW3BhdGhbaV1dO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJhc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIGFsbCBvcHRpb24gZWxlbWVudHMgYXJlIHdyYXBwZWQgaW4gYW4gaXRlbVxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gZG9tRWxlbWVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlSXRlbShwYXRoLCAuLi5kb21FbGVtZW50cykge1xuICAgIGlmICh0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUpIHtcbiAgICAgIGxldCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBpdGVtLmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWl0ZW0gdmlzLWNvbmZpZy1zJyArIHBhdGgubGVuZ3RoO1xuICAgICAgZG9tRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICBpdGVtLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLnB1c2goaXRlbSk7XG4gICAgICByZXR1cm4gdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cblxuICAvKipcbiAgICogaGVhZGVyIGZvciBtYWpvciBzdWJqZWN0c1xuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VIZWFkZXIobmFtZSkge1xuICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaGVhZGVyJztcbiAgICBkaXYuaW5uZXJIVE1MID0gbmFtZTtcbiAgICB0aGlzLl9tYWtlSXRlbShbXSxkaXYpO1xuICB9XG5cblxuICAvKipcbiAgICogbWFrZSBhIGxhYmVsLCBpZiBpdCBpcyBhbiBvYmplY3QgbGFiZWwsIGl0IGdldHMgZGlmZmVyZW50IHN0eWxpbmcuXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSBvYmplY3RMYWJlbFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFrZUxhYmVsKG5hbWUsIHBhdGgsIG9iamVjdExhYmVsID0gZmFsc2UpIHtcbiAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWxhYmVsIHZpcy1jb25maWctcycgKyBwYXRoLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0TGFiZWwgPT09IHRydWUpIHtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPGk+PGI+JyArIG5hbWUgKyAnOjwvYj48L2k+JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gbmFtZSArICc6JztcbiAgICB9XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIG1ha2UgYSBkcm9wZG93biBsaXN0IGZvciBtdWx0aXBsZSBwb3NzaWJsZSBzdHJpbmcgb3B0b2luc1xuICAgKiBAcGFyYW0gYXJyXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VEcm9wZG93bihhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgbGV0IHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgIHNlbGVjdC5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1zZWxlY3QnO1xuICAgIGxldCBzZWxlY3RlZFZhbHVlID0gMDtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGFyci5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZSA9IGFyci5pbmRleE9mKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgb3B0aW9uLnZhbHVlID0gYXJyW2ldO1xuICAgICAgaWYgKGkgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gJ3NlbGVjdGVkJztcbiAgICAgIH1cbiAgICAgIG9wdGlvbi5pbm5lckhUTUwgPSBhcnJbaV07XG4gICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICB9XG5cbiAgICBsZXQgbWUgPSB0aGlzO1xuICAgIHNlbGVjdC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHttZS5fdXBkYXRlKHRoaXMudmFsdWUsIHBhdGgpO307XG5cbiAgICBsZXQgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aC0xXSwgcGF0aCk7XG4gICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHNlbGVjdCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBtYWtlIGEgcmFuZ2Ugb2JqZWN0IGZvciBudW1lcmljIG9wdGlvbnNcbiAgICogQHBhcmFtIGFyclxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlUmFuZ2UoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgIGxldCBkZWZhdWx0VmFsdWUgPSBhcnJbMF07XG4gICAgbGV0IG1pbiA9IGFyclsxXTtcbiAgICBsZXQgbWF4ID0gYXJyWzJdO1xuICAgIGxldCBzdGVwID0gYXJyWzNdO1xuICAgIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgcmFuZ2UuY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2UnO1xuICAgIHRyeSB7XG4gICAgICByYW5nZS50eXBlID0gJ3JhbmdlJzsgLy8gbm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgIHJhbmdlLm1pbiA9IG1pbjtcbiAgICAgIHJhbmdlLm1heCA9IG1heDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge31cbiAgICByYW5nZS5zdGVwID0gc3RlcDtcblxuICAgIC8vIHNldCB1cCB0aGUgcG9wdXAgc2V0dGluZ3MgaW4gY2FzZSB0aGV5IGFyZSBuZWVkZWQuXG4gICAgbGV0IHBvcHVwU3RyaW5nID0gJyc7XG4gICAgbGV0IHBvcHVwVmFsdWUgPSAwO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBmYWN0b3IgPSAxLjIwO1xuICAgICAgaWYgKHZhbHVlIDwgMCAmJiB2YWx1ZSAqIGZhY3RvciA8IG1pbikge1xuICAgICAgICByYW5nZS5taW4gPSBNYXRoLmNlaWwodmFsdWUgKiBmYWN0b3IpO1xuICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgICBwb3B1cFN0cmluZyA9ICdyYW5nZSBpbmNyZWFzZWQnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodmFsdWUgLyBmYWN0b3IgPCBtaW4pIHtcbiAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlIC8gZmFjdG9yKTtcbiAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1pbjtcbiAgICAgICAgcG9wdXBTdHJpbmcgPSAncmFuZ2UgaW5jcmVhc2VkJztcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAqIGZhY3RvciA+IG1heCAmJiBtYXggIT09IDEpIHtcbiAgICAgICAgcmFuZ2UubWF4ID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgcG9wdXBWYWx1ZSA9IHJhbmdlLm1heDtcbiAgICAgICAgcG9wdXBTdHJpbmcgPSAncmFuZ2UgaW5jcmVhc2VkJztcbiAgICAgIH1cbiAgICAgIHJhbmdlLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmFuZ2UudmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1yYW5nZWlucHV0JztcbiAgICBpbnB1dC52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICByYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtpbnB1dC52YWx1ZSA9IHRoaXMudmFsdWU7IG1lLl91cGRhdGUoTnVtYmVyKHRoaXMudmFsdWUpLCBwYXRoKTt9O1xuICAgIHJhbmdlLm9uaW5wdXQgID0gZnVuY3Rpb24gKCkge2lucHV0LnZhbHVlID0gdGhpcy52YWx1ZTsgfTtcblxuICAgIGxldCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoLTFdLCBwYXRoKTtcbiAgICBsZXQgaXRlbUluZGV4ID0gdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIHJhbmdlLCBpbnB1dCk7XG5cbiAgICAvLyBpZiBhIHBvcHVwIGlzIG5lZWRlZCBBTkQgaXQgaGFzIG5vdCBiZWVuIHNob3duIGZvciB0aGlzIHZhbHVlLCBzaG93IGl0LlxuICAgIGlmIChwb3B1cFN0cmluZyAhPT0gJycgJiYgdGhpcy5wb3B1cEhpc3RvcnlbaXRlbUluZGV4XSAhPT0gcG9wdXBWYWx1ZSkge1xuICAgICAgdGhpcy5wb3B1cEhpc3RvcnlbaXRlbUluZGV4XSA9IHBvcHVwVmFsdWU7XG4gICAgICB0aGlzLl9zZXR1cFBvcHVwKHBvcHVwU3RyaW5nLCBpdGVtSW5kZXgpO1xuICAgIH1cblxuICB9XG5cblxuICAvKipcbiAgICogcHJlcGFyZSB0aGUgcG9wdXBcbiAgICogQHBhcmFtIHN0cmluZ1xuICAgKiBAcGFyYW0gaW5kZXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cFBvcHVwKHN0cmluZywgaW5kZXgpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gdHJ1ZSAmJiB0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUgJiYgdGhpcy5wb3B1cENvdW50ZXIgPCB0aGlzLnBvcHVwTGltaXQpIHtcbiAgICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmlkID0gXCJ2aXMtY29uZmlndXJhdGlvbi1wb3B1cFwiO1xuICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSBzdHJpbmc7XG4gICAgICBkaXYub25jbGljayA9ICgpID0+IHt0aGlzLl9yZW1vdmVQb3B1cCgpfTtcbiAgICAgIHRoaXMucG9wdXBDb3VudGVyICs9IDE7XG4gICAgICB0aGlzLnBvcHVwRGl2ID0ge2h0bWw6ZGl2LCBpbmRleDppbmRleH07XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogcmVtb3ZlIHRoZSBwb3B1cCBmcm9tIHRoZSBkb21cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW1vdmVQb3B1cCgpIHtcbiAgICBpZiAodGhpcy5wb3B1cERpdi5odG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBEaXYuaHRtbCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5wb3B1cERpdi5kZWxldGVUaW1lb3V0KTtcbiAgICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBwb3B1cCBpZiBpdCBpcyBuZWVkZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2hvd1BvcHVwSWZOZWVkZWQoKSB7XG4gICAgaWYgKHRoaXMucG9wdXBEaXYuaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgY29ycmVzcG9uZGluZ0VsZW1lbnQgPSB0aGlzLmRvbUVsZW1lbnRzW3RoaXMucG9wdXBEaXYuaW5kZXhdO1xuICAgICAgbGV0IHJlY3QgPSBjb3JyZXNwb25kaW5nRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLnRvcCA9IHJlY3QudG9wIC0gMzAgKyBcInB4XCI7IC8vIDMwIGlzIHRoZSBoZWlnaHQ7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucG9wdXBEaXYuaHRtbClcbiAgICAgIHRoaXMucG9wdXBEaXYuaGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgfSwxNTAwKTtcbiAgICAgIHRoaXMucG9wdXBEaXYuZGVsZXRlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZW1vdmVQb3B1cCgpO1xuICAgICAgfSwxODAwKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBtYWtlIGEgY2hlY2tib3ggZm9yIGJvb2xlYW4gb3B0aW9ucy5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlQ2hlY2tib3goZGVmYXVsdFZhbHVlLCB2YWx1ZSwgcGF0aCkge1xuICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgY2hlY2tib3gudHlwZSA9ICdjaGVja2JveCc7XG4gICAgY2hlY2tib3guY2xhc3NOYW1lID0gJ3Zpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY2hlY2tib3gnO1xuICAgIGNoZWNrYm94LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB2YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7cGF0aDpwYXRoLCB2YWx1ZTp2YWx1ZX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6cGF0aCwgdmFsdWU6dmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBtZSA9IHRoaXM7XG4gICAgY2hlY2tib3gub25jaGFuZ2UgPSBmdW5jdGlvbigpIHttZS5fdXBkYXRlKHRoaXMuY2hlY2tlZCwgcGF0aCl9O1xuXG4gICAgbGV0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGgtMV0sIHBhdGgpO1xuICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBjaGVja2JveCk7XG4gIH1cblxuICAvKipcbiAgICogbWFrZSBhIHRleHQgaW5wdXQgZmllbGQgZm9yIHN0cmluZyBvcHRpb25zLlxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VUZXh0SW5wdXQoZGVmYXVsdFZhbHVlLCB2YWx1ZSwgcGF0aCkge1xuICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgY2hlY2tib3gudHlwZSA9ICd0ZXh0JztcbiAgICBjaGVja2JveC5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy10ZXh0JztcbiAgICBjaGVja2JveC52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6cGF0aCwgdmFsdWU6dmFsdWV9KTtcbiAgICB9XG5cbiAgICBsZXQgbWUgPSB0aGlzO1xuICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gZnVuY3Rpb24oKSB7bWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKX07XG5cbiAgICBsZXQgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aC0xXSwgcGF0aCk7XG4gICAgdGhpcy5fbWFrZUl0ZW0ocGF0aCwgbGFiZWwsIGNoZWNrYm94KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIG1ha2UgYSBjb2xvciBmaWVsZCB3aXRoIGEgY29sb3IgcGlja2VyIGZvciBjb2xvciBmaWVsZHNcbiAgICogQHBhcmFtIGFyclxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYWtlQ29sb3JGaWVsZChhcnIsIHZhbHVlLCBwYXRoKSB7XG4gICAgbGV0IGRlZmF1bHRDb2xvciA9IGFyclsxXTtcbiAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbG9yIDogdmFsdWU7XG5cbiAgICBpZiAodmFsdWUgIT09ICdub25lJykge1xuICAgICAgZGl2LmNsYXNzTmFtZSA9ICd2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2snO1xuICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRpdi5jbGFzc05hbWUgPSAndmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1jb2xvckJsb2NrIG5vbmUnO1xuICAgIH1cblxuICAgIHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvciA6IHZhbHVlO1xuICAgIGRpdi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc2hvd0NvbG9yUGlja2VyKHZhbHVlLGRpdixwYXRoKTtcbiAgICB9O1xuXG4gICAgbGV0IGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGgtMV0sIHBhdGgpO1xuICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsbGFiZWwsIGRpdik7XG4gIH1cblxuXG4gIC8qKlxuICAgKiB1c2VkIGJ5IHRoZSBjb2xvciBidXR0b25zIHRvIGNhbGwgdGhlIGNvbG9yIHBpY2tlci5cbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcGFyYW0gZGl2XG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpIHtcbiAgICBsZXQgcmVjdCA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgYm9keVJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBwaWNrZXJYID0gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCArIDU7XG4gICAgbGV0IHBpY2tlclkgPSByZWN0LnRvcCAtIGJvZHlSZWN0LnRvcCArIHJlY3QuaGVpZ2h0ICsyO1xuICAgIHRoaXMuY29sb3JQaWNrZXIuc2hvdyhwaWNrZXJYLHBpY2tlclkpO1xuICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0Q29sb3IodmFsdWUpO1xuICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0Q2FsbGJhY2soKGNvbG9yKSA9PiB7XG4gICAgICBsZXQgY29sb3JTdHJpbmcgPSAncmdiYSgnICsgY29sb3IuciArICcsJyArIGNvbG9yLmcgKyAnLCcgKyBjb2xvci5iICsgJywnICsgY29sb3IuYSArICcpJztcbiAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvclN0cmluZztcbiAgICAgIHRoaXMuX3VwZGF0ZShjb2xvclN0cmluZyxwYXRoKTtcbiAgICB9KVxuICB9XG5cblxuICAvKipcbiAgICogcGFyc2UgYW4gb2JqZWN0IGFuZCBkcmF3IHRoZSBjb3JyZWN0IGl0ZW1zXG4gICAqIEBwYXJhbSBvYmpcbiAgICogQHBhcmFtIHBhdGhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVPYmplY3Qob2JqLCBwYXRoID0gW10sIGNoZWNrT25seSA9IGZhbHNlKSB7XG4gICAgbGV0IHNob3cgPSBmYWxzZTtcbiAgICBsZXQgZmlsdGVyID0gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICBsZXQgdmlzaWJsZUluU2V0ID0gZmFsc2U7XG4gICAgZm9yIChsZXQgc3ViT2JqIGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShzdWJPYmopKSB7XG4gICAgICAgIHNob3cgPSB0cnVlO1xuICAgICAgICBsZXQgaXRlbSA9IG9ialtzdWJPYmpdO1xuICAgICAgICBsZXQgbmV3UGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIHN1Yk9iaik7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2hvdyA9IGZpbHRlcihzdWJPYmoscGF0aCk7XG5cbiAgICAgICAgICAvLyBpZiBuZWVkZWQgd2UgbXVzdCBnbyBkZWVwZXIgaW50byB0aGUgb2JqZWN0LlxuICAgICAgICAgIGlmIChzaG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSAmJiB0eXBlb2YgaXRlbSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGl0ZW0gIT09ICdib29sZWFuJyAmJiBpdGVtIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICBzaG93ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBjaGVja09ubHkgPT09IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHZpc2libGVJblNldCA9IHRydWU7XG4gICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5fZ2V0VmFsdWUobmV3UGF0aCk7XG5cbiAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVBcnJheShpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fbWFrZVRleHRJbnB1dChpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgIC8vIGNvbGxhcHNlIHRoZSBwaHlzaWNzIG9wdGlvbnMgdGhhdCBhcmUgbm90IGVuYWJsZWRcbiAgICAgICAgICAgIGxldCBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2YoJ3BoeXNpY3MnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubW9kdWxlT3B0aW9ucy5waHlzaWNzLnNvbHZlciAhPT0gc3ViT2JqKSB7XG4gICAgICAgICAgICAgICAgZHJhdyA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkcmF3ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIC8vIGluaXRpYWxseSBjb2xsYXBzZSBvcHRpb25zIHdpdGggYW4gZGlzYWJsZWQgZW5hYmxlZCBvcHRpb24uXG4gICAgICAgICAgICAgIGlmIChpdGVtLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmFibGVkUGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KG5ld1BhdGgsICdlbmFibGVkJyk7XG4gICAgICAgICAgICAgICAgbGV0IGVuYWJsZWRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlKGVuYWJsZWRQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZFZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwoc3ViT2JqLCBuZXdQYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKG5ld1BhdGgsIGxhYmVsKTtcbiAgICAgICAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRoaXMuX2hhbmRsZU9iamVjdChpdGVtLCBuZXdQYXRoKSB8fCB2aXNpYmxlSW5TZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZUNoZWNrYm94KGl0ZW0sIGVuYWJsZWRWYWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChzdWJPYmosIG5ld1BhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKG5ld1BhdGgsIGxhYmVsKTtcbiAgICAgICAgICAgICAgICB2aXNpYmxlSW5TZXQgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCkgfHwgdmlzaWJsZUluU2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignZG9udCBrbm93IGhvdyB0byBoYW5kbGUnLCBpdGVtLCBzdWJPYmosIG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmlzaWJsZUluU2V0O1xuICB9XG5cblxuICAvKipcbiAgICogaGFuZGxlIHRoZSBhcnJheSB0eXBlIG9mIG9wdGlvblxuICAgKiBAcGFyYW0gb3B0aW9uTmFtZVxuICAgKiBAcGFyYW0gYXJyXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZUFycmF5KGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIGFyclswXSA9PT0gJ3N0cmluZycgJiYgYXJyWzBdID09PSAnY29sb3InKSB7XG4gICAgICB0aGlzLl9tYWtlQ29sb3JGaWVsZChhcnIsIHZhbHVlLCBwYXRoKTtcbiAgICAgIGlmIChhcnJbMV0gIT09IHZhbHVlKSB7dGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtwYXRoOnBhdGgsIHZhbHVlOnZhbHVlfSk7fVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fbWFrZURyb3Bkb3duKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHt0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe3BhdGg6cGF0aCwgdmFsdWU6dmFsdWV9KTt9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhcnJbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLl9tYWtlUmFuZ2UoYXJyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICBpZiAoYXJyWzBdICE9PSB2YWx1ZSkge3RoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7cGF0aDpwYXRoLCB2YWx1ZTpOdW1iZXIodmFsdWUpfSk7fVxuICAgIH1cbiAgfVxuXG5cblxuICAvKipcbiAgICogY2FsbGVkIHRvIHVwZGF0ZSB0aGUgbmV0d29yayB3aXRoIHRoZSBuZXcgc2V0dGluZ3MuXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZSh2YWx1ZSwgcGF0aCkge1xuICAgIGxldCBvcHRpb25zID0gdGhpcy5fY29uc3RydWN0T3B0aW9ucyh2YWx1ZSxwYXRoKTtcblxuICAgIGlmICh0aGlzLnBhcmVudC5ib2R5ICYmIHRoaXMucGFyZW50LmJvZHkuZW1pdHRlciAmJiB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIuZW1pdCkge1xuICAgICAgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQoXCJjb25maWdDaGFuZ2VcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMucGFyZW50LnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBfY29uc3RydWN0T3B0aW9ucyh2YWx1ZSwgcGF0aCwgb3B0aW9uc09iaiA9IHt9KSB7XG4gICAgbGV0IHBvaW50ZXIgPSBvcHRpb25zT2JqO1xuXG4gICAgLy8gd2hlbiBkcm9wZG93biBib3hlcyBjYW4gYmUgc3RyaW5nIG9yIGJvb2xlYW4sIHdlIHR5cGVjYXN0IGl0IGludG8gY29ycmVjdCB0eXBlc1xuICAgIHZhbHVlID0gdmFsdWUgPT09ICd0cnVlJyAgPyB0cnVlICA6IHZhbHVlO1xuICAgIHZhbHVlID0gdmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHZhbHVlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGF0aFtpXSAhPT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgaWYgKHBvaW50ZXJbcGF0aFtpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvaW50ZXJbcGF0aFtpXV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSAhPT0gcGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXJbcGF0aFtpXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcG9pbnRlcltwYXRoW2ldXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zT2JqO1xuXG4gIH1cblxuICBfcHJpbnRPcHRpb25zKCkge1xuICAgIGxldCBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgdGhpcy5vcHRpb25zQ29udGFpbmVyLmlubmVySFRNTCA9ICc8cHJlPnZhciBvcHRpb25zID0gJyArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG51bGwsIDIpICsgJzwvcHJlPic7XG4gIH1cblxuICBnZXRPcHRpb25zKCkge1xuICAgIGxldCBvcHRpb25zID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5nZWRPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jb25zdHJ1Y3RPcHRpb25zKHRoaXMuY2hhbmdlZE9wdGlvbnNbaV0udmFsdWUsIHRoaXMuY2hhbmdlZE9wdGlvbnNbaV0ucGF0aCwgb3B0aW9ucylcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDb25maWd1cmF0b3I7Il19
},{"../util":46,"./ColorPicker":23}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var util = require('../util');

var errorFound = false;
var allOptions = undefined;
var printStyle = 'background: #FFeeee; color: #dd0000';
/**
 *  Used to validate options.
 */

var Validator = (function () {
  function Validator() {
    _classCallCheck(this, Validator);
  }

  /**
   * Main function to be called
   * @param options
   * @param subObject
   * @returns {boolean}
   */

  _createClass(Validator, null, [{
    key: 'validate',
    value: function validate(options, referenceOptions, subObject) {
      errorFound = false;
      allOptions = referenceOptions;
      var usedOptions = referenceOptions;
      if (subObject !== undefined) {
        usedOptions = referenceOptions[subObject];
      }
      Validator.parse(options, usedOptions, []);
      return errorFound;
    }

    /**
     * Will traverse an object recursively and check every value
     * @param options
     * @param referenceOptions
     * @param path
     */
  }, {
    key: 'parse',
    value: function parse(options, referenceOptions, path) {
      for (var option in options) {
        if (options.hasOwnProperty(option)) {
          Validator.check(option, options, referenceOptions, path);
        }
      }
    }

    /**
     * Check every value. If the value is an object, call the parse function on that object.
     * @param option
     * @param options
     * @param referenceOptions
     * @param path
     */
  }, {
    key: 'check',
    value: function check(option, options, referenceOptions, path) {
      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {
        Validator.getSuggestion(option, referenceOptions, path);
      } else if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {
        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
        if (Validator.getType(options[option]) === 'object' && referenceOptions['__any__'].__type__ !== undefined) {
          // if the any subgroup is not a predefined object int he configurator we do not look deeper into the object.
          Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'].__type__, path);
        } else {
          Validator.checkFields(option, options, referenceOptions, '__any__', referenceOptions['__any__'], path);
        }
      } else {
        // Since all options in the reference are objects, we can check whether they are supposed to be object to look for the __type__ field.
        if (referenceOptions[option].__type__ !== undefined) {
          // if this should be an object, we check if the correct type has been supplied to account for shorthand options.
          Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option].__type__, path);
        } else {
          Validator.checkFields(option, options, referenceOptions, option, referenceOptions[option], path);
        }
      }
    }

    /**
     *
     * @param {String}  option     | the option property
     * @param {Object}  options    | The supplied options object
     * @param {Object}  referenceOptions    | The reference options containing all options and their allowed formats
     * @param {String}  referenceOption     | Usually this is the same as option, except when handling an __any__ tag.
     * @param {String}  refOptionType       | This is the type object from the reference options
     * @param {Array}   path      | where in the object is the option
     */
  }, {
    key: 'checkFields',
    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {
      var optionType = Validator.getType(options[option]);
      var refOptionType = refOptionObj[optionType];
      if (refOptionType !== undefined) {
        // if the type is correct, we check if it is supposed to be one of a few select values
        if (Validator.getType(refOptionType) === 'array') {
          if (refOptionType.indexOf(options[option]) === -1) {
            console.log('%cInvalid option detected in "' + option + '".' + ' Allowed values are:' + Validator.print(refOptionType) + ' not "' + options[option] + '". ' + Validator.printLocation(path, option), printStyle);
            errorFound = true;
          } else if (optionType === 'object' && referenceOption !== "__any__") {
            path = util.copyAndExtendArray(path, option);
            Validator.parse(options[option], referenceOptions[referenceOption], path);
          }
        } else if (optionType === 'object' && referenceOption !== "__any__") {
          path = util.copyAndExtendArray(path, option);
          Validator.parse(options[option], referenceOptions[referenceOption], path);
        }
      } else if (refOptionObj['any'] === undefined) {
        // type of the field is incorrect and the field cannot be any
        console.log('%cInvalid type received for "' + option + '". Expected: ' + Validator.print(Object.keys(refOptionObj)) + '. Received [' + optionType + '] "' + options[option] + '"' + Validator.printLocation(path, option), printStyle);
        errorFound = true;
      }
    }
  }, {
    key: 'getType',
    value: function getType(object) {
      var type = typeof object;

      if (type === 'object') {
        if (object === null) {
          return 'null';
        }
        if (object instanceof Boolean) {
          return 'boolean';
        }
        if (object instanceof Number) {
          return 'number';
        }
        if (object instanceof String) {
          return 'string';
        }
        if (Array.isArray(object)) {
          return 'array';
        }
        if (object instanceof Date) {
          return 'date';
        }
        if (object.nodeType !== undefined) {
          return 'dom';
        }
        if (object._isAMomentObject === true) {
          return 'moment';
        }
        return 'object';
      } else if (type === 'number') {
        return 'number';
      } else if (type === 'boolean') {
        return 'boolean';
      } else if (type === 'string') {
        return 'string';
      } else if (type === undefined) {
        return 'undefined';
      }
      return type;
    }
  }, {
    key: 'getSuggestion',
    value: function getSuggestion(option, options, path) {
      var localSearch = Validator.findInOptions(option, options, path, false);
      var globalSearch = Validator.findInOptions(option, allOptions, [], true);

      var localSearchThreshold = 8;
      var globalSearchThreshold = 4;

      if (localSearch.indexMatch !== undefined) {
        console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was incomplete? Did you mean: "' + localSearch.indexMatch + '"?\n\n', printStyle);
      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {
        console.log('%cUnknown option detected: "' + option + '" in ' + Validator.printLocation(localSearch.path, option, '') + 'Perhaps it was misplaced? Matching option found at: ' + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, ''), printStyle);
      } else if (localSearch.distance <= localSearchThreshold) {
        console.log('%cUnknown option detected: "' + option + '". Did you mean "' + localSearch.closestMatch + '"?' + Validator.printLocation(localSearch.path, option), printStyle);
      } else {
        console.log('%cUnknown option detected: "' + option + '". Did you mean one of these: ' + Validator.print(Object.keys(options)) + Validator.printLocation(path, option), printStyle);
      }

      errorFound = true;
    }

    /**
     * traverse the options in search for a match.
     * @param option
     * @param options
     * @param path
     * @param recursive
     * @returns {{closestMatch: string, path: Array, distance: number}}
     */
  }, {
    key: 'findInOptions',
    value: function findInOptions(option, options, path) {
      var recursive = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

      var min = 1e9;
      var closestMatch = '';
      var closestMatchPath = [];
      var lowerCaseOption = option.toLowerCase();
      var indexMatch = undefined;
      for (var op in options) {
        var distance = undefined;
        if (options[op].__type__ !== undefined && recursive === true) {
          var result = Validator.findInOptions(option, options[op], util.copyAndExtendArray(path, op));
          if (min > result.distance) {
            closestMatch = result.closestMatch;
            closestMatchPath = result.path;
            min = result.distance;
            indexMatch = result.indexMatch;
          }
        } else {
          if (op.toLowerCase().indexOf(lowerCaseOption) !== -1) {
            indexMatch = op;
          }
          distance = Validator.levenshteinDistance(option, op);
          if (min > distance) {
            closestMatch = op;
            closestMatchPath = util.copyArray(path);
            min = distance;
          }
        }
      }
      return { closestMatch: closestMatch, path: closestMatchPath, distance: min, indexMatch: indexMatch };
    }
  }, {
    key: 'printLocation',
    value: function printLocation(path, option) {
      var prefix = arguments.length <= 2 || arguments[2] === undefined ? 'Problem value found at: \n' : arguments[2];

      var str = '\n\n' + prefix + 'options = {\n';
      for (var i = 0; i < path.length; i++) {
        for (var j = 0; j < i + 1; j++) {
          str += '  ';
        }
        str += path[i] + ': {\n';
      }
      for (var j = 0; j < path.length + 1; j++) {
        str += '  ';
      }
      str += option + '\n';
      for (var i = 0; i < path.length + 1; i++) {
        for (var j = 0; j < path.length - i; j++) {
          str += '  ';
        }
        str += '}\n';
      }
      return str + '\n\n';
    }
  }, {
    key: 'print',
    value: function print(options) {
      return JSON.stringify(options).replace(/(\")|(\[)|(\])|(,"__type__")/g, "").replace(/(\,)/g, ', ');
    }

    // Compute the edit distance between the two given strings
    // http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
    /*
     Copyright (c) 2011 Andrei Mackenzie
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */
  }, {
    key: 'levenshteinDistance',
    value: function levenshteinDistance(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;

      var matrix = [];

      // increment along the first column of each row
      var i;
      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }

      // increment each column in the first row
      var j;
      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }

      // Fill in the rest of the matrix
      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) == a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
            Math.min(matrix[i][j - 1] + 1, // insertion
            matrix[i - 1][j] + 1)); // deletion
          }
        }
      }

      return matrix[b.length][a.length];
    }
  }]);

  return Validator;
})();

exports['default'] = Validator;
exports.printStyle = printStyle;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9zaGFyZWQvVmFsaWRhdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7O0FBRTlCLElBQUksVUFBVSxHQUFHLEtBQUssQ0FBQztBQUN2QixJQUFJLFVBQVUsWUFBQSxDQUFDO0FBQ2YsSUFBSSxVQUFVLEdBQUcscUNBQXFDLENBQUM7Ozs7O0lBSWpELFNBQVM7QUFDRixXQURQLFNBQVMsR0FDQzswQkFEVixTQUFTO0dBRVo7Ozs7Ozs7OztlQUZHLFNBQVM7O1dBVUUsa0JBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFNBQVMsRUFBRTtBQUNwRCxnQkFBVSxHQUFHLEtBQUssQ0FBQztBQUNuQixnQkFBVSxHQUFHLGdCQUFnQixDQUFDO0FBQzlCLFVBQUksV0FBVyxHQUFHLGdCQUFnQixDQUFDO0FBQ25DLFVBQUksU0FBUyxLQUFLLFNBQVMsRUFBRTtBQUMzQixtQkFBVyxHQUFHLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO09BQzNDO0FBQ0QsZUFBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzFDLGFBQU8sVUFBVSxDQUFDO0tBQ25COzs7Ozs7Ozs7O1dBU1csZUFBQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFO0FBQzVDLFdBQUssSUFBSSxNQUFNLElBQUksT0FBTyxFQUFFO0FBQzFCLFlBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsRUFBRTtBQUNsQyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzFEO09BQ0Y7S0FDRjs7Ozs7Ozs7Ozs7V0FVVyxlQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxF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QUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQ3RDLGtCQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7V0FDckMsTUFBTTtBQUNMLGtCQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzlDLGdCQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUMzQixrQkFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1dBQzVCO1NBQ0Y7T0FDRjs7QUFFRCxhQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ25DOzs7U0E3UkcsU0FBUzs7O3FCQW1TQSxTQUFTO1FBQ2hCLFVBQVUsR0FBVixVQUFVIiwiZmlsZSI6Ii91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi9zaGFyZWQvVmFsaWRhdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmxldCBlcnJvckZvdW5kID0gZmFsc2U7XG5sZXQgYWxsT3B0aW9ucztcbmxldCBwcmludFN0eWxlID0gJ2JhY2tncm91bmQ6ICNGRmVlZWU7IGNvbG9yOiAjZGQwMDAwJztcbi8qKlxuICogIFVzZWQgdG8gdmFsaWRhdGUgb3B0aW9ucy5cbiAqL1xuY2xhc3MgVmFsaWRhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICAvKipcbiAgICogTWFpbiBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIHN1Yk9iamVjdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZShvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBzdWJPYmplY3QpIHtcbiAgICBlcnJvckZvdW5kID0gZmFsc2U7XG4gICAgYWxsT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgbGV0IHVzZWRPcHRpb25zID0gcmVmZXJlbmNlT3B0aW9ucztcbiAgICBpZiAoc3ViT2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVzZWRPcHRpb25zID0gcmVmZXJlbmNlT3B0aW9uc1tzdWJPYmplY3RdO1xuICAgIH1cbiAgICBWYWxpZGF0b3IucGFyc2Uob3B0aW9ucywgdXNlZE9wdGlvbnMsIFtdKTtcbiAgICByZXR1cm4gZXJyb3JGb3VuZDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdpbGwgdHJhdmVyc2UgYW4gb2JqZWN0IHJlY3Vyc2l2ZWx5IGFuZCBjaGVjayBldmVyeSB2YWx1ZVxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gcmVmZXJlbmNlT3B0aW9uc1xuICAgKiBAcGFyYW0gcGF0aFxuICAgKi9cbiAgc3RhdGljIHBhcnNlKG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpIHtcbiAgICBmb3IgKGxldCBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICBWYWxpZGF0b3IuY2hlY2sob3B0aW9uLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDaGVjayBldmVyeSB2YWx1ZS4gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgY2FsbCB0aGUgcGFyc2UgZnVuY3Rpb24gb24gdGhhdCBvYmplY3QuXG4gICAqIEBwYXJhbSBvcHRpb25cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIHJlZmVyZW5jZU9wdGlvbnNcbiAgICogQHBhcmFtIHBhdGhcbiAgICovXG4gIHN0YXRpYyBjaGVjayhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHBhdGgpIHtcbiAgICBpZiAocmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dID09PSB1bmRlZmluZWQgJiYgcmVmZXJlbmNlT3B0aW9ucy5fX2FueV9fID09PSB1bmRlZmluZWQpIHtcbiAgICAgIFZhbGlkYXRvci5nZXRTdWdnZXN0aW9uKG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSA9PT0gdW5kZWZpbmVkICYmIHJlZmVyZW5jZU9wdGlvbnMuX19hbnlfXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBfX2FueV9fIGlzIGEgd2lsZGNhcmQuIEFueSB2YWx1ZSBpcyBhY2NlcHRlZCBhbmQgd2lsbCBiZSBmdXJ0aGVyIGFuYWx5c2VkIGJ5IHJlZmVyZW5jZS5cbiAgICAgIGlmIChWYWxpZGF0b3IuZ2V0VHlwZShvcHRpb25zW29wdGlvbl0pID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2VPcHRpb25zWydfX2FueV9fJ10uX190eXBlX18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBpZiB0aGUgYW55IHN1Ymdyb3VwIGlzIG5vdCBhIHByZWRlZmluZWQgb2JqZWN0IGludCBoZSBjb25maWd1cmF0b3Igd2UgZG8gbm90IGxvb2sgZGVlcGVyIGludG8gdGhlIG9iamVjdC5cbiAgICAgICAgVmFsaWRhdG9yLmNoZWNrRmllbGRzKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgJ19fYW55X18nLCByZWZlcmVuY2VPcHRpb25zWydfX2FueV9fJ10uX190eXBlX18sIHBhdGgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsICdfX2FueV9fJywgcmVmZXJlbmNlT3B0aW9uc1snX19hbnlfXyddLCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBTaW5jZSBhbGwgb3B0aW9ucyBpbiB0aGUgcmVmZXJlbmNlIGFyZSBvYmplY3RzLCB3ZSBjYW4gY2hlY2sgd2hldGhlciB0aGV5IGFyZSBzdXBwb3NlZCB0byBiZSBvYmplY3QgdG8gbG9vayBmb3IgdGhlIF9fdHlwZV9fIGZpZWxkLlxuICAgICAgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXS5fX3R5cGVfXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgc2hvdWxkIGJlIGFuIG9iamVjdCwgd2UgY2hlY2sgaWYgdGhlIGNvcnJlY3QgdHlwZSBoYXMgYmVlbiBzdXBwbGllZCB0byBhY2NvdW50IGZvciBzaG9ydGhhbmQgb3B0aW9ucy5cbiAgICAgICAgVmFsaWRhdG9yLmNoZWNrRmllbGRzKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgb3B0aW9uLCByZWZlcmVuY2VPcHRpb25zW29wdGlvbl0uX190eXBlX18sIHBhdGgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIFZhbGlkYXRvci5jaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9uc1tvcHRpb25dLCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9ICBvcHRpb24gICAgIHwgdGhlIG9wdGlvbiBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gIG9wdGlvbnMgICAgfCBUaGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9ICByZWZlcmVuY2VPcHRpb25zICAgIHwgVGhlIHJlZmVyZW5jZSBvcHRpb25zIGNvbnRhaW5pbmcgYWxsIG9wdGlvbnMgYW5kIHRoZWlyIGFsbG93ZWQgZm9ybWF0c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gIHJlZmVyZW5jZU9wdGlvbiAgICAgfCBVc3VhbGx5IHRoaXMgaXMgdGhlIHNhbWUgYXMgb3B0aW9uLCBleGNlcHQgd2hlbiBoYW5kbGluZyBhbiBfX2FueV9fIHRhZy5cbiAgICogQHBhcmFtIHtTdHJpbmd9ICByZWZPcHRpb25UeXBlICAgICAgIHwgVGhpcyBpcyB0aGUgdHlwZSBvYmplY3QgZnJvbSB0aGUgcmVmZXJlbmNlIG9wdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheX0gICBwYXRoICAgICAgfCB3aGVyZSBpbiB0aGUgb2JqZWN0IGlzIHRoZSBvcHRpb25cbiAgICovXG4gIHN0YXRpYyBjaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbiwgcmVmT3B0aW9uT2JqLCBwYXRoKSB7XG4gICAgbGV0IG9wdGlvblR5cGUgPSBWYWxpZGF0b3IuZ2V0VHlwZShvcHRpb25zW29wdGlvbl0pO1xuICAgIGxldCByZWZPcHRpb25UeXBlID0gcmVmT3B0aW9uT2JqW29wdGlvblR5cGVdO1xuICAgIGlmIChyZWZPcHRpb25UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGlmIHRoZSB0eXBlIGlzIGNvcnJlY3QsIHdlIGNoZWNrIGlmIGl0IGlzIHN1cHBvc2VkIHRvIGJlIG9uZSBvZiBhIGZldyBzZWxlY3QgdmFsdWVzXG4gICAgICBpZiAoVmFsaWRhdG9yLmdldFR5cGUocmVmT3B0aW9uVHlwZSkgPT09ICdhcnJheScpIHtcbiAgICAgICAgaWYgKHJlZk9wdGlvblR5cGUuaW5kZXhPZihvcHRpb25zW29wdGlvbl0pID09PSAtMSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCclY0ludmFsaWQgb3B0aW9uIGRldGVjdGVkIGluIFwiJyArIG9wdGlvbiArICdcIi4nICtcbiAgICAgICAgICAgICcgQWxsb3dlZCB2YWx1ZXMgYXJlOicgKyBWYWxpZGF0b3IucHJpbnQocmVmT3B0aW9uVHlwZSkgKyAnIG5vdCBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCIuICcgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pLCBwcmludFN0eWxlKTtcbiAgICAgICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25UeXBlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2VPcHRpb24gIT09IFwiX19hbnlfX1wiKSB7XG4gICAgICAgICAgcGF0aCA9IHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsIG9wdGlvbik7XG4gICAgICAgICAgVmFsaWRhdG9yLnBhcnNlKG9wdGlvbnNbb3B0aW9uXSwgcmVmZXJlbmNlT3B0aW9uc1tyZWZlcmVuY2VPcHRpb25dLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3B0aW9uVHlwZSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlT3B0aW9uICE9PSBcIl9fYW55X19cIikge1xuICAgICAgICBwYXRoID0gdXRpbC5jb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgb3B0aW9uKTtcbiAgICAgICAgVmFsaWRhdG9yLnBhcnNlKG9wdGlvbnNbb3B0aW9uXSwgcmVmZXJlbmNlT3B0aW9uc1tyZWZlcmVuY2VPcHRpb25dLCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVmT3B0aW9uT2JqWydhbnknXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0eXBlIG9mIHRoZSBmaWVsZCBpcyBpbmNvcnJlY3QgYW5kIHRoZSBmaWVsZCBjYW5ub3QgYmUgYW55XG4gICAgICBjb25zb2xlLmxvZygnJWNJbnZhbGlkIHR5cGUgcmVjZWl2ZWQgZm9yIFwiJyArIG9wdGlvbiArICdcIi4gRXhwZWN0ZWQ6ICcgKyBWYWxpZGF0b3IucHJpbnQoT2JqZWN0LmtleXMocmVmT3B0aW9uT2JqKSkgKyAnLiBSZWNlaXZlZCBbJyArIG9wdGlvblR5cGUgKyAnXSBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCInICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgcHJpbnRTdHlsZSk7XG4gICAgICBlcnJvckZvdW5kID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuXG4gIHN0YXRpYyBnZXRUeXBlKG9iamVjdCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iamVjdDtcblxuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuICdib29sZWFuJztcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Qubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gJ2RvbSc7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Ll9pc0FNb21lbnRPYmplY3QgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuICdtb21lbnQnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRTdWdnZXN0aW9uKG9wdGlvbiwgb3B0aW9ucywgcGF0aCkge1xuICAgIGxldCBsb2NhbFNlYXJjaCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbixvcHRpb25zLHBhdGgsZmFsc2UpO1xuICAgIGxldCBnbG9iYWxTZWFyY2ggPSBWYWxpZGF0b3IuZmluZEluT3B0aW9ucyhvcHRpb24sYWxsT3B0aW9ucyxbXSx0cnVlKTtcblxuICAgIGxldCBsb2NhbFNlYXJjaFRocmVzaG9sZCA9IDg7XG4gICAgbGV0IGdsb2JhbFNlYXJjaFRocmVzaG9sZCA9IDQ7XG5cbiAgICBpZiAobG9jYWxTZWFyY2guaW5kZXhNYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLmxvZygnJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiIGluICcgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihsb2NhbFNlYXJjaC5wYXRoLCBvcHRpb24sJycpICsgJ1BlcmhhcHMgaXQgd2FzIGluY29tcGxldGU/IERpZCB5b3UgbWVhbjogXCInICsgbG9jYWxTZWFyY2guaW5kZXhNYXRjaCArICdcIj9cXG5cXG4nLCBwcmludFN0eWxlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2xvYmFsU2VhcmNoLmRpc3RhbmNlIDw9IGdsb2JhbFNlYXJjaFRocmVzaG9sZCAmJiBsb2NhbFNlYXJjaC5kaXN0YW5jZSA+IGdsb2JhbFNlYXJjaC5kaXN0YW5jZSkge1xuICAgICAgY29uc29sZS5sb2coJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJyArIG9wdGlvbiArICdcIiBpbiAnICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uLCcnKSArICdQZXJoYXBzIGl0IHdhcyBtaXNwbGFjZWQ/IE1hdGNoaW5nIG9wdGlvbiBmb3VuZCBhdDogJyArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGdsb2JhbFNlYXJjaC5wYXRoLCBnbG9iYWxTZWFyY2guY2xvc2VzdE1hdGNoLCcnKSwgcHJpbnRTdHlsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvY2FsU2VhcmNoLmRpc3RhbmNlIDw9IGxvY2FsU2VhcmNoVGhyZXNob2xkKSB7XG4gICAgICBjb25zb2xlLmxvZygnJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiLiBEaWQgeW91IG1lYW4gXCInICsgbG9jYWxTZWFyY2guY2xvc2VzdE1hdGNoICsgJ1wiPycgKyBWYWxpZGF0b3IucHJpbnRMb2NhdGlvbihsb2NhbFNlYXJjaC5wYXRoLCBvcHRpb24pLCBwcmludFN0eWxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnJWNVbmtub3duIG9wdGlvbiBkZXRlY3RlZDogXCInICsgb3B0aW9uICsgJ1wiLiBEaWQgeW91IG1lYW4gb25lIG9mIHRoZXNlOiAnICsgVmFsaWRhdG9yLnByaW50KE9iamVjdC5rZXlzKG9wdGlvbnMpKSArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiksIHByaW50U3R5bGUpO1xuICAgIH1cblxuICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIHRyYXZlcnNlIHRoZSBvcHRpb25zIGluIHNlYXJjaCBmb3IgYSBtYXRjaC5cbiAgICogQHBhcmFtIG9wdGlvblxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gcGF0aFxuICAgKiBAcGFyYW0gcmVjdXJzaXZlXG4gICAqIEByZXR1cm5zIHt7Y2xvc2VzdE1hdGNoOiBzdHJpbmcsIHBhdGg6IEFycmF5LCBkaXN0YW5jZTogbnVtYmVyfX1cbiAgICovXG4gIHN0YXRpYyBmaW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9ucywgcGF0aCwgcmVjdXJzaXZlID0gZmFsc2UpIHtcbiAgICBsZXQgbWluID0gMWU5O1xuICAgIGxldCBjbG9zZXN0TWF0Y2ggPSAnJztcbiAgICBsZXQgY2xvc2VzdE1hdGNoUGF0aCA9IFtdO1xuICAgIGxldCBsb3dlckNhc2VPcHRpb24gPSBvcHRpb24udG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgaW5kZXhNYXRjaCA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGxldCBvcCBpbiBvcHRpb25zKSB7XG4gICAgICBsZXQgZGlzdGFuY2U7XG4gICAgICBpZiAob3B0aW9uc1tvcF0uX190eXBlX18gIT09IHVuZGVmaW5lZCAmJiByZWN1cnNpdmUgPT09IHRydWUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFZhbGlkYXRvci5maW5kSW5PcHRpb25zKG9wdGlvbiwgb3B0aW9uc1tvcF0sIHV0aWwuY29weUFuZEV4dGVuZEFycmF5KHBhdGgsb3ApKTtcbiAgICAgICAgaWYgKG1pbiA+IHJlc3VsdC5kaXN0YW5jZSkge1xuICAgICAgICAgIGNsb3Nlc3RNYXRjaCA9IHJlc3VsdC5jbG9zZXN0TWF0Y2g7XG4gICAgICAgICAgY2xvc2VzdE1hdGNoUGF0aCA9IHJlc3VsdC5wYXRoO1xuICAgICAgICAgIG1pbiA9IHJlc3VsdC5kaXN0YW5jZTtcbiAgICAgICAgICBpbmRleE1hdGNoID0gcmVzdWx0LmluZGV4TWF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAob3AudG9Mb3dlckNhc2UoKS5pbmRleE9mKGxvd2VyQ2FzZU9wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgaW5kZXhNYXRjaCA9IG9wO1xuICAgICAgICB9XG4gICAgICAgIGRpc3RhbmNlID0gVmFsaWRhdG9yLmxldmVuc2h0ZWluRGlzdGFuY2Uob3B0aW9uLCBvcCk7XG4gICAgICAgIGlmIChtaW4gPiBkaXN0YW5jZSkge1xuICAgICAgICAgIGNsb3Nlc3RNYXRjaCA9IG9wO1xuICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSB1dGlsLmNvcHlBcnJheShwYXRoKTtcbiAgICAgICAgICBtaW4gPSBkaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge2Nsb3Nlc3RNYXRjaDpjbG9zZXN0TWF0Y2gsIHBhdGg6Y2xvc2VzdE1hdGNoUGF0aCwgZGlzdGFuY2U6bWluLCBpbmRleE1hdGNoOiBpbmRleE1hdGNofTtcbiAgfVxuXG4gIHN0YXRpYyBwcmludExvY2F0aW9uKHBhdGgsIG9wdGlvbiwgcHJlZml4ID0gJ1Byb2JsZW0gdmFsdWUgZm91bmQgYXQ6IFxcbicpIHtcbiAgICBsZXQgc3RyID0gJ1xcblxcbicgKyBwcmVmaXggKyAnb3B0aW9ucyA9IHtcXG4nO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpICsgMTsgaisrKSB7XG4gICAgICAgIHN0ciArPSAnICAnO1xuICAgICAgfVxuICAgICAgc3RyICs9IHBhdGhbaV0gKyAnOiB7XFxuJ1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhdGgubGVuZ3RoICsgMTsgaisrKSB7XG4gICAgICBzdHIgKz0gJyAgJztcbiAgICB9XG4gICAgc3RyICs9IG9wdGlvbiArICdcXG4nO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggKyAxOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGF0aC5sZW5ndGggLSBpOyBqKyspIHtcbiAgICAgICAgc3RyICs9ICcgICc7XG4gICAgICB9XG4gICAgICBzdHIgKz0gJ31cXG4nXG4gICAgfVxuICAgIHJldHVybiBzdHIgKyAnXFxuXFxuJztcbiAgfVxuXG4gIHN0YXRpYyBwcmludChvcHRpb25zKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpLnJlcGxhY2UoLyhcXFwiKXwoXFxbKXwoXFxdKXwoLFwiX190eXBlX19cIikvZywgXCJcIikucmVwbGFjZSgvKFxcLCkvZywgJywgJylcbiAgfVxuXG5cbiAgLy8gQ29tcHV0ZSB0aGUgZWRpdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5nc1xuICAvLyBodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9TdHJpbmdzL0xldmVuc2h0ZWluX2Rpc3RhbmNlI0phdmFTY3JpcHRcbiAgLypcbiAgIENvcHlyaWdodCAoYykgMjAxMSBBbmRyZWkgTWFja2VuemllXG5cbiAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAgICovXG4gIHN0YXRpYyBsZXZlbnNodGVpbkRpc3RhbmNlKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggPT09IDApIHJldHVybiBiLmxlbmd0aDtcbiAgICBpZiAoYi5sZW5ndGggPT09IDApIHJldHVybiBhLmxlbmd0aDtcblxuICAgIHZhciBtYXRyaXggPSBbXTtcblxuICAgIC8vIGluY3JlbWVudCBhbG9uZyB0aGUgZmlyc3QgY29sdW1uIG9mIGVhY2ggcm93XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXRyaXhbaV0gPSBbaV07XG4gICAgfVxuXG4gICAgLy8gaW5jcmVtZW50IGVhY2ggY29sdW1uIGluIHRoZSBmaXJzdCByb3dcbiAgICB2YXIgajtcbiAgICBmb3IgKGogPSAwOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgIG1hdHJpeFswXVtqXSA9IGo7XG4gICAgfVxuXG4gICAgLy8gRmlsbCBpbiB0aGUgcmVzdCBvZiB0aGUgbWF0cml4XG4gICAgZm9yIChpID0gMTsgaSA8PSBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGogPSAxOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGIuY2hhckF0KGkgLSAxKSA9PSBhLmNoYXJBdChqIC0gMSkpIHtcbiAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaSAtIDFdW2ogLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRyaXhbaV1bal0gPSBNYXRoLm1pbihtYXRyaXhbaSAtIDFdW2ogLSAxXSArIDEsIC8vIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgTWF0aC5taW4obWF0cml4W2ldW2ogLSAxXSArIDEsIC8vIGluc2VydGlvblxuICAgICAgICAgICAgICBtYXRyaXhbaSAtIDFdW2pdICsgMSkpOyAvLyBkZWxldGlvblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdHJpeFtiLmxlbmd0aF1bYS5sZW5ndGhdO1xuICB9XG5cbjtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBWYWxpZGF0b3I7XG5leHBvcnQge3ByaW50U3R5bGV9Il19
},{"../util":46}],26:[function(require,module,exports){
'use strict';

var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var hammerUtil = require('../hammerUtil');
var util = require('../util');
var DataSet = require('../DataSet');
var DataView = require('../DataView');
var Range = require('./Range');
var ItemSet = require('./component/ItemSet');
var TimeAxis = require('./component/TimeAxis');
var Activator = require('../shared/Activator');
var DateUtil = require('./DateUtil');
var CustomTime = require('./component/CustomTime');

/**
 * Create a timeline visualization
 * @constructor
 */
function Core() {}

// turn Core into an event emitter
Emitter(Core.prototype);

/**
 * Create the main DOM for the Core: a root panel containing left, right,
 * top, bottom, content, and background panel.
 * @param {Element} container  The container element where the Core will
 *                             be attached.
 * @protected
 */
Core.prototype._create = function (container) {
  this.dom = {};

  this.dom.container = container;

  this.dom.root = document.createElement('div');
  this.dom.background = document.createElement('div');
  this.dom.backgroundVertical = document.createElement('div');
  this.dom.backgroundHorizontal = document.createElement('div');
  this.dom.centerContainer = document.createElement('div');
  this.dom.leftContainer = document.createElement('div');
  this.dom.rightContainer = document.createElement('div');
  this.dom.center = document.createElement('div');
  this.dom.left = document.createElement('div');
  this.dom.right = document.createElement('div');
  this.dom.top = document.createElement('div');
  this.dom.bottom = document.createElement('div');
  this.dom.shadowTop = document.createElement('div');
  this.dom.shadowBottom = document.createElement('div');
  this.dom.shadowTopLeft = document.createElement('div');
  this.dom.shadowBottomLeft = document.createElement('div');
  this.dom.shadowTopRight = document.createElement('div');
  this.dom.shadowBottomRight = document.createElement('div');

  this.dom.root.className = 'vis-timeline';
  this.dom.background.className = 'vis-panel vis-background';
  this.dom.backgroundVertical.className = 'vis-panel vis-background vis-vertical';
  this.dom.backgroundHorizontal.className = 'vis-panel vis-background vis-horizontal';
  this.dom.centerContainer.className = 'vis-panel vis-center';
  this.dom.leftContainer.className = 'vis-panel vis-left';
  this.dom.rightContainer.className = 'vis-panel vis-right';
  this.dom.top.className = 'vis-panel vis-top';
  this.dom.bottom.className = 'vis-panel vis-bottom';
  this.dom.left.className = 'vis-content';
  this.dom.center.className = 'vis-content';
  this.dom.right.className = 'vis-content';
  this.dom.shadowTop.className = 'vis-shadow vis-top';
  this.dom.shadowBottom.className = 'vis-shadow vis-bottom';
  this.dom.shadowTopLeft.className = 'vis-shadow vis-top';
  this.dom.shadowBottomLeft.className = 'vis-shadow vis-bottom';
  this.dom.shadowTopRight.className = 'vis-shadow vis-top';
  this.dom.shadowBottomRight.className = 'vis-shadow vis-bottom';

  this.dom.root.appendChild(this.dom.background);
  this.dom.root.appendChild(this.dom.backgroundVertical);
  this.dom.root.appendChild(this.dom.backgroundHorizontal);
  this.dom.root.appendChild(this.dom.centerContainer);
  this.dom.root.appendChild(this.dom.leftContainer);
  this.dom.root.appendChild(this.dom.rightContainer);
  this.dom.root.appendChild(this.dom.top);
  this.dom.root.appendChild(this.dom.bottom);

  this.dom.centerContainer.appendChild(this.dom.center);
  this.dom.leftContainer.appendChild(this.dom.left);
  this.dom.rightContainer.appendChild(this.dom.right);

  this.dom.centerContainer.appendChild(this.dom.shadowTop);
  this.dom.centerContainer.appendChild(this.dom.shadowBottom);
  this.dom.leftContainer.appendChild(this.dom.shadowTopLeft);
  this.dom.leftContainer.appendChild(this.dom.shadowBottomLeft);
  this.dom.rightContainer.appendChild(this.dom.shadowTopRight);
  this.dom.rightContainer.appendChild(this.dom.shadowBottomRight);

  this.on('rangechange', (function () {
    this._redraw(); // this allows overriding the _redraw method
  }).bind(this));
  this.on('touch', this._onTouch.bind(this));
  this.on('pan', this._onDrag.bind(this));

  var me = this;
  this.on('change', function (properties) {
    if (properties && properties.queue == true) {
      // redraw once on next tick
      if (!me._redrawTimer) {
        me._redrawTimer = setTimeout(function () {
          me._redrawTimer = null;
          me._redraw();
        }, 0);
      }
    } else {
      // redraw immediately
      me._redraw();
    }
  });

  // create event listeners for all interesting events, these events will be
  // emitted via emitter
  this.hammer = new Hammer(this.dom.root);
  this.hammer.get('pinch').set({ enable: true });
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.
  this.listeners = {};

  var events = ['tap', 'doubletap', 'press', 'pinch', 'pan', 'panstart', 'panmove', 'panend'
  // TODO: cleanup
  //'touch', 'pinch',
  //'tap', 'doubletap', 'hold',
  //'dragstart', 'drag', 'dragend',
  //'mousewheel', 'DOMMouseScroll' // DOMMouseScroll is needed for Firefox
  ];
  events.forEach(function (type) {
    var listener = function listener(event) {
      if (me.isActive()) {
        me.emit(type, event);
      }
    };
    me.hammer.on(type, listener);
    me.listeners[type] = listener;
  });

  // emulate a touch event (emitted before the start of a pan, pinch, tap, or press)
  hammerUtil.onTouch(this.hammer, (function (event) {
    me.emit('touch', event);
  }).bind(this));

  // emulate a release event (emitted after a pan, pinch, tap, or press)
  hammerUtil.onRelease(this.hammer, (function (event) {
    me.emit('release', event);
  }).bind(this));

  function onMouseWheel(event) {
    if (me.isActive()) {
      me.emit('mousewheel', event);
    }
  }
  this.dom.root.addEventListener('mousewheel', onMouseWheel);
  this.dom.root.addEventListener('DOMMouseScroll', onMouseWheel);

  // size properties of each of the panels
  this.props = {
    root: {},
    background: {},
    centerContainer: {},
    leftContainer: {},
    rightContainer: {},
    center: {},
    left: {},
    right: {},
    top: {},
    bottom: {},
    border: {},
    scrollTop: 0,
    scrollTopMin: 0
  };

  this.customTimes = [];

  // store state information needed for touch events
  this.touch = {};

  this.redrawCount = 0;

  // attach the root panel to the provided container
  if (!container) throw new Error('No container provided');
  container.appendChild(this.dom.root);
};

/**
 * Set options. Options will be passed to all components loaded in the Timeline.
 * @param {Object} [options]
 *                           {String} orientation
 *                              Vertical orientation for the Timeline,
 *                              can be 'bottom' (default) or 'top'.
 *                           {String | Number} width
 *                              Width for the timeline, a number in pixels or
 *                              a css string like '1000px' or '75%'. '100%' by default.
 *                           {String | Number} height
 *                              Fixed height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'. If undefined,
 *                              The Timeline will automatically size such that
 *                              its contents fit.
 *                           {String | Number} minHeight
 *                              Minimum height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'.
 *                           {String | Number} maxHeight
 *                              Maximum height for the Timeline, a number in pixels or
 *                              a css string like '400px' or '75%'.
 *                           {Number | Date | String} start
 *                              Start date for the visible window
 *                           {Number | Date | String} end
 *                              End date for the visible window
 */
Core.prototype.setOptions = function (options) {
  if (options) {
    // copy the known options
    var fields = ['width', 'height', 'minHeight', 'maxHeight', 'autoResize', 'start', 'end', 'clickToUse', 'dataAttributes', 'hiddenDates', 'locale', 'locales', 'moment', 'throttleRedraw'];
    util.selectiveExtend(fields, this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation = {
          item: options.orientation,
          axis: options.orientation
        };
      } else if (typeof options.orientation === 'object') {
        if ('item' in options.orientation) {
          this.options.orientation.item = options.orientation.item;
        }
        if ('axis' in options.orientation) {
          this.options.orientation.axis = options.orientation.axis;
        }
      }
    }

    if (this.options.orientation.axis === 'both') {
      if (!this.timeAxis2) {
        var timeAxis2 = this.timeAxis2 = new TimeAxis(this.body);
        timeAxis2.setOptions = function (options) {
          var _options = options ? util.extend({}, options) : {};
          _options.orientation = 'top'; // override the orientation option, always top
          TimeAxis.prototype.setOptions.call(timeAxis2, _options);
        };
        this.components.push(timeAxis2);
      }
    } else {
      if (this.timeAxis2) {
        var index = this.components.indexOf(this.timeAxis2);
        if (index !== -1) {
          this.components.splice(index, 1);
        }
        this.timeAxis2.destroy();
        this.timeAxis2 = null;
      }
    }

    // if the graph2d's drawPoints is a function delegate the callback to the onRender property
    if (typeof options.drawPoints == 'function') {
      options.drawPoints = {
        onRender: options.drawPoints
      };
    }

    if ('hiddenDates' in this.options) {
      DateUtil.convertHiddenOptions(this.options.moment, this.body, this.options.hiddenDates);
    }

    if ('clickToUse' in options) {
      if (options.clickToUse) {
        if (!this.activator) {
          this.activator = new Activator(this.dom.root);
        }
      } else {
        if (this.activator) {
          this.activator.destroy();
          delete this.activator;
        }
      }
    }

    if ('showCustomTime' in options) {
      throw new Error('Option `showCustomTime` is deprecated. Create a custom time bar via timeline.addCustomTime(time [, id])');
    }

    // enable/disable autoResize
    this._initAutoResize();
  }

  // propagate options to all components
  this.components.forEach(function (component) {
    return component.setOptions(options);
  });

  // enable/disable configure
  if ('configure' in options) {
    if (!this.configurator) {
      this.configurator = this._createConfigurator();
    }

    this.configurator.setOptions(options.configure);

    // collect the settings of all components, and pass them to the configuration system
    var appliedOptions = util.deepExtend({}, this.options);
    this.components.forEach(function (component) {
      util.deepExtend(appliedOptions, component.options);
    });
    this.configurator.setModuleOptions({ global: appliedOptions });
  }

  // override redraw with a throttled version
  if (!this._origRedraw) {
    this._origRedraw = this._redraw.bind(this);
  }
  this._redraw = util.throttle(this._origRedraw, this.options.throttleRedraw);

  // redraw everything
  this._redraw();
};

/**
 * Returns true when the Timeline is active.
 * @returns {boolean}
 */
Core.prototype.isActive = function () {
  return !this.activator || this.activator.active;
};

/**
 * Destroy the Core, clean up all DOM elements and event listeners.
 */
Core.prototype.destroy = function () {
  // unbind datasets
  this.setItems(null);
  this.setGroups(null);

  // remove all event listeners
  this.off();

  // stop checking for changed size
  this._stopAutoResize();

  // remove from DOM
  if (this.dom.root.parentNode) {
    this.dom.root.parentNode.removeChild(this.dom.root);
  }
  this.dom = null;

  // remove Activator
  if (this.activator) {
    this.activator.destroy();
    delete this.activator;
  }

  // cleanup hammer touch events
  for (var event in this.listeners) {
    if (this.listeners.hasOwnProperty(event)) {
      delete this.listeners[event];
    }
  }
  this.listeners = null;
  this.hammer = null;

  // give all components the opportunity to cleanup
  this.components.forEach(function (component) {
    return component.destroy();
  });

  this.body = null;
};

/**
 * Set a custom time bar
 * @param {Date} time
 * @param {number} [id=undefined] Optional id of the custom time bar to be adjusted.
 */
Core.prototype.setCustomTime = function (time, id) {
  var customTimes = this.customTimes.filter(function (component) {
    return id === component.options.id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }

  if (customTimes.length > 0) {
    customTimes[0].setCustomTime(time);
  }
};

/**
 * Retrieve the current custom time.
 * @param {number} [id=undefined]    Id of the custom time bar.
 * @return {Date | undefined} customTime
 */
Core.prototype.getCustomTime = function (id) {
  var customTimes = this.customTimes.filter(function (component) {
    return component.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }
  return customTimes[0].getCustomTime();
};

/**
 * Set a custom title for the custom time bar.
 * @param {String} [title] Custom title
 * @param {number} [id=undefined]    Id of the custom time bar.
 */
Core.prototype.setCustomTimeTitle = function (title, id) {
  var customTimes = this.customTimes.filter(function (component) {
    return component.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }
  if (customTimes.length > 0) {
    return customTimes[0].setCustomTitle(title);
  }
};

/**
 * Retrieve meta information from an event.
 * Should be overridden by classes extending Core
 * @param {Event} event
 * @return {Object} An object with related information.
 */
Core.prototype.getEventProperties = function (event) {
  return { event: event };
};

/**
 * Add custom vertical bar
 * @param {Date | String | Number} [time]  A Date, unix timestamp, or
 *                                         ISO date string. Time point where
 *                                         the new bar should be placed.
 *                                         If not provided, `new Date()` will
 *                                         be used.
 * @param {Number | String} [id=undefined] Id of the new bar. Optional
 * @return {Number | String}               Returns the id of the new bar
 */
Core.prototype.addCustomTime = function (time, id) {
  var timestamp = time !== undefined ? util.convert(time, 'Date').valueOf() : new Date();

  var exists = this.customTimes.some(function (customTime) {
    return customTime.options.id === id;
  });
  if (exists) {
    throw new Error('A custom time with id ' + JSON.stringify(id) + ' already exists');
  }

  var customTime = new CustomTime(this.body, util.extend({}, this.options, {
    time: timestamp,
    id: id
  }));

  this.customTimes.push(customTime);
  this.components.push(customTime);
  this._redraw();

  return id;
};

/**
 * Remove previously added custom bar
 * @param {int} id ID of the custom bar to be removed
 * @return {boolean} True if the bar exists and is removed, false otherwise
 */
Core.prototype.removeCustomTime = function (id) {
  var customTimes = this.customTimes.filter(function (bar) {
    return bar.options.id === id;
  });

  if (customTimes.length === 0) {
    throw new Error('No custom time bar found with id ' + JSON.stringify(id));
  }

  customTimes.forEach((function (customTime) {
    this.customTimes.splice(this.customTimes.indexOf(customTime), 1);
    this.components.splice(this.components.indexOf(customTime), 1);
    customTime.destroy();
  }).bind(this));
};

/**
 * Get the id's of the currently visible items.
 * @returns {Array} The ids of the visible items
 */
Core.prototype.getVisibleItems = function () {
  return this.itemSet && this.itemSet.getVisibleItems() || [];
};

/**
 * Set Core window such that it fits all items
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.fit = function (options) {
  var range = this.getDataRange();

  // skip range set if there is no min and max date
  if (range.min === null && range.max === null) {
    return;
  }

  // apply a margin of 1% left and right of the data
  var interval = range.max - range.min;
  var min = new Date(range.min.valueOf() - interval * 0.01);
  var max = new Date(range.max.valueOf() + interval * 0.01);

  var animation = options && options.animation !== undefined ? options.animation : true;
  this.range.setRange(min, max, animation);
};

/**
 * Calculate the data range of the items start and end dates
 * @returns {{min: Date | null, max: Date | null}}
 * @protected
 */
Core.prototype.getDataRange = function () {
  // must be implemented by Timeline and Graph2d
  throw new Error('Cannot invoke abstract method getDataRange');
};

/**
 * Set the visible window. Both parameters are optional, you can change only
 * start or only end. Syntax:
 *
 *     TimeLine.setWindow(start, end)
 *     TimeLine.setWindow(start, end, options)
 *     TimeLine.setWindow(range)
 *
 * Where start and end can be a Date, number, or string, and range is an
 * object with properties start and end.
 *
 * @param {Date | Number | String | Object} [start] Start date of visible window
 * @param {Date | Number | String} [end]            End date of visible window
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.setWindow = function (start, end, options) {
  var animation;
  if (arguments.length == 1) {
    var range = arguments[0];
    animation = range.animation !== undefined ? range.animation : true;
    this.range.setRange(range.start, range.end, animation);
  } else {
    animation = options && options.animation !== undefined ? options.animation : true;
    this.range.setRange(start, end, animation);
  }
};

/**
 * Move the window such that given time is centered on screen.
 * @param {Date | Number | String} time
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Core.prototype.moveTo = function (time, options) {
  var interval = this.range.end - this.range.start;
  var t = util.convert(time, 'Date').valueOf();

  var start = t - interval / 2;
  var end = t + interval / 2;
  var animation = options && options.animation !== undefined ? options.animation : true;

  this.range.setRange(start, end, animation);
};

/**
 * Get the visible window
 * @return {{start: Date, end: Date}}   Visible range
 */
Core.prototype.getWindow = function () {
  var range = this.range.getRange();
  return {
    start: new Date(range.start),
    end: new Date(range.end)
  };
};

/**
 * Force a redraw. Can be overridden by implementations of Core
 *
 * Note: this function will be overridden on construction with a trottled version
 */
Core.prototype.redraw = function () {
  this._redraw();
};

/**
 * Redraw for internal use. Redraws all components. See also the public
 * method redraw.
 * @protected
 */
Core.prototype._redraw = function () {
  var resized = false;
  var options = this.options;
  var props = this.props;
  var dom = this.dom;

  if (!dom) return; // when destroyed

  DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);

  // update class names
  if (options.orientation == 'top') {
    util.addClassName(dom.root, 'vis-top');
    util.removeClassName(dom.root, 'vis-bottom');
  } else {
    util.removeClassName(dom.root, 'vis-top');
    util.addClassName(dom.root, 'vis-bottom');
  }

  // update root width and height options
  dom.root.style.maxHeight = util.option.asSize(options.maxHeight, '');
  dom.root.style.minHeight = util.option.asSize(options.minHeight, '');
  dom.root.style.width = util.option.asSize(options.width, '');

  // calculate border widths
  props.border.left = (dom.centerContainer.offsetWidth - dom.centerContainer.clientWidth) / 2;
  props.border.right = props.border.left;
  props.border.top = (dom.centerContainer.offsetHeight - dom.centerContainer.clientHeight) / 2;
  props.border.bottom = props.border.top;
  var borderRootHeight = dom.root.offsetHeight - dom.root.clientHeight;
  var borderRootWidth = dom.root.offsetWidth - dom.root.clientWidth;

  // workaround for a bug in IE: the clientWidth of an element with
  // a height:0px and overflow:hidden is not calculated and always has value 0
  if (dom.centerContainer.clientHeight === 0) {
    props.border.left = props.border.top;
    props.border.right = props.border.left;
  }
  if (dom.root.clientHeight === 0) {
    borderRootWidth = borderRootHeight;
  }

  // calculate the heights. If any of the side panels is empty, we set the height to
  // minus the border width, such that the border will be invisible
  props.center.height = dom.center.offsetHeight;
  props.left.height = dom.left.offsetHeight;
  props.right.height = dom.right.offsetHeight;
  props.top.height = dom.top.clientHeight || -props.border.top;
  props.bottom.height = dom.bottom.clientHeight || -props.border.bottom;

  // TODO: compensate borders when any of the panels is empty.

  // apply auto height
  // TODO: only calculate autoHeight when needed (else we cause an extra reflow/repaint of the DOM)
  var contentHeight = Math.max(props.left.height, props.center.height, props.right.height);
  var autoHeight = props.top.height + contentHeight + props.bottom.height + borderRootHeight + props.border.top + props.border.bottom;
  dom.root.style.height = util.option.asSize(options.height, autoHeight + 'px');

  // calculate heights of the content panels
  props.root.height = dom.root.offsetHeight;
  props.background.height = props.root.height - borderRootHeight;
  var containerHeight = props.root.height - props.top.height - props.bottom.height - borderRootHeight;
  props.centerContainer.height = containerHeight;
  props.leftContainer.height = containerHeight;
  props.rightContainer.height = props.leftContainer.height;

  // calculate the widths of the panels
  props.root.width = dom.root.offsetWidth;
  props.background.width = props.root.width - borderRootWidth;
  props.left.width = dom.leftContainer.clientWidth || -props.border.left;
  props.leftContainer.width = props.left.width;
  props.right.width = dom.rightContainer.clientWidth || -props.border.right;
  props.rightContainer.width = props.right.width;
  var centerWidth = props.root.width - props.left.width - props.right.width - borderRootWidth;
  props.center.width = centerWidth;
  props.centerContainer.width = centerWidth;
  props.top.width = centerWidth;
  props.bottom.width = centerWidth;

  // resize the panels
  dom.background.style.height = props.background.height + 'px';
  dom.backgroundVertical.style.height = props.background.height + 'px';
  dom.backgroundHorizontal.style.height = props.centerContainer.height + 'px';
  dom.centerContainer.style.height = props.centerContainer.height + 'px';
  dom.leftContainer.style.height = props.leftContainer.height + 'px';
  dom.rightContainer.style.height = props.rightContainer.height + 'px';

  dom.background.style.width = props.background.width + 'px';
  dom.backgroundVertical.style.width = props.centerContainer.width + 'px';
  dom.backgroundHorizontal.style.width = props.background.width + 'px';
  dom.centerContainer.style.width = props.center.width + 'px';
  dom.top.style.width = props.top.width + 'px';
  dom.bottom.style.width = props.bottom.width + 'px';

  // reposition the panels
  dom.background.style.left = '0';
  dom.background.style.top = '0';
  dom.backgroundVertical.style.left = props.left.width + props.border.left + 'px';
  dom.backgroundVertical.style.top = '0';
  dom.backgroundHorizontal.style.left = '0';
  dom.backgroundHorizontal.style.top = props.top.height + 'px';
  dom.centerContainer.style.left = props.left.width + 'px';
  dom.centerContainer.style.top = props.top.height + 'px';
  dom.leftContainer.style.left = '0';
  dom.leftContainer.style.top = props.top.height + 'px';
  dom.rightContainer.style.left = props.left.width + props.center.width + 'px';
  dom.rightContainer.style.top = props.top.height + 'px';
  dom.top.style.left = props.left.width + 'px';
  dom.top.style.top = '0';
  dom.bottom.style.left = props.left.width + 'px';
  dom.bottom.style.top = props.top.height + props.centerContainer.height + 'px';

  // update the scrollTop, feasible range for the offset can be changed
  // when the height of the Core or of the contents of the center changed
  this._updateScrollTop();

  // reposition the scrollable contents
  var offset = this.props.scrollTop;
  if (options.orientation.item != 'top') {
    offset += Math.max(this.props.centerContainer.height - this.props.center.height - this.props.border.top - this.props.border.bottom, 0);
  }
  dom.center.style.left = '0';
  dom.center.style.top = offset + 'px';
  dom.left.style.left = '0';
  dom.left.style.top = offset + 'px';
  dom.right.style.left = '0';
  dom.right.style.top = offset + 'px';

  // show shadows when vertical scrolling is available
  var visibilityTop = this.props.scrollTop == 0 ? 'hidden' : '';
  var visibilityBottom = this.props.scrollTop == this.props.scrollTopMin ? 'hidden' : '';
  dom.shadowTop.style.visibility = visibilityTop;
  dom.shadowBottom.style.visibility = visibilityBottom;
  dom.shadowTopLeft.style.visibility = visibilityTop;
  dom.shadowBottomLeft.style.visibility = visibilityBottom;
  dom.shadowTopRight.style.visibility = visibilityTop;
  dom.shadowBottomRight.style.visibility = visibilityBottom;

  // redraw all components
  this.components.forEach(function (component) {
    resized = component.redraw() || resized;
  });
  if (resized) {
    // keep repainting until all sizes are settled
    var MAX_REDRAWS = 3; // maximum number of consecutive redraws
    if (this.redrawCount < MAX_REDRAWS) {
      this.redrawCount++;
      this._redraw();
    } else {
      console.log('WARNING: infinite loop in redraw?');
    }
    this.redrawCount = 0;
  }
};

// TODO: deprecated since version 1.1.0, remove some day
Core.prototype.repaint = function () {
  throw new Error('Function repaint is deprecated. Use redraw instead.');
};

/**
 * Set a current time. This can be used for example to ensure that a client's
 * time is synchronized with a shared server time.
 * Only applicable when option `showCurrentTime` is true.
 * @param {Date | String | Number} time     A Date, unix timestamp, or
 *                                          ISO date string.
 */
Core.prototype.setCurrentTime = function (time) {
  if (!this.currentTime) {
    throw new Error('Option showCurrentTime must be true');
  }

  this.currentTime.setCurrentTime(time);
};

/**
 * Get the current time.
 * Only applicable when option `showCurrentTime` is true.
 * @return {Date} Returns the current time.
 */
Core.prototype.getCurrentTime = function () {
  if (!this.currentTime) {
    throw new Error('Option showCurrentTime must be true');
  }

  return this.currentTime.getCurrentTime();
};

/**
 * Convert a position on screen (pixels) to a datetime
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toTime = function (x) {
  return DateUtil.toTime(this, x, this.props.center.width);
};

/**
 * Convert a position on the global screen (pixels) to a datetime
 * @param {int}     x    Position on the screen in pixels
 * @return {Date}   time The datetime the corresponds with given position x
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toGlobalTime = function (x) {
  return DateUtil.toTime(this, x, this.props.root.width);
  //var conversion = this.range.conversion(this.props.root.width);
  //return new Date(x / conversion.scale + conversion.offset);
};

/**
 * Convert a datetime (Date object) into a position on the screen
 * @param {Date}   time A date
 * @return {int}   x    The position on the screen in pixels which corresponds
 *                      with the given date.
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toScreen = function (time) {
  return DateUtil.toScreen(this, time, this.props.center.width);
};

/**
 * Convert a datetime (Date object) into a position on the root
 * This is used to get the pixel density estimate for the screen, not the center panel
 * @param {Date}   time A date
 * @return {int}   x    The position on root in pixels which corresponds
 *                      with the given date.
 * @protected
 */
// TODO: move this function to Range
Core.prototype._toGlobalScreen = function (time) {
  return DateUtil.toScreen(this, time, this.props.root.width);
  //var conversion = this.range.conversion(this.props.root.width);
  //return (time.valueOf() - conversion.offset) * conversion.scale;
};

/**
 * Initialize watching when option autoResize is true
 * @private
 */
Core.prototype._initAutoResize = function () {
  if (this.options.autoResize == true) {
    this._startAutoResize();
  } else {
    this._stopAutoResize();
  }
};

/**
 * Watch for changes in the size of the container. On resize, the Panel will
 * automatically redraw itself.
 * @private
 */
Core.prototype._startAutoResize = function () {
  var me = this;

  this._stopAutoResize();

  this._onResize = function () {
    if (me.options.autoResize != true) {
      // stop watching when the option autoResize is changed to false
      me._stopAutoResize();
      return;
    }

    if (me.dom.root) {
      // check whether the frame is resized
      // Note: we compare offsetWidth here, not clientWidth. For some reason,
      // IE does not restore the clientWidth from 0 to the actual width after
      // changing the timeline's container display style from none to visible
      if (me.dom.root.offsetWidth != me.props.lastWidth || me.dom.root.offsetHeight != me.props.lastHeight) {
        me.props.lastWidth = me.dom.root.offsetWidth;
        me.props.lastHeight = me.dom.root.offsetHeight;

        me.emit('change');
      }
    }
  };

  // add event listener to window resize
  util.addEventListener(window, 'resize', this._onResize);

  this.watchTimer = setInterval(this._onResize, 1000);
};

/**
 * Stop watching for a resize of the frame.
 * @private
 */
Core.prototype._stopAutoResize = function () {
  if (this.watchTimer) {
    clearInterval(this.watchTimer);
    this.watchTimer = undefined;
  }

  // remove event listener on window.resize
  if (this._onResize) {
    util.removeEventListener(window, 'resize', this._onResize);
    this._onResize = null;
  }
};

/**
 * Start moving the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onTouch = function (event) {
  this.touch.allowDragging = true;
  this.touch.initialScrollTop = this.props.scrollTop;
};

/**
 * Start moving the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onPinch = function (event) {
  this.touch.allowDragging = false;
};

/**
 * Move the timeline vertically
 * @param {Event} event
 * @private
 */
Core.prototype._onDrag = function (event) {
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.touch.allowDragging) return;

  var delta = event.deltaY;

  var oldScrollTop = this._getScrollTop();
  var newScrollTop = this._setScrollTop(this.touch.initialScrollTop + delta);

  if (newScrollTop != oldScrollTop) {
    this._redraw(); // TODO: this causes two redraws when dragging, the other is triggered by rangechange already
    this.emit("verticalDrag");
  }
};

/**
 * Apply a scrollTop
 * @param {Number} scrollTop
 * @returns {Number} scrollTop  Returns the applied scrollTop
 * @private
 */
Core.prototype._setScrollTop = function (scrollTop) {
  this.props.scrollTop = scrollTop;
  this._updateScrollTop();
  return this.props.scrollTop;
};

/**
 * Update the current scrollTop when the height of  the containers has been changed
 * @returns {Number} scrollTop  Returns the applied scrollTop
 * @private
 */
Core.prototype._updateScrollTop = function () {
  // recalculate the scrollTopMin
  var scrollTopMin = Math.min(this.props.centerContainer.height - this.props.center.height, 0); // is negative or zero
  if (scrollTopMin != this.props.scrollTopMin) {
    // in case of bottom orientation, change the scrollTop such that the contents
    // do not move relative to the time axis at the bottom
    if (this.options.orientation.item != 'top') {
      this.props.scrollTop += scrollTopMin - this.props.scrollTopMin;
    }
    this.props.scrollTopMin = scrollTopMin;
  }

  // limit the scrollTop to the feasible scroll range
  if (this.props.scrollTop > 0) this.props.scrollTop = 0;
  if (this.props.scrollTop < scrollTopMin) this.props.scrollTop = scrollTopMin;

  return this.props.scrollTop;
};

/**
 * Get the current scrollTop
 * @returns {number} scrollTop
 * @private
 */
Core.prototype._getScrollTop = function () {
  return this.props.scrollTop;
};

/**
 * Load a configurator
 * @return {Object}
 * @private
 */
Core.prototype._createConfigurator = function () {
  throw new Error('Cannot invoke abstract method _createConfigurator');
};

module.exports = Core;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9Db3JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDM0MsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDekMsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzFDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUM5QixJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDcEMsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3RDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUMvQixJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUM3QyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUMvQyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUMvQyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDckMsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUM7Ozs7OztBQU1uRCxTQUFTLElBQUksR0FBSSxFQUFFOzs7QUFHbkIsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQzs7Ozs7Ozs7O0FBU3hCLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFVBQVUsU0FBUyxFQUFFO0FBQzVDLE1BQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDOztBQUVkLE1BQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQzs7QUFFL0IsTUFBSSxDQUFDLEdB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QVMsSUFBSyxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEFBQUMsQ0FBQztLQUNsRTtBQUNELFFBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztHQUN4Qzs7O0FBR0QsTUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZELE1BQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsWUFBWSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLFlBQVksQ0FBQzs7QUFFN0UsU0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztDQUM3QixDQUFDOzs7Ozs7O0FBT0YsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsWUFBWTtBQUN6QyxTQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDO0NBQzdCLENBQUM7Ozs7Ozs7QUFPRixJQUFJLENBQUMsU0FBUyxDQUFDLG1CQUFtQixHQUFHLFlBQVk7QUFDL0MsUUFBTSxJQUFJLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO0NBQ3RFLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL0NvcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2VtaXR0ZXItY29tcG9uZW50Jyk7XG52YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIGhhbW1lclV0aWwgPSByZXF1aXJlKCcuLi9oYW1tZXJVdGlsJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBEYXRhU2V0ID0gcmVxdWlyZSgnLi4vRGF0YVNldCcpO1xudmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi4vRGF0YVZpZXcnKTtcbnZhciBSYW5nZSA9IHJlcXVpcmUoJy4vUmFuZ2UnKTtcbnZhciBJdGVtU2V0ID0gcmVxdWlyZSgnLi9jb21wb25lbnQvSXRlbVNldCcpO1xudmFyIFRpbWVBeGlzID0gcmVxdWlyZSgnLi9jb21wb25lbnQvVGltZUF4aXMnKTtcbnZhciBBY3RpdmF0b3IgPSByZXF1aXJlKCcuLi9zaGFyZWQvQWN0aXZhdG9yJyk7XG52YXIgRGF0ZVV0aWwgPSByZXF1aXJlKCcuL0RhdGVVdGlsJyk7XG52YXIgQ3VzdG9tVGltZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50L0N1c3RvbVRpbWUnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSB0aW1lbGluZSB2aXN1YWxpemF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29yZSAoKSB7fVxuXG4vLyB0dXJuIENvcmUgaW50byBhbiBldmVudCBlbWl0dGVyXG5FbWl0dGVyKENvcmUucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIG1haW4gRE9NIGZvciB0aGUgQ29yZTogYSByb290IHBhbmVsIGNvbnRhaW5pbmcgbGVmdCwgcmlnaHQsXG4gKiB0b3AsIGJvdHRvbSwgY29udGVudCwgYW5kIGJhY2tncm91bmQgcGFuZWwuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgVGhlIGNvbnRhaW5lciBlbGVtZW50IHdoZXJlIHRoZSBDb3JlIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBhdHRhY2hlZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29yZS5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgdGhpcy5kb20gPSB7fTtcblxuICB0aGlzLmRvbS5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgdGhpcy5kb20ucm9vdCAgICAgICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uYmFja2dyb3VuZCAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uYmFja2dyb3VuZFZlcnRpY2FsICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uYmFja2dyb3VuZEhvcml6b250YWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20ubGVmdENvbnRhaW5lciAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20ucmlnaHRDb250YWluZXIgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uY2VudGVyICAgICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20ubGVmdCAgICAgICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20ucmlnaHQgICAgICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20udG9wICAgICAgICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uYm90dG9tICAgICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uc2hhZG93VG9wICAgICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uc2hhZG93Qm90dG9tICAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uc2hhZG93VG9wTGVmdCAgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uc2hhZG93Qm90dG9tTGVmdCAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uc2hhZG93VG9wUmlnaHQgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uc2hhZG93Qm90dG9tUmlnaHQgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICB0aGlzLmRvbS5yb290LmNsYXNzTmFtZSAgICAgICAgICAgICAgICAgPSAndmlzLXRpbWVsaW5lJztcbiAgdGhpcy5kb20uYmFja2dyb3VuZC5jbGFzc05hbWUgICAgICAgICAgID0gJ3Zpcy1wYW5lbCB2aXMtYmFja2dyb3VuZCc7XG4gIHRoaXMuZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5jbGFzc05hbWUgICA9ICd2aXMtcGFuZWwgdmlzLWJhY2tncm91bmQgdmlzLXZlcnRpY2FsJztcbiAgdGhpcy5kb20uYmFja2dyb3VuZEhvcml6b250YWwuY2xhc3NOYW1lID0gJ3Zpcy1wYW5lbCB2aXMtYmFja2dyb3VuZCB2aXMtaG9yaXpvbnRhbCc7XG4gIHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lci5jbGFzc05hbWUgICAgICA9ICd2aXMtcGFuZWwgdmlzLWNlbnRlcic7XG4gIHRoaXMuZG9tLmxlZnRDb250YWluZXIuY2xhc3NOYW1lICAgICAgICA9ICd2aXMtcGFuZWwgdmlzLWxlZnQnO1xuICB0aGlzLmRvbS5yaWdodENvbnRhaW5lci5jbGFzc05hbWUgICAgICAgPSAndmlzLXBhbmVsIHZpcy1yaWdodCc7XG4gIHRoaXMuZG9tLnRvcC5jbGFzc05hbWUgICAgICAgICAgICAgICAgICA9ICd2aXMtcGFuZWwgdmlzLXRvcCc7XG4gIHRoaXMuZG9tLmJvdHRvbS5jbGFzc05hbWUgICAgICAgICAgICAgICA9ICd2aXMtcGFuZWwgdmlzLWJvdHRvbSc7XG4gIHRoaXMuZG9tLmxlZnQuY2xhc3NOYW1lICAgICAgICAgICAgICAgICA9ICd2aXMtY29udGVudCc7XG4gIHRoaXMuZG9tLmNlbnRlci5jbGFzc05hbWUgICAgICAgICAgICAgICA9ICd2aXMtY29udGVudCc7XG4gIHRoaXMuZG9tLnJpZ2h0LmNsYXNzTmFtZSAgICAgICAgICAgICAgICA9ICd2aXMtY29udGVudCc7XG4gIHRoaXMuZG9tLnNoYWRvd1RvcC5jbGFzc05hbWUgICAgICAgICAgICA9ICd2aXMtc2hhZG93IHZpcy10b3AnO1xuICB0aGlzLmRvbS5zaGFkb3dCb3R0b20uY2xhc3NOYW1lICAgICAgICAgPSAndmlzLXNoYWRvdyB2aXMtYm90dG9tJztcbiAgdGhpcy5kb20uc2hhZG93VG9wTGVmdC5jbGFzc05hbWUgICAgICAgID0gJ3Zpcy1zaGFkb3cgdmlzLXRvcCc7XG4gIHRoaXMuZG9tLnNoYWRvd0JvdHRvbUxlZnQuY2xhc3NOYW1lICAgICA9ICd2aXMtc2hhZG93IHZpcy1ib3R0b20nO1xuICB0aGlzLmRvbS5zaGFkb3dUb3BSaWdodC5jbGFzc05hbWUgICAgICAgPSAndmlzLXNoYWRvdyB2aXMtdG9wJztcbiAgdGhpcy5kb20uc2hhZG93Qm90dG9tUmlnaHQuY2xhc3NOYW1lICAgID0gJ3Zpcy1zaGFkb3cgdmlzLWJvdHRvbSc7XG5cbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kKTtcbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kVmVydGljYWwpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmRIb3Jpem9udGFsKTtcbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5jZW50ZXJDb250YWluZXIpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmxlZnRDb250YWluZXIpO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyKTtcbiAgdGhpcy5kb20ucm9vdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS50b3ApO1xuICB0aGlzLmRvbS5yb290LmFwcGVuZENoaWxkKHRoaXMuZG9tLmJvdHRvbSk7XG5cbiAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLmNlbnRlcik7XG4gIHRoaXMuZG9tLmxlZnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ubGVmdCk7XG4gIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnJpZ2h0KTtcblxuICB0aGlzLmRvbS5jZW50ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93VG9wKTtcbiAgdGhpcy5kb20uY2VudGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd0JvdHRvbSk7XG4gIHRoaXMuZG9tLmxlZnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93VG9wTGVmdCk7XG4gIHRoaXMuZG9tLmxlZnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93Qm90dG9tTGVmdCk7XG4gIHRoaXMuZG9tLnJpZ2h0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZG9tLnNoYWRvd1RvcFJpZ2h0KTtcbiAgdGhpcy5kb20ucmlnaHRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20uc2hhZG93Qm90dG9tUmlnaHQpO1xuXG4gIHRoaXMub24oJ3JhbmdlY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlZHJhdygpOyAvLyB0aGlzIGFsbG93cyBvdmVycmlkaW5nIHRoZSBfcmVkcmF3IG1ldGhvZFxuICB9LmJpbmQodGhpcykpO1xuICB0aGlzLm9uKCd0b3VjaCcsICAgICAgIHRoaXMuX29uVG91Y2guYmluZCh0aGlzKSk7XG4gIHRoaXMub24oJ3BhbicsICAgICAgICAgdGhpcy5fb25EcmFnLmJpbmQodGhpcykpO1xuXG4gIHZhciBtZSA9IHRoaXM7XG4gIHRoaXMub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHByb3BlcnRpZXMgJiYgcHJvcGVydGllcy5xdWV1ZSA9PSB0cnVlKSB7XG4gICAgICAvLyByZWRyYXcgb25jZSBvbiBuZXh0IHRpY2tcbiAgICAgIGlmICghbWUuX3JlZHJhd1RpbWVyKSB7XG4gICAgICAgIG1lLl9yZWRyYXdUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lLl9yZWRyYXdUaW1lciA9IG51bGw7XG4gICAgICAgICAgbWUuX3JlZHJhdygpO1xuICAgICAgICB9LCAwKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHJlZHJhdyBpbW1lZGlhdGVseVxuICAgICAgbWUuX3JlZHJhdygpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gY3JlYXRlIGV2ZW50IGxpc3RlbmVycyBmb3IgYWxsIGludGVyZXN0aW5nIGV2ZW50cywgdGhlc2UgZXZlbnRzIHdpbGwgYmVcbiAgLy8gZW1pdHRlZCB2aWEgZW1pdHRlclxuICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5kb20ucm9vdCk7XG4gIHRoaXMuaGFtbWVyLmdldCgncGluY2gnKS5zZXQoe2VuYWJsZTogdHJ1ZX0pO1xuICB0aGlzLmhhbW1lci5nZXQoJ3BhbicpLnNldCh7dGhyZXNob2xkOjUsIGRpcmVjdGlvbjozMH0pOyAvLyAzMCBpcyBBTExfRElSRUNUSU9OUyBpbiBoYW1tZXIuXG4gIHRoaXMubGlzdGVuZXJzID0ge307XG5cbiAgdmFyIGV2ZW50cyA9IFtcbiAgICAndGFwJywgJ2RvdWJsZXRhcCcsICdwcmVzcycsXG4gICAgJ3BpbmNoJyxcbiAgICAncGFuJywgJ3BhbnN0YXJ0JywgJ3Bhbm1vdmUnLCAncGFuZW5kJ1xuICAgICAgLy8gVE9ETzogY2xlYW51cFxuICAgIC8vJ3RvdWNoJywgJ3BpbmNoJyxcbiAgICAvLyd0YXAnLCAnZG91YmxldGFwJywgJ2hvbGQnLFxuICAgIC8vJ2RyYWdzdGFydCcsICdkcmFnJywgJ2RyYWdlbmQnLFxuICAgIC8vJ21vdXNld2hlZWwnLCAnRE9NTW91c2VTY3JvbGwnIC8vIERPTU1vdXNlU2Nyb2xsIGlzIG5lZWRlZCBmb3IgRmlyZWZveFxuICBdO1xuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKG1lLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgbWUuZW1pdCh0eXBlLCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBtZS5oYW1tZXIub24odHlwZSwgbGlzdGVuZXIpO1xuICAgIG1lLmxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICB9KTtcblxuICAvLyBlbXVsYXRlIGEgdG91Y2ggZXZlbnQgKGVtaXR0ZWQgYmVmb3JlIHRoZSBzdGFydCBvZiBhIHBhbiwgcGluY2gsIHRhcCwgb3IgcHJlc3MpXG4gIGhhbW1lclV0aWwub25Ub3VjaCh0aGlzLmhhbW1lciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbWUuZW1pdCgndG91Y2gnLCBldmVudCk7XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgLy8gZW11bGF0ZSBhIHJlbGVhc2UgZXZlbnQgKGVtaXR0ZWQgYWZ0ZXIgYSBwYW4sIHBpbmNoLCB0YXAsIG9yIHByZXNzKVxuICBoYW1tZXJVdGlsLm9uUmVsZWFzZSh0aGlzLmhhbW1lciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgbWUuZW1pdCgncmVsZWFzZScsIGV2ZW50KTtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoZXZlbnQpIHtcbiAgICBpZiAobWUuaXNBY3RpdmUoKSkge1xuICAgICAgbWUuZW1pdCgnbW91c2V3aGVlbCcsIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgdGhpcy5kb20ucm9vdC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgb25Nb3VzZVdoZWVsKTtcbiAgdGhpcy5kb20ucm9vdC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIG9uTW91c2VXaGVlbCk7XG5cbiAgLy8gc2l6ZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2YgdGhlIHBhbmVsc1xuICB0aGlzLnByb3BzID0ge1xuICAgIHJvb3Q6IHt9LFxuICAgIGJhY2tncm91bmQ6IHt9LFxuICAgIGNlbnRlckNvbnRhaW5lcjoge30sXG4gICAgbGVmdENvbnRhaW5lcjoge30sXG4gICAgcmlnaHRDb250YWluZXI6IHt9LFxuICAgIGNlbnRlcjoge30sXG4gICAgbGVmdDoge30sXG4gICAgcmlnaHQ6IHt9LFxuICAgIHRvcDoge30sXG4gICAgYm90dG9tOiB7fSxcbiAgICBib3JkZXI6IHt9LFxuICAgIHNjcm9sbFRvcDogMCxcbiAgICBzY3JvbGxUb3BNaW46IDBcbiAgfTtcblxuICB0aGlzLmN1c3RvbVRpbWVzID0gW107XG5cbiAgLy8gc3RvcmUgc3RhdGUgaW5mb3JtYXRpb24gbmVlZGVkIGZvciB0b3VjaCBldmVudHNcbiAgdGhpcy50b3VjaCA9IHt9O1xuXG4gIHRoaXMucmVkcmF3Q291bnQgPSAwO1xuXG4gIC8vIGF0dGFjaCB0aGUgcm9vdCBwYW5lbCB0byB0aGUgcHJvdmlkZWQgY29udGFpbmVyXG4gIGlmICghY29udGFpbmVyKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRhaW5lciBwcm92aWRlZCcpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb20ucm9vdCk7XG59O1xuXG4vKipcbiAqIFNldCBvcHRpb25zLiBPcHRpb25zIHdpbGwgYmUgcGFzc2VkIHRvIGFsbCBjb21wb25lbnRzIGxvYWRlZCBpbiB0aGUgVGltZWxpbmUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG9yaWVudGF0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2FsIG9yaWVudGF0aW9uIGZvciB0aGUgVGltZWxpbmUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbiBiZSAnYm90dG9tJyAoZGVmYXVsdCkgb3IgJ3RvcCcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IHdpZHRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdpZHRoIGZvciB0aGUgdGltZWxpbmUsIGEgbnVtYmVyIGluIHBpeGVscyBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGNzcyBzdHJpbmcgbGlrZSAnMTAwMHB4JyBvciAnNzUlJy4gJzEwMCUnIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IGhlaWdodFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXhlZCBoZWlnaHQgZm9yIHRoZSBUaW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgY3NzIHN0cmluZyBsaWtlICc0MDBweCcgb3IgJzc1JScuIElmIHVuZGVmaW5lZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIFRpbWVsaW5lIHdpbGwgYXV0b21hdGljYWxseSBzaXplIHN1Y2ggdGhhdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdHMgY29udGVudHMgZml0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nIHwgTnVtYmVyfSBtaW5IZWlnaHRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWluaW11bSBoZWlnaHQgZm9yIHRoZSBUaW1lbGluZSwgYSBudW1iZXIgaW4gcGl4ZWxzIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgY3NzIHN0cmluZyBsaWtlICc0MDBweCcgb3IgJzc1JScuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmcgfCBOdW1iZXJ9IG1heEhlaWdodFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXhpbXVtIGhlaWdodCBmb3IgdGhlIFRpbWVsaW5lLCBhIG51bWJlciBpbiBwaXhlbHMgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBjc3Mgc3RyaW5nIGxpa2UgJzQwMHB4JyBvciAnNzUlJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlciB8IERhdGUgfCBTdHJpbmd9IHN0YXJ0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0YXJ0IGRhdGUgZm9yIHRoZSB2aXNpYmxlIHdpbmRvd1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyIHwgRGF0ZSB8IFN0cmluZ30gZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZCBkYXRlIGZvciB0aGUgdmlzaWJsZSB3aW5kb3dcbiAqL1xuQ29yZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgLy8gY29weSB0aGUga25vd24gb3B0aW9uc1xuICAgIHZhciBmaWVsZHMgPSBbXG4gICAgICAnd2lkdGgnLCAnaGVpZ2h0JywgJ21pbkhlaWdodCcsICdtYXhIZWlnaHQnLCAnYXV0b1Jlc2l6ZScsXG4gICAgICAnc3RhcnQnLCAnZW5kJywgJ2NsaWNrVG9Vc2UnLCAnZGF0YUF0dHJpYnV0ZXMnLCAnaGlkZGVuRGF0ZXMnLFxuICAgICAgJ2xvY2FsZScsICdsb2NhbGVzJywgJ21vbWVudCcsXG4gICAgICAndGhyb3R0bGVSZWRyYXcnXG4gICAgXTtcbiAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ29yaWVudGF0aW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9IHtcbiAgICAgICAgICBpdGVtOiBvcHRpb25zLm9yaWVudGF0aW9uLFxuICAgICAgICAgIGF4aXM6IG9wdGlvbnMub3JpZW50YXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoJ2l0ZW0nIGluIG9wdGlvbnMub3JpZW50YXRpb24pIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9IG9wdGlvbnMub3JpZW50YXRpb24uaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2F4aXMnIGluIG9wdGlvbnMub3JpZW50YXRpb24pIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyA9IG9wdGlvbnMub3JpZW50YXRpb24uYXhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyA9PT0gJ2JvdGgnKSB7XG4gICAgICBpZiAoIXRoaXMudGltZUF4aXMyKSB7XG4gICAgICAgIHZhciB0aW1lQXhpczIgPSB0aGlzLnRpbWVBeGlzMiA9IG5ldyBUaW1lQXhpcyh0aGlzLmJvZHkpO1xuICAgICAgICB0aW1lQXhpczIuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyA/IHV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zKSA6IHt9O1xuICAgICAgICAgIF9vcHRpb25zLm9yaWVudGF0aW9uID0gJ3RvcCc7IC8vIG92ZXJyaWRlIHRoZSBvcmllbnRhdGlvbiBvcHRpb24sIGFsd2F5cyB0b3BcbiAgICAgICAgICBUaW1lQXhpcy5wcm90b3R5cGUuc2V0T3B0aW9ucy5jYWxsKHRpbWVBeGlzMiwgX29wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaCh0aW1lQXhpczIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnRpbWVBeGlzMikge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbXBvbmVudHMuaW5kZXhPZih0aGlzLnRpbWVBeGlzMik7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVBeGlzMi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudGltZUF4aXMyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgZ3JhcGgyZCdzIGRyYXdQb2ludHMgaXMgYSBmdW5jdGlvbiBkZWxlZ2F0ZSB0aGUgY2FsbGJhY2sgdG8gdGhlIG9uUmVuZGVyIHByb3BlcnR5XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRyYXdQb2ludHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0aW9ucy5kcmF3UG9pbnRzID0ge1xuICAgICAgICAgIG9uUmVuZGVyOiBvcHRpb25zLmRyYXdQb2ludHNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCdoaWRkZW5EYXRlcycgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICBEYXRlVXRpbC5jb252ZXJ0SGlkZGVuT3B0aW9ucyh0aGlzLm9wdGlvbnMubW9tZW50LCB0aGlzLmJvZHksIHRoaXMub3B0aW9ucy5oaWRkZW5EYXRlcyk7XG4gICAgfVxuXG4gICAgaWYgKCdjbGlja1RvVXNlJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5jbGlja1RvVXNlKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmF0b3IpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRvciA9IG5ldyBBY3RpdmF0b3IodGhpcy5kb20ucm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0b3IpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRvci5kZXN0cm95KCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuYWN0aXZhdG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCdzaG93Q3VzdG9tVGltZScgaW4gb3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gYHNob3dDdXN0b21UaW1lYCBpcyBkZXByZWNhdGVkLiBDcmVhdGUgYSBjdXN0b20gdGltZSBiYXIgdmlhIHRpbWVsaW5lLmFkZEN1c3RvbVRpbWUodGltZSBbLCBpZF0pJyk7XG4gICAgfVxuXG4gICAgLy8gZW5hYmxlL2Rpc2FibGUgYXV0b1Jlc2l6ZVxuICAgIHRoaXMuX2luaXRBdXRvUmVzaXplKCk7XG4gIH1cblxuICAvLyBwcm9wYWdhdGUgb3B0aW9ucyB0byBhbGwgY29tcG9uZW50c1xuICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChjb21wb25lbnQgPT4gY29tcG9uZW50LnNldE9wdGlvbnMob3B0aW9ucykpO1xuXG4gIC8vIGVuYWJsZS9kaXNhYmxlIGNvbmZpZ3VyZVxuICBpZiAoJ2NvbmZpZ3VyZScgaW4gb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jb25maWd1cmF0b3IpIHtcbiAgICAgIHRoaXMuY29uZmlndXJhdG9yID0gdGhpcy5fY3JlYXRlQ29uZmlndXJhdG9yKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0T3B0aW9ucyhvcHRpb25zLmNvbmZpZ3VyZSk7XG5cbiAgICAvLyBjb2xsZWN0IHRoZSBzZXR0aW5ncyBvZiBhbGwgY29tcG9uZW50cywgYW5kIHBhc3MgdGhlbSB0byB0aGUgY29uZmlndXJhdGlvbiBzeXN0ZW1cbiAgICB2YXIgYXBwbGllZE9wdGlvbnMgPSB1dGlsLmRlZXBFeHRlbmQoe30sIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgdXRpbC5kZWVwRXh0ZW5kKGFwcGxpZWRPcHRpb25zLCBjb21wb25lbnQub3B0aW9ucyk7XG4gICAgfSk7XG4gICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0TW9kdWxlT3B0aW9ucyh7Z2xvYmFsOiBhcHBsaWVkT3B0aW9uc30pO1xuICB9XG5cbiAgLy8gb3ZlcnJpZGUgcmVkcmF3IHdpdGggYSB0aHJvdHRsZWQgdmVyc2lvblxuICBpZiAoIXRoaXMuX29yaWdSZWRyYXcpIHtcbiAgICB0aGlzLl9vcmlnUmVkcmF3ID0gdGhpcy5fcmVkcmF3LmJpbmQodGhpcyk7XG4gIH1cbiAgdGhpcy5fcmVkcmF3ID0gdXRpbC50aHJvdHRsZSh0aGlzLl9vcmlnUmVkcmF3LCB0aGlzLm9wdGlvbnMudGhyb3R0bGVSZWRyYXcpO1xuXG4gIC8vIHJlZHJhdyBldmVyeXRoaW5nXG4gIHRoaXMuX3JlZHJhdygpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgVGltZWxpbmUgaXMgYWN0aXZlLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkNvcmUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIXRoaXMuYWN0aXZhdG9yIHx8IHRoaXMuYWN0aXZhdG9yLmFjdGl2ZTtcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgQ29yZSwgY2xlYW4gdXAgYWxsIERPTSBlbGVtZW50cyBhbmQgZXZlbnQgbGlzdGVuZXJzLlxuICovXG5Db3JlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAvLyB1bmJpbmQgZGF0YXNldHNcbiAgdGhpcy5zZXRJdGVtcyhudWxsKTtcbiAgdGhpcy5zZXRHcm91cHMobnVsbCk7XG5cbiAgLy8gcmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgdGhpcy5vZmYoKTtcblxuICAvLyBzdG9wIGNoZWNraW5nIGZvciBjaGFuZ2VkIHNpemVcbiAgdGhpcy5fc3RvcEF1dG9SZXNpemUoKTtcblxuICAvLyByZW1vdmUgZnJvbSBET01cbiAgaWYgKHRoaXMuZG9tLnJvb3QucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLnJvb3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5yb290KTtcbiAgfVxuICB0aGlzLmRvbSA9IG51bGw7XG5cbiAgLy8gcmVtb3ZlIEFjdGl2YXRvclxuICBpZiAodGhpcy5hY3RpdmF0b3IpIHtcbiAgICB0aGlzLmFjdGl2YXRvci5kZXN0cm95KCk7XG4gICAgZGVsZXRlIHRoaXMuYWN0aXZhdG9yO1xuICB9XG5cbiAgLy8gY2xlYW51cCBoYW1tZXIgdG91Y2ggZXZlbnRzXG4gIGZvciAodmFyIGV2ZW50IGluIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICB9XG4gIH1cbiAgdGhpcy5saXN0ZW5lcnMgPSBudWxsO1xuICB0aGlzLmhhbW1lciA9IG51bGw7XG5cbiAgLy8gZ2l2ZSBhbGwgY29tcG9uZW50cyB0aGUgb3Bwb3J0dW5pdHkgdG8gY2xlYW51cFxuICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChjb21wb25lbnQgPT4gY29tcG9uZW50LmRlc3Ryb3koKSk7XG5cbiAgdGhpcy5ib2R5ID0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBTZXQgYSBjdXN0b20gdGltZSBiYXJcbiAqIEBwYXJhbSB7RGF0ZX0gdGltZVxuICogQHBhcmFtIHtudW1iZXJ9IFtpZD11bmRlZmluZWRdIE9wdGlvbmFsIGlkIG9mIHRoZSBjdXN0b20gdGltZSBiYXIgdG8gYmUgYWRqdXN0ZWQuXG4gKi9cbkNvcmUucHJvdG90eXBlLnNldEN1c3RvbVRpbWUgPSBmdW5jdGlvbiAodGltZSwgaWQpIHtcbiAgdmFyIGN1c3RvbVRpbWVzID0gdGhpcy5jdXN0b21UaW1lcy5maWx0ZXIoZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBpZCA9PT0gY29tcG9uZW50Lm9wdGlvbnMuaWQ7XG4gIH0pO1xuXG4gIGlmIChjdXN0b21UaW1lcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGN1c3RvbSB0aW1lIGJhciBmb3VuZCB3aXRoIGlkICcgKyBKU09OLnN0cmluZ2lmeShpZCkpXG4gIH1cblxuICBpZiAoY3VzdG9tVGltZXMubGVuZ3RoID4gMCkge1xuICAgIGN1c3RvbVRpbWVzWzBdLnNldEN1c3RvbVRpbWUodGltZSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgY3VzdG9tIHRpbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2lkPXVuZGVmaW5lZF0gICAgSWQgb2YgdGhlIGN1c3RvbSB0aW1lIGJhci5cbiAqIEByZXR1cm4ge0RhdGUgfCB1bmRlZmluZWR9IGN1c3RvbVRpbWVcbiAqL1xuQ29yZS5wcm90b3R5cGUuZ2V0Q3VzdG9tVGltZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBjdXN0b21UaW1lcyA9IHRoaXMuY3VzdG9tVGltZXMuZmlsdGVyKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY29tcG9uZW50Lm9wdGlvbnMuaWQgPT09IGlkO1xuICB9KTtcblxuICBpZiAoY3VzdG9tVGltZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBjdXN0b20gdGltZSBiYXIgZm91bmQgd2l0aCBpZCAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKVxuICB9XG4gIHJldHVybiBjdXN0b21UaW1lc1swXS5nZXRDdXN0b21UaW1lKCk7XG59O1xuXG4vKipcbiAqIFNldCBhIGN1c3RvbSB0aXRsZSBmb3IgdGhlIGN1c3RvbSB0aW1lIGJhci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbdGl0bGVdIEN1c3RvbSB0aXRsZVxuICogQHBhcmFtIHtudW1iZXJ9IFtpZD11bmRlZmluZWRdICAgIElkIG9mIHRoZSBjdXN0b20gdGltZSBiYXIuXG4gKi9cbkNvcmUucHJvdG90eXBlLnNldEN1c3RvbVRpbWVUaXRsZSA9IGZ1bmN0aW9uKHRpdGxlLCBpZCkge1xuICB2YXIgY3VzdG9tVGltZXMgPSB0aGlzLmN1c3RvbVRpbWVzLmZpbHRlcihmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5vcHRpb25zLmlkID09PSBpZDtcbiAgfSk7XG5cbiAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY3VzdG9tIHRpbWUgYmFyIGZvdW5kIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSlcbiAgfVxuICBpZiAoY3VzdG9tVGltZXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjdXN0b21UaW1lc1swXS5zZXRDdXN0b21UaXRsZSh0aXRsZSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmUgbWV0YSBpbmZvcm1hdGlvbiBmcm9tIGFuIGV2ZW50LlxuICogU2hvdWxkIGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgQ29yZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggcmVsYXRlZCBpbmZvcm1hdGlvbi5cbiAqL1xuQ29yZS5wcm90b3R5cGUuZ2V0RXZlbnRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJldHVybiB7IGV2ZW50OiBldmVudCB9O1xufTtcblxuLyoqXG4gKiBBZGQgY3VzdG9tIHZlcnRpY2FsIGJhclxuICogQHBhcmFtIHtEYXRlIHwgU3RyaW5nIHwgTnVtYmVyfSBbdGltZV0gIEEgRGF0ZSwgdW5peCB0aW1lc3RhbXAsIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSVNPIGRhdGUgc3RyaW5nLiBUaW1lIHBvaW50IHdoZXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ldyBiYXIgc2hvdWxkIGJlIHBsYWNlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QgcHJvdmlkZWQsIGBuZXcgRGF0ZSgpYCB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgdXNlZC5cbiAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nfSBbaWQ9dW5kZWZpbmVkXSBJZCBvZiB0aGUgbmV3IGJhci4gT3B0aW9uYWxcbiAqIEByZXR1cm4ge051bWJlciB8IFN0cmluZ30gICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgbmV3IGJhclxuICovXG5Db3JlLnByb3RvdHlwZS5hZGRDdXN0b21UaW1lID0gZnVuY3Rpb24gKHRpbWUsIGlkKSB7XG4gIHZhciB0aW1lc3RhbXAgPSB0aW1lICE9PSB1bmRlZmluZWRcbiAgICAgID8gdXRpbC5jb252ZXJ0KHRpbWUsICdEYXRlJykudmFsdWVPZigpXG4gICAgICA6IG5ldyBEYXRlKCk7XG5cbiAgdmFyIGV4aXN0cyA9IHRoaXMuY3VzdG9tVGltZXMuc29tZShmdW5jdGlvbiAoY3VzdG9tVGltZSkge1xuICAgIHJldHVybiBjdXN0b21UaW1lLm9wdGlvbnMuaWQgPT09IGlkO1xuICB9KTtcbiAgaWYgKGV4aXN0cykge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBjdXN0b20gdGltZSB3aXRoIGlkICcgKyBKU09OLnN0cmluZ2lmeShpZCkgKyAnIGFscmVhZHkgZXhpc3RzJyk7XG4gIH1cblxuICB2YXIgY3VzdG9tVGltZSA9IG5ldyBDdXN0b21UaW1lKHRoaXMuYm9keSwgdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywge1xuICAgIHRpbWUgOiB0aW1lc3RhbXAsXG4gICAgaWQgOiBpZFxuICB9KSk7XG5cbiAgdGhpcy5jdXN0b21UaW1lcy5wdXNoKGN1c3RvbVRpbWUpO1xuICB0aGlzLmNvbXBvbmVudHMucHVzaChjdXN0b21UaW1lKTtcbiAgdGhpcy5fcmVkcmF3KCk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgcHJldmlvdXNseSBhZGRlZCBjdXN0b20gYmFyXG4gKiBAcGFyYW0ge2ludH0gaWQgSUQgb2YgdGhlIGN1c3RvbSBiYXIgdG8gYmUgcmVtb3ZlZFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYmFyIGV4aXN0cyBhbmQgaXMgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkNvcmUucHJvdG90eXBlLnJlbW92ZUN1c3RvbVRpbWUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGN1c3RvbVRpbWVzID0gdGhpcy5jdXN0b21UaW1lcy5maWx0ZXIoZnVuY3Rpb24gKGJhcikge1xuICAgIHJldHVybiAoYmFyLm9wdGlvbnMuaWQgPT09IGlkKTtcbiAgfSk7XG5cbiAgaWYgKGN1c3RvbVRpbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gY3VzdG9tIHRpbWUgYmFyIGZvdW5kIHdpdGggaWQgJyArIEpTT04uc3RyaW5naWZ5KGlkKSlcbiAgfVxuXG4gIGN1c3RvbVRpbWVzLmZvckVhY2goZnVuY3Rpb24gKGN1c3RvbVRpbWUpIHtcbiAgICB0aGlzLmN1c3RvbVRpbWVzLnNwbGljZSh0aGlzLmN1c3RvbVRpbWVzLmluZGV4T2YoY3VzdG9tVGltZSksIDEpO1xuICAgIHRoaXMuY29tcG9uZW50cy5zcGxpY2UodGhpcy5jb21wb25lbnRzLmluZGV4T2YoY3VzdG9tVGltZSksIDEpO1xuICAgIGN1c3RvbVRpbWUuZGVzdHJveSgpO1xuICB9LmJpbmQodGhpcykpXG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBpZCdzIG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBpdGVtcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGlkcyBvZiB0aGUgdmlzaWJsZSBpdGVtc1xuICovXG5Db3JlLnByb3RvdHlwZS5nZXRWaXNpYmxlSXRlbXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXRlbVNldCAmJiB0aGlzLml0ZW1TZXQuZ2V0VmlzaWJsZUl0ZW1zKCkgfHwgW107XG59O1xuXG4vKipcbiAqIFNldCBDb3JlIHdpbmRvdyBzdWNoIHRoYXQgaXQgZml0cyBhbGwgaXRlbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAqL1xuQ29yZS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgcmFuZ2UgPSB0aGlzLmdldERhdGFSYW5nZSgpO1xuXG4gIC8vIHNraXAgcmFuZ2Ugc2V0IGlmIHRoZXJlIGlzIG5vIG1pbiBhbmQgbWF4IGRhdGVcbiAgaWYgKHJhbmdlLm1pbiA9PT0gbnVsbCAmJiByYW5nZS5tYXggPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhcHBseSBhIG1hcmdpbiBvZiAxJSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgZGF0YVxuICB2YXIgaW50ZXJ2YWwgPSByYW5nZS5tYXggLSByYW5nZS5taW47XG4gIHZhciBtaW4gPSBuZXcgRGF0ZShyYW5nZS5taW4udmFsdWVPZigpIC0gaW50ZXJ2YWwgKiAwLjAxKTtcbiAgdmFyIG1heCA9IG5ldyBEYXRlKHJhbmdlLm1heC52YWx1ZU9mKCkgKyBpbnRlcnZhbCAqIDAuMDEpO1xuXG4gIHZhciBhbmltYXRpb24gPSAob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuYW5pbWF0aW9uIDogdHJ1ZTtcbiAgdGhpcy5yYW5nZS5zZXRSYW5nZShtaW4sIG1heCwgYW5pbWF0aW9uKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBkYXRhIHJhbmdlIG9mIHRoZSBpdGVtcyBzdGFydCBhbmQgZW5kIGRhdGVzXG4gKiBAcmV0dXJucyB7e21pbjogRGF0ZSB8IG51bGwsIG1heDogRGF0ZSB8IG51bGx9fVxuICogQHByb3RlY3RlZFxuICovXG5Db3JlLnByb3RvdHlwZS5nZXREYXRhUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgLy8gbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBUaW1lbGluZSBhbmQgR3JhcGgyZFxuICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZva2UgYWJzdHJhY3QgbWV0aG9kIGdldERhdGFSYW5nZScpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHZpc2libGUgd2luZG93LiBCb3RoIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLCB5b3UgY2FuIGNoYW5nZSBvbmx5XG4gKiBzdGFydCBvciBvbmx5IGVuZC4gU3ludGF4OlxuICpcbiAqICAgICBUaW1lTGluZS5zZXRXaW5kb3coc3RhcnQsIGVuZClcbiAqICAgICBUaW1lTGluZS5zZXRXaW5kb3coc3RhcnQsIGVuZCwgb3B0aW9ucylcbiAqICAgICBUaW1lTGluZS5zZXRXaW5kb3cocmFuZ2UpXG4gKlxuICogV2hlcmUgc3RhcnQgYW5kIGVuZCBjYW4gYmUgYSBEYXRlLCBudW1iZXIsIG9yIHN0cmluZywgYW5kIHJhbmdlIGlzIGFuXG4gKiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHN0YXJ0IGFuZCBlbmQuXG4gKlxuICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nIHwgT2JqZWN0fSBbc3RhcnRdIFN0YXJ0IGRhdGUgb2YgdmlzaWJsZSB3aW5kb3dcbiAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZ30gW2VuZF0gICAgICAgICAgICBFbmQgZGF0ZSBvZiB2aXNpYmxlIHdpbmRvd1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICovXG5Db3JlLnByb3RvdHlwZS5zZXRXaW5kb3cgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBvcHRpb25zKSB7XG4gIHZhciBhbmltYXRpb247XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICB2YXIgcmFuZ2UgPSBhcmd1bWVudHNbMF07XG4gICAgYW5pbWF0aW9uID0gKHJhbmdlLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkKSA/IHJhbmdlLmFuaW1hdGlvbiA6IHRydWU7XG4gICAgdGhpcy5yYW5nZS5zZXRSYW5nZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBhbmltYXRpb24pO1xuICB9XG4gIGVsc2Uge1xuICAgIGFuaW1hdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuICAgIHRoaXMucmFuZ2Uuc2V0UmFuZ2Uoc3RhcnQsIGVuZCwgYW5pbWF0aW9uKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNb3ZlIHRoZSB3aW5kb3cgc3VjaCB0aGF0IGdpdmVuIHRpbWUgaXMgY2VudGVyZWQgb24gc2NyZWVuLlxuICogQHBhcmFtIHtEYXRlIHwgTnVtYmVyIHwgU3RyaW5nfSB0aW1lXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYW5pbWF0aW9uOiBib29sZWFuIHwge2R1cmF0aW9uOiBudW1iZXIsIGVhc2luZ0Z1bmN0aW9uOiBzdHJpbmd9YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIChkZWZhdWx0KSwgdGhlIHJhbmdlIGlzIGFuaW1hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtb290aGx5IHRvIHRoZSBuZXcgd2luZG93LiBBbiBvYmplY3QgY2FuIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkIHRvIHNwZWNpZnkgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBkdXJhdGlvbiBpcyA1MDAgbXMsIGFuZCBkZWZhdWx0IGVhc2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpcyAnZWFzZUluT3V0UXVhZCcuXG4gKi9cbkNvcmUucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uKHRpbWUsIG9wdGlvbnMpIHtcbiAgdmFyIGludGVydmFsID0gdGhpcy5yYW5nZS5lbmQgLSB0aGlzLnJhbmdlLnN0YXJ0O1xuICB2YXIgdCA9IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpLnZhbHVlT2YoKTtcblxuICB2YXIgc3RhcnQgPSB0IC0gaW50ZXJ2YWwgLyAyO1xuICB2YXIgZW5kID0gdCArIGludGVydmFsIC8gMjtcbiAgdmFyIGFuaW1hdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuXG4gIHRoaXMucmFuZ2Uuc2V0UmFuZ2Uoc3RhcnQsIGVuZCwgYW5pbWF0aW9uKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2aXNpYmxlIHdpbmRvd1xuICogQHJldHVybiB7e3N0YXJ0OiBEYXRlLCBlbmQ6IERhdGV9fSAgIFZpc2libGUgcmFuZ2VcbiAqL1xuQ29yZS5wcm90b3R5cGUuZ2V0V2luZG93ID0gZnVuY3Rpb24oKSB7XG4gIHZhciByYW5nZSA9IHRoaXMucmFuZ2UuZ2V0UmFuZ2UoKTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogbmV3IERhdGUocmFuZ2Uuc3RhcnQpLFxuICAgIGVuZDogbmV3IERhdGUocmFuZ2UuZW5kKVxuICB9O1xufTtcblxuLyoqXG4gKiBGb3JjZSBhIHJlZHJhdy4gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgaW1wbGVtZW50YXRpb25zIG9mIENvcmVcbiAqXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgb3ZlcnJpZGRlbiBvbiBjb25zdHJ1Y3Rpb24gd2l0aCBhIHRyb3R0bGVkIHZlcnNpb25cbiAqL1xuQ29yZS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3JlZHJhdygpO1xufTtcblxuLyoqXG4gKiBSZWRyYXcgZm9yIGludGVybmFsIHVzZS4gUmVkcmF3cyBhbGwgY29tcG9uZW50cy4gU2VlIGFsc28gdGhlIHB1YmxpY1xuICogbWV0aG9kIHJlZHJhdy5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29yZS5wcm90b3R5cGUuX3JlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzaXplZCA9IGZhbHNlO1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuXG4gIGlmICghZG9tKSByZXR1cm47IC8vIHdoZW4gZGVzdHJveWVkXG5cbiAgRGF0ZVV0aWwudXBkYXRlSGlkZGVuRGF0ZXModGhpcy5vcHRpb25zLm1vbWVudCwgdGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMuaGlkZGVuRGF0ZXMpO1xuXG4gIC8vIHVwZGF0ZSBjbGFzcyBuYW1lc1xuICBpZiAob3B0aW9ucy5vcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKGRvbS5yb290LCAndmlzLXRvcCcpO1xuICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKGRvbS5yb290LCAndmlzLWJvdHRvbScpO1xuICB9XG4gIGVsc2Uge1xuICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKGRvbS5yb290LCAndmlzLXRvcCcpO1xuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKGRvbS5yb290LCAndmlzLWJvdHRvbScpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHJvb3Qgd2lkdGggYW5kIGhlaWdodCBvcHRpb25zXG4gIGRvbS5yb290LnN0eWxlLm1heEhlaWdodCA9IHV0aWwub3B0aW9uLmFzU2l6ZShvcHRpb25zLm1heEhlaWdodCwgJycpO1xuICBkb20ucm9vdC5zdHlsZS5taW5IZWlnaHQgPSB1dGlsLm9wdGlvbi5hc1NpemUob3B0aW9ucy5taW5IZWlnaHQsICcnKTtcbiAgZG9tLnJvb3Quc3R5bGUud2lkdGggPSB1dGlsLm9wdGlvbi5hc1NpemUob3B0aW9ucy53aWR0aCwgJycpO1xuXG4gIC8vIGNhbGN1bGF0ZSBib3JkZXIgd2lkdGhzXG4gIHByb3BzLmJvcmRlci5sZWZ0ICAgPSAoZG9tLmNlbnRlckNvbnRhaW5lci5vZmZzZXRXaWR0aCAtIGRvbS5jZW50ZXJDb250YWluZXIuY2xpZW50V2lkdGgpIC8gMjtcbiAgcHJvcHMuYm9yZGVyLnJpZ2h0ICA9IHByb3BzLmJvcmRlci5sZWZ0O1xuICBwcm9wcy5ib3JkZXIudG9wICAgID0gKGRvbS5jZW50ZXJDb250YWluZXIub2Zmc2V0SGVpZ2h0IC0gZG9tLmNlbnRlckNvbnRhaW5lci5jbGllbnRIZWlnaHQpIC8gMjtcbiAgcHJvcHMuYm9yZGVyLmJvdHRvbSA9IHByb3BzLmJvcmRlci50b3A7XG4gIHZhciBib3JkZXJSb290SGVpZ2h0PSBkb20ucm9vdC5vZmZzZXRIZWlnaHQgLSBkb20ucm9vdC5jbGllbnRIZWlnaHQ7XG4gIHZhciBib3JkZXJSb290V2lkdGggPSBkb20ucm9vdC5vZmZzZXRXaWR0aCAtIGRvbS5yb290LmNsaWVudFdpZHRoO1xuXG4gIC8vIHdvcmthcm91bmQgZm9yIGEgYnVnIGluIElFOiB0aGUgY2xpZW50V2lkdGggb2YgYW4gZWxlbWVudCB3aXRoXG4gIC8vIGEgaGVpZ2h0OjBweCBhbmQgb3ZlcmZsb3c6aGlkZGVuIGlzIG5vdCBjYWxjdWxhdGVkIGFuZCBhbHdheXMgaGFzIHZhbHVlIDBcbiAgaWYgKGRvbS5jZW50ZXJDb250YWluZXIuY2xpZW50SGVpZ2h0ID09PSAwKSB7XG4gICAgcHJvcHMuYm9yZGVyLmxlZnQgPSBwcm9wcy5ib3JkZXIudG9wO1xuICAgIHByb3BzLmJvcmRlci5yaWdodCAgPSBwcm9wcy5ib3JkZXIubGVmdDtcbiAgfVxuICBpZiAoZG9tLnJvb3QuY2xpZW50SGVpZ2h0ID09PSAwKSB7XG4gICAgYm9yZGVyUm9vdFdpZHRoID0gYm9yZGVyUm9vdEhlaWdodDtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0cy4gSWYgYW55IG9mIHRoZSBzaWRlIHBhbmVscyBpcyBlbXB0eSwgd2Ugc2V0IHRoZSBoZWlnaHQgdG9cbiAgLy8gbWludXMgdGhlIGJvcmRlciB3aWR0aCwgc3VjaCB0aGF0IHRoZSBib3JkZXIgd2lsbCBiZSBpbnZpc2libGVcbiAgcHJvcHMuY2VudGVyLmhlaWdodCA9IGRvbS5jZW50ZXIub2Zmc2V0SGVpZ2h0O1xuICBwcm9wcy5sZWZ0LmhlaWdodCAgID0gZG9tLmxlZnQub2Zmc2V0SGVpZ2h0O1xuICBwcm9wcy5yaWdodC5oZWlnaHQgID0gZG9tLnJpZ2h0Lm9mZnNldEhlaWdodDtcbiAgcHJvcHMudG9wLmhlaWdodCAgICA9IGRvbS50b3AuY2xpZW50SGVpZ2h0ICAgIHx8IC1wcm9wcy5ib3JkZXIudG9wO1xuICBwcm9wcy5ib3R0b20uaGVpZ2h0ID0gZG9tLmJvdHRvbS5jbGllbnRIZWlnaHQgfHwgLXByb3BzLmJvcmRlci5ib3R0b207XG5cbiAgLy8gVE9ETzogY29tcGVuc2F0ZSBib3JkZXJzIHdoZW4gYW55IG9mIHRoZSBwYW5lbHMgaXMgZW1wdHkuXG5cbiAgLy8gYXBwbHkgYXV0byBoZWlnaHRcbiAgLy8gVE9ETzogb25seSBjYWxjdWxhdGUgYXV0b0hlaWdodCB3aGVuIG5lZWRlZCAoZWxzZSB3ZSBjYXVzZSBhbiBleHRyYSByZWZsb3cvcmVwYWludCBvZiB0aGUgRE9NKVxuICB2YXIgY29udGVudEhlaWdodCA9IE1hdGgubWF4KHByb3BzLmxlZnQuaGVpZ2h0LCBwcm9wcy5jZW50ZXIuaGVpZ2h0LCBwcm9wcy5yaWdodC5oZWlnaHQpO1xuICB2YXIgYXV0b0hlaWdodCA9IHByb3BzLnRvcC5oZWlnaHQgKyBjb250ZW50SGVpZ2h0ICsgcHJvcHMuYm90dG9tLmhlaWdodCArXG4gICAgYm9yZGVyUm9vdEhlaWdodCArIHByb3BzLmJvcmRlci50b3AgKyBwcm9wcy5ib3JkZXIuYm90dG9tO1xuICBkb20ucm9vdC5zdHlsZS5oZWlnaHQgPSB1dGlsLm9wdGlvbi5hc1NpemUob3B0aW9ucy5oZWlnaHQsIGF1dG9IZWlnaHQgKyAncHgnKTtcblxuICAvLyBjYWxjdWxhdGUgaGVpZ2h0cyBvZiB0aGUgY29udGVudCBwYW5lbHNcbiAgcHJvcHMucm9vdC5oZWlnaHQgPSBkb20ucm9vdC5vZmZzZXRIZWlnaHQ7XG4gIHByb3BzLmJhY2tncm91bmQuaGVpZ2h0ID0gcHJvcHMucm9vdC5oZWlnaHQgLSBib3JkZXJSb290SGVpZ2h0O1xuICB2YXIgY29udGFpbmVySGVpZ2h0ID0gcHJvcHMucm9vdC5oZWlnaHQgLSBwcm9wcy50b3AuaGVpZ2h0IC0gcHJvcHMuYm90dG9tLmhlaWdodCAtXG4gICAgYm9yZGVyUm9vdEhlaWdodDtcbiAgcHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCAgPSBjb250YWluZXJIZWlnaHQ7XG4gIHByb3BzLmxlZnRDb250YWluZXIuaGVpZ2h0ICAgID0gY29udGFpbmVySGVpZ2h0O1xuICBwcm9wcy5yaWdodENvbnRhaW5lci5oZWlnaHQgICA9IHByb3BzLmxlZnRDb250YWluZXIuaGVpZ2h0O1xuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgd2lkdGhzIG9mIHRoZSBwYW5lbHNcbiAgcHJvcHMucm9vdC53aWR0aCA9IGRvbS5yb290Lm9mZnNldFdpZHRoO1xuICBwcm9wcy5iYWNrZ3JvdW5kLndpZHRoID0gcHJvcHMucm9vdC53aWR0aCAtIGJvcmRlclJvb3RXaWR0aDtcbiAgcHJvcHMubGVmdC53aWR0aCA9IGRvbS5sZWZ0Q29udGFpbmVyLmNsaWVudFdpZHRoICAgfHwgLXByb3BzLmJvcmRlci5sZWZ0O1xuICBwcm9wcy5sZWZ0Q29udGFpbmVyLndpZHRoID0gcHJvcHMubGVmdC53aWR0aDtcbiAgcHJvcHMucmlnaHQud2lkdGggPSBkb20ucmlnaHRDb250YWluZXIuY2xpZW50V2lkdGggfHwgLXByb3BzLmJvcmRlci5yaWdodDtcbiAgcHJvcHMucmlnaHRDb250YWluZXIud2lkdGggPSBwcm9wcy5yaWdodC53aWR0aDtcbiAgdmFyIGNlbnRlcldpZHRoID0gcHJvcHMucm9vdC53aWR0aCAtIHByb3BzLmxlZnQud2lkdGggLSBwcm9wcy5yaWdodC53aWR0aCAtIGJvcmRlclJvb3RXaWR0aDtcbiAgcHJvcHMuY2VudGVyLndpZHRoICAgICAgICAgID0gY2VudGVyV2lkdGg7XG4gIHByb3BzLmNlbnRlckNvbnRhaW5lci53aWR0aCA9IGNlbnRlcldpZHRoO1xuICBwcm9wcy50b3Aud2lkdGggICAgICAgICAgICAgPSBjZW50ZXJXaWR0aDtcbiAgcHJvcHMuYm90dG9tLndpZHRoICAgICAgICAgID0gY2VudGVyV2lkdGg7XG5cbiAgLy8gcmVzaXplIHRoZSBwYW5lbHNcbiAgZG9tLmJhY2tncm91bmQuc3R5bGUuaGVpZ2h0ICAgICAgICAgICA9IHByb3BzLmJhY2tncm91bmQuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5zdHlsZS5oZWlnaHQgICA9IHByb3BzLmJhY2tncm91bmQuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLmJhY2tncm91bmRIb3Jpem9udGFsLnN0eWxlLmhlaWdodCA9IHByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuICBkb20uY2VudGVyQ29udGFpbmVyLnN0eWxlLmhlaWdodCAgICAgID0gcHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCArICdweCc7XG4gIGRvbS5sZWZ0Q29udGFpbmVyLnN0eWxlLmhlaWdodCAgICAgICAgPSBwcm9wcy5sZWZ0Q29udGFpbmVyLmhlaWdodCArICdweCc7XG4gIGRvbS5yaWdodENvbnRhaW5lci5zdHlsZS5oZWlnaHQgICAgICAgPSBwcm9wcy5yaWdodENvbnRhaW5lci5oZWlnaHQgKyAncHgnO1xuXG4gIGRvbS5iYWNrZ3JvdW5kLnN0eWxlLndpZHRoICAgICAgICAgICAgPSBwcm9wcy5iYWNrZ3JvdW5kLndpZHRoICsgJ3B4JztcbiAgZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5zdHlsZS53aWR0aCAgICA9IHByb3BzLmNlbnRlckNvbnRhaW5lci53aWR0aCArICdweCc7XG4gIGRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5zdHlsZS53aWR0aCAgPSBwcm9wcy5iYWNrZ3JvdW5kLndpZHRoICsgJ3B4JztcbiAgZG9tLmNlbnRlckNvbnRhaW5lci5zdHlsZS53aWR0aCAgICAgICA9IHByb3BzLmNlbnRlci53aWR0aCArICdweCc7XG4gIGRvbS50b3Auc3R5bGUud2lkdGggICAgICAgICAgICAgICAgICAgPSBwcm9wcy50b3Aud2lkdGggKyAncHgnO1xuICBkb20uYm90dG9tLnN0eWxlLndpZHRoICAgICAgICAgICAgICAgID0gcHJvcHMuYm90dG9tLndpZHRoICsgJ3B4JztcblxuICAvLyByZXBvc2l0aW9uIHRoZSBwYW5lbHNcbiAgZG9tLmJhY2tncm91bmQuc3R5bGUubGVmdCAgICAgICAgICAgPSAnMCc7XG4gIGRvbS5iYWNrZ3JvdW5kLnN0eWxlLnRvcCAgICAgICAgICAgID0gJzAnO1xuICBkb20uYmFja2dyb3VuZFZlcnRpY2FsLnN0eWxlLmxlZnQgICA9IChwcm9wcy5sZWZ0LndpZHRoICsgcHJvcHMuYm9yZGVyLmxlZnQpICsgJ3B4JztcbiAgZG9tLmJhY2tncm91bmRWZXJ0aWNhbC5zdHlsZS50b3AgICAgPSAnMCc7XG4gIGRvbS5iYWNrZ3JvdW5kSG9yaXpvbnRhbC5zdHlsZS5sZWZ0ID0gJzAnO1xuICBkb20uYmFja2dyb3VuZEhvcml6b250YWwuc3R5bGUudG9wICA9IHByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICBkb20uY2VudGVyQ29udGFpbmVyLnN0eWxlLmxlZnQgICAgICA9IHByb3BzLmxlZnQud2lkdGggKyAncHgnO1xuICBkb20uY2VudGVyQ29udGFpbmVyLnN0eWxlLnRvcCAgICAgICA9IHByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICBkb20ubGVmdENvbnRhaW5lci5zdHlsZS5sZWZ0ICAgICAgICA9ICcwJztcbiAgZG9tLmxlZnRDb250YWluZXIuc3R5bGUudG9wICAgICAgICAgPSBwcm9wcy50b3AuaGVpZ2h0ICsgJ3B4JztcbiAgZG9tLnJpZ2h0Q29udGFpbmVyLnN0eWxlLmxlZnQgICAgICAgPSAocHJvcHMubGVmdC53aWR0aCArIHByb3BzLmNlbnRlci53aWR0aCkgKyAncHgnO1xuICBkb20ucmlnaHRDb250YWluZXIuc3R5bGUudG9wICAgICAgICA9IHByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICBkb20udG9wLnN0eWxlLmxlZnQgICAgICAgICAgICAgICAgICA9IHByb3BzLmxlZnQud2lkdGggKyAncHgnO1xuICBkb20udG9wLnN0eWxlLnRvcCAgICAgICAgICAgICAgICAgICA9ICcwJztcbiAgZG9tLmJvdHRvbS5zdHlsZS5sZWZ0ICAgICAgICAgICAgICAgPSBwcm9wcy5sZWZ0LndpZHRoICsgJ3B4JztcbiAgZG9tLmJvdHRvbS5zdHlsZS50b3AgICAgICAgICAgICAgICAgPSAocHJvcHMudG9wLmhlaWdodCArIHByb3BzLmNlbnRlckNvbnRhaW5lci5oZWlnaHQpICsgJ3B4JztcblxuICAvLyB1cGRhdGUgdGhlIHNjcm9sbFRvcCwgZmVhc2libGUgcmFuZ2UgZm9yIHRoZSBvZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgLy8gd2hlbiB0aGUgaGVpZ2h0IG9mIHRoZSBDb3JlIG9yIG9mIHRoZSBjb250ZW50cyBvZiB0aGUgY2VudGVyIGNoYW5nZWRcbiAgdGhpcy5fdXBkYXRlU2Nyb2xsVG9wKCk7XG5cbiAgLy8gcmVwb3NpdGlvbiB0aGUgc2Nyb2xsYWJsZSBjb250ZW50c1xuICB2YXIgb2Zmc2V0ID0gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG4gIGlmIChvcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gIT0gJ3RvcCcpIHtcbiAgICBvZmZzZXQgKz0gTWF0aC5tYXgodGhpcy5wcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0IC0gdGhpcy5wcm9wcy5jZW50ZXIuaGVpZ2h0IC1cbiAgICAgIHRoaXMucHJvcHMuYm9yZGVyLnRvcCAtIHRoaXMucHJvcHMuYm9yZGVyLmJvdHRvbSwgMCk7XG4gIH1cbiAgZG9tLmNlbnRlci5zdHlsZS5sZWZ0ID0gJzAnO1xuICBkb20uY2VudGVyLnN0eWxlLnRvcCAgPSBvZmZzZXQgKyAncHgnO1xuICBkb20ubGVmdC5zdHlsZS5sZWZ0ICAgPSAnMCc7XG4gIGRvbS5sZWZ0LnN0eWxlLnRvcCAgICA9IG9mZnNldCArICdweCc7XG4gIGRvbS5yaWdodC5zdHlsZS5sZWZ0ICA9ICcwJztcbiAgZG9tLnJpZ2h0LnN0eWxlLnRvcCAgID0gb2Zmc2V0ICsgJ3B4JztcblxuICAvLyBzaG93IHNoYWRvd3Mgd2hlbiB2ZXJ0aWNhbCBzY3JvbGxpbmcgaXMgYXZhaWxhYmxlXG4gIHZhciB2aXNpYmlsaXR5VG9wID0gdGhpcy5wcm9wcy5zY3JvbGxUb3AgPT0gMCA/ICdoaWRkZW4nIDogJyc7XG4gIHZhciB2aXNpYmlsaXR5Qm90dG9tID0gdGhpcy5wcm9wcy5zY3JvbGxUb3AgPT0gdGhpcy5wcm9wcy5zY3JvbGxUb3BNaW4gPyAnaGlkZGVuJyA6ICcnO1xuICBkb20uc2hhZG93VG9wLnN0eWxlLnZpc2liaWxpdHkgICAgICAgICAgPSB2aXNpYmlsaXR5VG9wO1xuICBkb20uc2hhZG93Qm90dG9tLnN0eWxlLnZpc2liaWxpdHkgICAgICAgPSB2aXNpYmlsaXR5Qm90dG9tO1xuICBkb20uc2hhZG93VG9wTGVmdC5zdHlsZS52aXNpYmlsaXR5ICAgICAgPSB2aXNpYmlsaXR5VG9wO1xuICBkb20uc2hhZG93Qm90dG9tTGVmdC5zdHlsZS52aXNpYmlsaXR5ICAgPSB2aXNpYmlsaXR5Qm90dG9tO1xuICBkb20uc2hhZG93VG9wUmlnaHQuc3R5bGUudmlzaWJpbGl0eSAgICAgPSB2aXNpYmlsaXR5VG9wO1xuICBkb20uc2hhZG93Qm90dG9tUmlnaHQuc3R5bGUudmlzaWJpbGl0eSAgPSB2aXNpYmlsaXR5Qm90dG9tO1xuXG4gIC8vIHJlZHJhdyBhbGwgY29tcG9uZW50c1xuICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgcmVzaXplZCA9IGNvbXBvbmVudC5yZWRyYXcoKSB8fCByZXNpemVkO1xuICB9KTtcbiAgaWYgKHJlc2l6ZWQpIHtcbiAgICAvLyBrZWVwIHJlcGFpbnRpbmcgdW50aWwgYWxsIHNpemVzIGFyZSBzZXR0bGVkXG4gICAgdmFyIE1BWF9SRURSQVdTID0gMzsgLy8gbWF4aW11bSBudW1iZXIgb2YgY29uc2VjdXRpdmUgcmVkcmF3c1xuICAgIGlmICh0aGlzLnJlZHJhd0NvdW50IDwgTUFYX1JFRFJBV1MpIHtcbiAgICAgIHRoaXMucmVkcmF3Q291bnQrKztcbiAgICAgIHRoaXMuX3JlZHJhdygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBpbmZpbml0ZSBsb29wIGluIHJlZHJhdz8nKTtcbiAgICB9XG4gICAgdGhpcy5yZWRyYXdDb3VudCA9IDA7XG4gIH1cbn07XG5cbi8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEuMCwgcmVtb3ZlIHNvbWUgZGF5XG5Db3JlLnByb3RvdHlwZS5yZXBhaW50ID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIHJlcGFpbnQgaXMgZGVwcmVjYXRlZC4gVXNlIHJlZHJhdyBpbnN0ZWFkLicpO1xufTtcblxuLyoqXG4gKiBTZXQgYSBjdXJyZW50IHRpbWUuIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGV4YW1wbGUgdG8gZW5zdXJlIHRoYXQgYSBjbGllbnQnc1xuICogdGltZSBpcyBzeW5jaHJvbml6ZWQgd2l0aCBhIHNoYXJlZCBzZXJ2ZXIgdGltZS5cbiAqIE9ubHkgYXBwbGljYWJsZSB3aGVuIG9wdGlvbiBgc2hvd0N1cnJlbnRUaW1lYCBpcyB0cnVlLlxuICogQHBhcmFtIHtEYXRlIHwgU3RyaW5nIHwgTnVtYmVyfSB0aW1lICAgICBBIERhdGUsIHVuaXggdGltZXN0YW1wLCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJU08gZGF0ZSBzdHJpbmcuXG4gKi9cbkNvcmUucHJvdG90eXBlLnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24odGltZSkge1xuICBpZiAoIXRoaXMuY3VycmVudFRpbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBzaG93Q3VycmVudFRpbWUgbXVzdCBiZSB0cnVlJyk7XG4gIH1cblxuICB0aGlzLmN1cnJlbnRUaW1lLnNldEN1cnJlbnRUaW1lKHRpbWUpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdGltZS5cbiAqIE9ubHkgYXBwbGljYWJsZSB3aGVuIG9wdGlvbiBgc2hvd0N1cnJlbnRUaW1lYCBpcyB0cnVlLlxuICogQHJldHVybiB7RGF0ZX0gUmV0dXJucyB0aGUgY3VycmVudCB0aW1lLlxuICovXG5Db3JlLnByb3RvdHlwZS5nZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY3VycmVudFRpbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBzaG93Q3VycmVudFRpbWUgbXVzdCBiZSB0cnVlJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJyZW50VGltZS5nZXRDdXJyZW50VGltZSgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgcG9zaXRpb24gb24gc2NyZWVuIChwaXhlbHMpIHRvIGEgZGF0ZXRpbWVcbiAqIEBwYXJhbSB7aW50fSAgICAgeCAgICBQb3NpdGlvbiBvbiB0aGUgc2NyZWVuIGluIHBpeGVsc1xuICogQHJldHVybiB7RGF0ZX0gICB0aW1lIFRoZSBkYXRldGltZSB0aGUgY29ycmVzcG9uZHMgd2l0aCBnaXZlbiBwb3NpdGlvbiB4XG4gKiBAcHJvdGVjdGVkXG4gKi9cbi8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiB0byBSYW5nZVxuQ29yZS5wcm90b3R5cGUuX3RvVGltZSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIERhdGVVdGlsLnRvVGltZSh0aGlzLCB4LCB0aGlzLnByb3BzLmNlbnRlci53aWR0aCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBwb3NpdGlvbiBvbiB0aGUgZ2xvYmFsIHNjcmVlbiAocGl4ZWxzKSB0byBhIGRhdGV0aW1lXG4gKiBAcGFyYW0ge2ludH0gICAgIHggICAgUG9zaXRpb24gb24gdGhlIHNjcmVlbiBpbiBwaXhlbHNcbiAqIEByZXR1cm4ge0RhdGV9ICAgdGltZSBUaGUgZGF0ZXRpbWUgdGhlIGNvcnJlc3BvbmRzIHdpdGggZ2l2ZW4gcG9zaXRpb24geFxuICogQHByb3RlY3RlZFxuICovXG4vLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gdG8gUmFuZ2VcbkNvcmUucHJvdG90eXBlLl90b0dsb2JhbFRpbWUgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBEYXRlVXRpbC50b1RpbWUodGhpcywgeCwgdGhpcy5wcm9wcy5yb290LndpZHRoKTtcbiAgLy92YXIgY29udmVyc2lvbiA9IHRoaXMucmFuZ2UuY29udmVyc2lvbih0aGlzLnByb3BzLnJvb3Qud2lkdGgpO1xuICAvL3JldHVybiBuZXcgRGF0ZSh4IC8gY29udmVyc2lvbi5zY2FsZSArIGNvbnZlcnNpb24ub2Zmc2V0KTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIGRhdGV0aW1lIChEYXRlIG9iamVjdCkgaW50byBhIHBvc2l0aW9uIG9uIHRoZSBzY3JlZW5cbiAqIEBwYXJhbSB7RGF0ZX0gICB0aW1lIEEgZGF0ZVxuICogQHJldHVybiB7aW50fSAgIHggICAgVGhlIHBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gaW4gcGl4ZWxzIHdoaWNoIGNvcnJlc3BvbmRzXG4gKiAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBnaXZlbiBkYXRlLlxuICogQHByb3RlY3RlZFxuICovXG4vLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gdG8gUmFuZ2VcbkNvcmUucHJvdG90eXBlLl90b1NjcmVlbiA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgcmV0dXJuIERhdGVVdGlsLnRvU2NyZWVuKHRoaXMsIHRpbWUsIHRoaXMucHJvcHMuY2VudGVyLndpZHRoKTtcbn07XG5cblxuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRldGltZSAoRGF0ZSBvYmplY3QpIGludG8gYSBwb3NpdGlvbiBvbiB0aGUgcm9vdFxuICogVGhpcyBpcyB1c2VkIHRvIGdldCB0aGUgcGl4ZWwgZGVuc2l0eSBlc3RpbWF0ZSBmb3IgdGhlIHNjcmVlbiwgbm90IHRoZSBjZW50ZXIgcGFuZWxcbiAqIEBwYXJhbSB7RGF0ZX0gICB0aW1lIEEgZGF0ZVxuICogQHJldHVybiB7aW50fSAgIHggICAgVGhlIHBvc2l0aW9uIG9uIHJvb3QgaW4gcGl4ZWxzIHdoaWNoIGNvcnJlc3BvbmRzXG4gKiAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBnaXZlbiBkYXRlLlxuICogQHByb3RlY3RlZFxuICovXG4vLyBUT0RPOiBtb3ZlIHRoaXMgZnVuY3Rpb24gdG8gUmFuZ2VcbkNvcmUucHJvdG90eXBlLl90b0dsb2JhbFNjcmVlbiA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgcmV0dXJuIERhdGVVdGlsLnRvU2NyZWVuKHRoaXMsIHRpbWUsIHRoaXMucHJvcHMucm9vdC53aWR0aCk7XG4gIC8vdmFyIGNvbnZlcnNpb24gPSB0aGlzLnJhbmdlLmNvbnZlcnNpb24odGhpcy5wcm9wcy5yb290LndpZHRoKTtcbiAgLy9yZXR1cm4gKHRpbWUudmFsdWVPZigpIC0gY29udmVyc2lvbi5vZmZzZXQpICogY29udmVyc2lvbi5zY2FsZTtcbn07XG5cblxuLyoqXG4gKiBJbml0aWFsaXplIHdhdGNoaW5nIHdoZW4gb3B0aW9uIGF1dG9SZXNpemUgaXMgdHJ1ZVxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX2luaXRBdXRvUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmF1dG9SZXNpemUgPT0gdHJ1ZSkge1xuICAgIHRoaXMuX3N0YXJ0QXV0b1Jlc2l6ZSgpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX3N0b3BBdXRvUmVzaXplKCk7XG4gIH1cbn07XG5cbi8qKlxuICogV2F0Y2ggZm9yIGNoYW5nZXMgaW4gdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lci4gT24gcmVzaXplLCB0aGUgUGFuZWwgd2lsbFxuICogYXV0b21hdGljYWxseSByZWRyYXcgaXRzZWxmLlxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX3N0YXJ0QXV0b1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICB0aGlzLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuXG4gIHRoaXMuX29uUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKG1lLm9wdGlvbnMuYXV0b1Jlc2l6ZSAhPSB0cnVlKSB7XG4gICAgICAvLyBzdG9wIHdhdGNoaW5nIHdoZW4gdGhlIG9wdGlvbiBhdXRvUmVzaXplIGlzIGNoYW5nZWQgdG8gZmFsc2VcbiAgICAgIG1lLl9zdG9wQXV0b1Jlc2l6ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtZS5kb20ucm9vdCkge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgZnJhbWUgaXMgcmVzaXplZFxuICAgICAgLy8gTm90ZTogd2UgY29tcGFyZSBvZmZzZXRXaWR0aCBoZXJlLCBub3QgY2xpZW50V2lkdGguIEZvciBzb21lIHJlYXNvbixcbiAgICAgIC8vIElFIGRvZXMgbm90IHJlc3RvcmUgdGhlIGNsaWVudFdpZHRoIGZyb20gMCB0byB0aGUgYWN0dWFsIHdpZHRoIGFmdGVyXG4gICAgICAvLyBjaGFuZ2luZyB0aGUgdGltZWxpbmUncyBjb250YWluZXIgZGlzcGxheSBzdHlsZSBmcm9tIG5vbmUgdG8gdmlzaWJsZVxuICAgICAgaWYgKChtZS5kb20ucm9vdC5vZmZzZXRXaWR0aCAhPSBtZS5wcm9wcy5sYXN0V2lkdGgpIHx8XG4gICAgICAgIChtZS5kb20ucm9vdC5vZmZzZXRIZWlnaHQgIT0gbWUucHJvcHMubGFzdEhlaWdodCkpIHtcbiAgICAgICAgbWUucHJvcHMubGFzdFdpZHRoID0gbWUuZG9tLnJvb3Qub2Zmc2V0V2lkdGg7XG4gICAgICAgIG1lLnByb3BzLmxhc3RIZWlnaHQgPSBtZS5kb20ucm9vdC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgbWUuZW1pdCgnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGFkZCBldmVudCBsaXN0ZW5lciB0byB3aW5kb3cgcmVzaXplXG4gIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSk7XG5cbiAgdGhpcy53YXRjaFRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy5fb25SZXNpemUsIDEwMDApO1xufTtcblxuLyoqXG4gKiBTdG9wIHdhdGNoaW5nIGZvciBhIHJlc2l6ZSBvZiB0aGUgZnJhbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fc3RvcEF1dG9SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLndhdGNoVGltZXIpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMud2F0Y2hUaW1lcik7XG4gICAgdGhpcy53YXRjaFRpbWVyID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvdy5yZXNpemVcbiAgaWYgKHRoaXMuX29uUmVzaXplKSB7XG4gICAgdXRpbC5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcbiAgICB0aGlzLl9vblJlc2l6ZSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnQgbW92aW5nIHRoZSB0aW1lbGluZSB2ZXJ0aWNhbGx5XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX29uVG91Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdGhpcy50b3VjaC5hbGxvd0RyYWdnaW5nID0gdHJ1ZTtcbiAgdGhpcy50b3VjaC5pbml0aWFsU2Nyb2xsVG9wID0gdGhpcy5wcm9wcy5zY3JvbGxUb3A7XG59O1xuXG4vKipcbiAqIFN0YXJ0IG1vdmluZyB0aGUgdGltZWxpbmUgdmVydGljYWxseVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl9vblBpbmNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHRoaXMudG91Y2guYWxsb3dEcmFnZ2luZyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBNb3ZlIHRoZSB0aW1lbGluZSB2ZXJ0aWNhbGx5XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyByZWZ1c2UgdG8gZHJhZyB3aGVuIHdlIHdoZXJlIHBpbmNoaW5nIHRvIHByZXZlbnQgdGhlIHRpbWVsaW5lIG1ha2UgYSBqdW1wXG4gIC8vIHdoZW4gcmVsZWFzaW5nIHRoZSBmaW5nZXJzIGluIG9wcG9zaXRlIG9yZGVyIGZyb20gdGhlIHRvdWNoIHNjcmVlblxuICBpZiAoIXRoaXMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gIHZhciBkZWx0YSA9IGV2ZW50LmRlbHRhWTtcblxuICB2YXIgb2xkU2Nyb2xsVG9wID0gdGhpcy5fZ2V0U2Nyb2xsVG9wKCk7XG4gIHZhciBuZXdTY3JvbGxUb3AgPSB0aGlzLl9zZXRTY3JvbGxUb3AodGhpcy50b3VjaC5pbml0aWFsU2Nyb2xsVG9wICsgZGVsdGEpO1xuXG5cbiAgaWYgKG5ld1Njcm9sbFRvcCAhPSBvbGRTY3JvbGxUb3ApIHtcbiAgICB0aGlzLl9yZWRyYXcoKTsgLy8gVE9ETzogdGhpcyBjYXVzZXMgdHdvIHJlZHJhd3Mgd2hlbiBkcmFnZ2luZywgdGhlIG90aGVyIGlzIHRyaWdnZXJlZCBieSByYW5nZWNoYW5nZSBhbHJlYWR5XG4gICAgdGhpcy5lbWl0KFwidmVydGljYWxEcmFnXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgc2Nyb2xsVG9wXG4gKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsVG9wXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzY3JvbGxUb3AgIFJldHVybnMgdGhlIGFwcGxpZWQgc2Nyb2xsVG9wXG4gKiBAcHJpdmF0ZVxuICovXG5Db3JlLnByb3RvdHlwZS5fc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHNjcm9sbFRvcCkge1xuICB0aGlzLnByb3BzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgdGhpcy5fdXBkYXRlU2Nyb2xsVG9wKCk7XG4gIHJldHVybiB0aGlzLnByb3BzLnNjcm9sbFRvcDtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjdXJyZW50IHNjcm9sbFRvcCB3aGVuIHRoZSBoZWlnaHQgb2YgIHRoZSBjb250YWluZXJzIGhhcyBiZWVuIGNoYW5nZWRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNjcm9sbFRvcCAgUmV0dXJucyB0aGUgYXBwbGllZCBzY3JvbGxUb3BcbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl91cGRhdGVTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHJlY2FsY3VsYXRlIHRoZSBzY3JvbGxUb3BNaW5cbiAgdmFyIHNjcm9sbFRvcE1pbiA9IE1hdGgubWluKHRoaXMucHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCAtIHRoaXMucHJvcHMuY2VudGVyLmhlaWdodCwgMCk7IC8vIGlzIG5lZ2F0aXZlIG9yIHplcm9cbiAgaWYgKHNjcm9sbFRvcE1pbiAhPSB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbikge1xuICAgIC8vIGluIGNhc2Ugb2YgYm90dG9tIG9yaWVudGF0aW9uLCBjaGFuZ2UgdGhlIHNjcm9sbFRvcCBzdWNoIHRoYXQgdGhlIGNvbnRlbnRzXG4gICAgLy8gZG8gbm90IG1vdmUgcmVsYXRpdmUgdG8gdGhlIHRpbWUgYXhpcyBhdCB0aGUgYm90dG9tXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtICE9ICd0b3AnKSB7XG4gICAgICB0aGlzLnByb3BzLnNjcm9sbFRvcCArPSAoc2Nyb2xsVG9wTWluIC0gdGhpcy5wcm9wcy5zY3JvbGxUb3BNaW4pO1xuICAgIH1cbiAgICB0aGlzLnByb3BzLnNjcm9sbFRvcE1pbiA9IHNjcm9sbFRvcE1pbjtcbiAgfVxuXG4gIC8vIGxpbWl0IHRoZSBzY3JvbGxUb3AgdG8gdGhlIGZlYXNpYmxlIHNjcm9sbCByYW5nZVxuICBpZiAodGhpcy5wcm9wcy5zY3JvbGxUb3AgPiAwKSB0aGlzLnByb3BzLnNjcm9sbFRvcCA9IDA7XG4gIGlmICh0aGlzLnByb3BzLnNjcm9sbFRvcCA8IHNjcm9sbFRvcE1pbikgdGhpcy5wcm9wcy5zY3JvbGxUb3AgPSBzY3JvbGxUb3BNaW47XG5cbiAgcmV0dXJuIHRoaXMucHJvcHMuc2Nyb2xsVG9wO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgc2Nyb2xsVG9wXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBzY3JvbGxUb3BcbiAqIEBwcml2YXRlXG4gKi9cbkNvcmUucHJvdG90eXBlLl9nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLnNjcm9sbFRvcDtcbn07XG5cbi8qKlxuICogTG9hZCBhIGNvbmZpZ3VyYXRvclxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuQ29yZS5wcm90b3R5cGUuX2NyZWF0ZUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW52b2tlIGFic3RyYWN0IG1ldGhvZCBfY3JlYXRlQ29uZmlndXJhdG9yJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvcmU7XG4iXX0=
},{"../DataSet":15,"../DataView":16,"../hammerUtil":18,"../module/hammer":19,"../shared/Activator":22,"../util":46,"./DateUtil":27,"./Range":28,"./component/CustomTime":35,"./component/ItemSet":37,"./component/TimeAxis":38,"emitter-component":10}],27:[function(require,module,exports){

/**
 * used in Core to convert the options into a volatile variable
 * 
 * @param {function} moment
 * @param {Object} body
 * @param {Array | Object} hiddenDates
 */
"use strict";

exports.convertHiddenOptions = function (moment, body, hiddenDates) {
  if (hiddenDates && !Array.isArray(hiddenDates)) {
    return exports.convertHiddenOptions(moment, body, [hiddenDates]);
  }

  body.hiddenDates = [];
  if (hiddenDates) {
    if (Array.isArray(hiddenDates) == true) {
      for (var i = 0; i < hiddenDates.length; i++) {
        if (hiddenDates[i].repeat === undefined) {
          var dateItem = {};
          dateItem.start = moment(hiddenDates[i].start).toDate().valueOf();
          dateItem.end = moment(hiddenDates[i].end).toDate().valueOf();
          body.hiddenDates.push(dateItem);
        }
      }
      body.hiddenDates.sort(function (a, b) {
        return a.start - b.start;
      }); // sort by start time
    }
  }
};

/**
 * create new entrees for the repeating hidden dates
 * @param {function} moment
 * @param {Object} body
 * @param {Array | Object} hiddenDates
 */
exports.updateHiddenDates = function (moment, body, hiddenDates) {
  if (hiddenDates && !Array.isArray(hiddenDates)) {
    return exports.updateHiddenDates(moment, body, [hiddenDates]);
  }

  if (hiddenDates && body.domProps.centerContainer.width !== undefined) {
    exports.convertHiddenOptions(moment, body, hiddenDates);

    var start = moment(body.range.start);
    var end = moment(body.range.end);

    var totalRange = body.range.end - body.range.start;
    var pixelTime = totalRange / body.domProps.centerContainer.width;

    for (var i = 0; i < hiddenDates.length; i++) {
      if (hiddenDates[i].repeat !== undefined) {
        var startDate = moment(hiddenDates[i].start);
        var endDate = moment(hiddenDates[i].end);

        if (startDate._d == "Invalid Date") {
          throw new Error("Supplied start date is not valid: " + hiddenDates[i].start);
        }
        if (endDate._d == "Invalid Date") {
          throw new Error("Supplied end date is not valid: " + hiddenDates[i].end);
        }

        var duration = endDate - startDate;
        if (duration >= 4 * pixelTime) {

          var offset = 0;
          var runUntil = end.clone();
          switch (hiddenDates[i].repeat) {
            case "daily":
              // case of time
              if (startDate.day() != endDate.day()) {
                offset = 1;
              }
              startDate.dayOfYear(start.dayOfYear());
              startDate.year(start.year());
              startDate.subtract(7, 'days');

              endDate.dayOfYear(start.dayOfYear());
              endDate.year(start.year());
              endDate.subtract(7 - offset, 'days');

              runUntil.add(1, 'weeks');
              break;
            case "weekly":
              var dayOffset = endDate.diff(startDate, 'days');
              var day = startDate.day();

              // set the start date to the range.start
              startDate.date(start.date());
              startDate.month(start.month());
              startDate.year(start.year());
              endDate = startDate.clone();

              // force
              startDate.day(day);
              endDate.day(day);
              endDate.add(dayOffset, 'days');

              startDate.subtract(1, 'weeks');
              endDate.subtract(1, 'weeks');

              runUntil.add(1, 'weeks');
              break;
            case "monthly":
              if (startDate.month() != endDate.month()) {
                offset = 1;
              }
              startDate.month(start.month());
              startDate.year(start.year());
              startDate.subtract(1, 'months');

              endDate.month(start.month());
              endDate.year(start.year());
              endDate.subtract(1, 'months');
              endDate.add(offset, 'months');

              runUntil.add(1, 'months');
              break;
            case "yearly":
              if (startDate.year() != endDate.year()) {
                offset = 1;
              }
              startDate.year(start.year());
              startDate.subtract(1, 'years');
              endDate.year(start.year());
              endDate.subtract(1, 'years');
              endDate.add(offset, 'years');

              runUntil.add(1, 'years');
              break;
            default:
              console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
              return;
          }
          while (startDate < runUntil) {
            body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
            switch (hiddenDates[i].repeat) {
              case "daily":
                startDate.add(1, 'days');
                endDate.add(1, 'days');
                break;
              case "weekly":
                startDate.add(1, 'weeks');
                endDate.add(1, 'weeks');
                break;
              case "monthly":
                startDate.add(1, 'months');
                endDate.add(1, 'months');
                break;
              case "yearly":
                startDate.add(1, 'y');
                endDate.add(1, 'y');
                break;
              default:
                console.log("Wrong repeat format, allowed are: daily, weekly, monthly, yearly. Given:", hiddenDates[i].repeat);
                return;
            }
          }
          body.hiddenDates.push({ start: startDate.valueOf(), end: endDate.valueOf() });
        }
      }
    }
    // remove duplicates, merge where possible
    exports.removeDuplicates(body);
    // ensure the new positions are not on hidden dates
    var startHidden = exports.isHidden(body.range.start, body.hiddenDates);
    var endHidden = exports.isHidden(body.range.end, body.hiddenDates);
    var rangeStart = body.range.start;
    var rangeEnd = body.range.end;
    if (startHidden.hidden == true) {
      rangeStart = body.range.startToFront == true ? startHidden.startDate - 1 : startHidden.endDate + 1;
    }
    if (endHidden.hidden == true) {
      rangeEnd = body.range.endToFront == true ? endHidden.startDate - 1 : endHidden.endDate + 1;
    }
    if (startHidden.hidden == true || endHidden.hidden == true) {
      body.range._applyRange(rangeStart, rangeEnd);
    }
  }
};

/**
 * remove duplicates from the hidden dates list. Duplicates are evil. They mess everything up.
 * Scales with N^2
 * @param body
 */
exports.removeDuplicates = function (body) {
  var hiddenDates = body.hiddenDates;
  var safeDates = [];
  for (var i = 0; i < hiddenDates.length; i++) {
    for (var j = 0; j < hiddenDates.length; j++) {
      if (i != j && hiddenDates[j].remove != true && hiddenDates[i].remove != true) {
        // j inside i
        if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
          hiddenDates[j].remove = true;
        }
        // j start inside i
        else if (hiddenDates[j].start >= hiddenDates[i].start && hiddenDates[j].start <= hiddenDates[i].end) {
            hiddenDates[i].end = hiddenDates[j].end;
            hiddenDates[j].remove = true;
          }
          // j end inside i
          else if (hiddenDates[j].end >= hiddenDates[i].start && hiddenDates[j].end <= hiddenDates[i].end) {
              hiddenDates[i].start = hiddenDates[j].start;
              hiddenDates[j].remove = true;
            }
      }
    }
  }

  for (var i = 0; i < hiddenDates.length; i++) {
    if (hiddenDates[i].remove !== true) {
      safeDates.push(hiddenDates[i]);
    }
  }

  body.hiddenDates = safeDates;
  body.hiddenDates.sort(function (a, b) {
    return a.start - b.start;
  }); // sort by start time
};

exports.printDates = function (dates) {
  for (var i = 0; i < dates.length; i++) {
    console.log(i, new Date(dates[i].start), new Date(dates[i].end), dates[i].start, dates[i].end, dates[i].remove);
  }
};

/**
 * Used in TimeStep to avoid the hidden times.
 * @param {function} moment
 * @param {TimeStep} timeStep
 * @param previousTime
 */
exports.stepOverHiddenDates = function (moment, timeStep, previousTime) {
  var stepInHidden = false;
  var currentValue = timeStep.current.valueOf();
  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
    var startDate = timeStep.hiddenDates[i].start;
    var endDate = timeStep.hiddenDates[i].end;
    if (currentValue >= startDate && currentValue < endDate) {
      stepInHidden = true;
      break;
    }
  }

  if (stepInHidden == true && currentValue < timeStep._end.valueOf() && currentValue != previousTime) {
    var prevValue = moment(previousTime);
    var newValue = moment(endDate);
    //check if the next step should be major
    if (prevValue.year() != newValue.year()) {
      timeStep.switchedYear = true;
    } else if (prevValue.month() != newValue.month()) {
      timeStep.switchedMonth = true;
    } else if (prevValue.dayOfYear() != newValue.dayOfYear()) {
      timeStep.switchedDay = true;
    }

    timeStep.current = newValue;
  }
};

///**
// * Used in TimeStep to avoid the hidden times.
// * @param timeStep
// * @param previousTime
// */
//exports.checkFirstStep = function(timeStep) {
//  var stepInHidden = false;
//  var currentValue = timeStep.current.valueOf();
//  for (var i = 0; i < timeStep.hiddenDates.length; i++) {
//    var startDate = timeStep.hiddenDates[i].start;
//    var endDate = timeStep.hiddenDates[i].end;
//    if (currentValue >= startDate && currentValue < endDate) {
//      stepInHidden = true;
//      break;
//    }
//  }
//
//  if (stepInHidden == true && currentValue <= timeStep._end.valueOf()) {
//    var newValue = moment(endDate);
//    timeStep.current = newValue.toDate();
//  }
//};

/**
 * replaces the Core toScreen methods
 * @param Core
 * @param time
 * @param width
 * @returns {number}
 */
exports.toScreen = function (Core, time, width) {
  if (Core.body.hiddenDates.length == 0) {
    var conversion = Core.range.conversion(width);
    return (time.valueOf() - conversion.offset) * conversion.scale;
  } else {
    var hidden = exports.isHidden(time, Core.body.hiddenDates);
    if (hidden.hidden == true) {
      time = hidden.startDate;
    }

    var duration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
    time = exports.correctTimeForHidden(Core.options.moment, Core.body.hiddenDates, Core.range, time);

    var conversion = Core.range.conversion(width, duration);
    return (time.valueOf() - conversion.offset) * conversion.scale;
  }
};

/**
 * Replaces the core toTime methods
 * @param body
 * @param range
 * @param x
 * @param width
 * @returns {Date}
 */
exports.toTime = function (Core, x, width) {
  if (Core.body.hiddenDates.length == 0) {
    var conversion = Core.range.conversion(width);
    return new Date(x / conversion.scale + conversion.offset);
  } else {
    var hiddenDuration = exports.getHiddenDurationBetween(Core.body.hiddenDates, Core.range.start, Core.range.end);
    var totalDuration = Core.range.end - Core.range.start - hiddenDuration;
    var partialDuration = totalDuration * x / width;
    var accumulatedHiddenDuration = exports.getAccumulatedHiddenDuration(Core.body.hiddenDates, Core.range, partialDuration);

    var newTime = new Date(accumulatedHiddenDuration + partialDuration + Core.range.start);
    return newTime;
  }
};

/**
 * Support function
 *
 * @param hiddenDates
 * @param range
 * @returns {number}
 */
exports.getHiddenDurationBetween = function (hiddenDates, start, end) {
  var duration = 0;
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= start && endDate < end) {
      duration += endDate - startDate;
    }
  }
  return duration;
};

/**
 * Support function
 * @param moment
 * @param hiddenDates
 * @param range
 * @param time
 * @returns {{duration: number, time: *, offset: number}}
 */
exports.correctTimeForHidden = function (moment, hiddenDates, range, time) {
  time = moment(time).toDate().valueOf();
  time -= exports.getHiddenDurationBefore(moment, hiddenDates, range, time);
  return time;
};

exports.getHiddenDurationBefore = function (moment, hiddenDates, range, time) {
  var timeOffset = 0;
  time = moment(time).toDate().valueOf();

  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= range.start && endDate < range.end) {
      if (time >= endDate) {
        timeOffset += endDate - startDate;
      }
    }
  }
  return timeOffset;
};

/**
 * sum the duration from start to finish, including the hidden duration,
 * until the required amount has been reached, return the accumulated hidden duration
 * @param hiddenDates
 * @param range
 * @param time
 * @returns {{duration: number, time: *, offset: number}}
 */
exports.getAccumulatedHiddenDuration = function (hiddenDates, range, requiredDuration) {
  var hiddenDuration = 0;
  var duration = 0;
  var previousPoint = range.start;
  //exports.printDates(hiddenDates)
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;
    // if time after the cutout, and the
    if (startDate >= range.start && endDate < range.end) {
      duration += startDate - previousPoint;
      previousPoint = endDate;
      if (duration >= requiredDuration) {
        break;
      } else {
        hiddenDuration += endDate - startDate;
      }
    }
  }

  return hiddenDuration;
};

/**
 * used to step over to either side of a hidden block. Correction is disabled on tablets, might be set to true
 * @param hiddenDates
 * @param time
 * @param direction
 * @param correctionEnabled
 * @returns {*}
 */
exports.snapAwayFromHidden = function (hiddenDates, time, direction, correctionEnabled) {
  var isHidden = exports.isHidden(time, hiddenDates);
  if (isHidden.hidden == true) {
    if (direction < 0) {
      if (correctionEnabled == true) {
        return isHidden.startDate - (isHidden.endDate - time) - 1;
      } else {
        return isHidden.startDate - 1;
      }
    } else {
      if (correctionEnabled == true) {
        return isHidden.endDate + (time - isHidden.startDate) + 1;
      } else {
        return isHidden.endDate + 1;
      }
    }
  } else {
    return time;
  }
};

/**
 * Check if a time is hidden
 *
 * @param time
 * @param hiddenDates
 * @returns {{hidden: boolean, startDate: Window.start, endDate: *}}
 */
exports.isHidden = function (time, hiddenDates) {
  for (var i = 0; i < hiddenDates.length; i++) {
    var startDate = hiddenDates[i].start;
    var endDate = hiddenDates[i].end;

    if (time >= startDate && time < endDate) {
      // if the start is entering a hidden zone
      return { hidden: true, startDate: startDate, endDate: endDate };
      break;
    }
  }
  return { hidden: false, startDate: startDate, endDate: endDate };
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9EYXRlVXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBUUEsT0FBTyxDQUFDLG9CQUFvQixHQUFHLFVBQVMsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUU7QUFDakUsTUFBSSxXQUFXLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFO0FBQzlDLFdBQU8sT0FBTyxDQUFDLG9CQUFvQixDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFBO0dBQ2pFOztBQUVELE1BQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3RCLE1BQUksV0FBVyxFQUFFO0FBQ2YsUUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLElBQUksRUFBRTtBQUN0QyxXQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMzQyxZQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO0FBQ3ZDLGNBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztBQUNsQixrQkFBUSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ2pFLGtCQUFRLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDN0QsY0FBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDakM7T0FDRjtBQUNELFVBQUksQ0FBQyxXQUFXLENB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Q0FBQyxDQUFDO09BQy9CO0tBQ0YsTUFDSTtBQUNILFVBQUksaUJBQWlCLElBQUksSUFBSSxFQUFFO0FBQzdCLGVBQU8sUUFBUSxDQUFDLE9BQU8sSUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQSxBQUFDLEdBQUcsQ0FBQyxDQUFDO09BQzNELE1BQ0k7QUFDSCxlQUFPLFFBQVEsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO09BQzdCO0tBQ0Y7R0FDRixNQUNJO0FBQ0gsV0FBTyxJQUFJLENBQUM7R0FDYjtDQUVGLENBQUE7Ozs7Ozs7OztBQVVELE9BQU8sQ0FBQyxRQUFRLEdBQUcsVUFBUyxJQUFJLEVBQUUsV0FBVyxFQUFFO0FBQzdDLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzNDLFFBQUksU0FBUyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDckMsUUFBSSxPQUFPLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQzs7QUFFakMsUUFBSSxJQUFJLElBQUksU0FBUyxJQUFJLElBQUksR0FBRyxPQUFPLEVBQUU7O0FBQ3ZDLGFBQU8sRUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBQyxDQUFDO0FBQzlELFlBQU07S0FDUDtHQUNGO0FBQ0QsU0FBTyxFQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFDLENBQUM7Q0FDaEUsQ0FBQSIsImZpbGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvRGF0ZVV0aWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogdXNlZCBpbiBDb3JlIHRvIGNvbnZlcnQgdGhlIG9wdGlvbnMgaW50byBhIHZvbGF0aWxlIHZhcmlhYmxlXG4gKiBcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAqIEBwYXJhbSB7QXJyYXkgfCBPYmplY3R9IGhpZGRlbkRhdGVzXG4gKi9cbmV4cG9ydHMuY29udmVydEhpZGRlbk9wdGlvbnMgPSBmdW5jdGlvbihtb21lbnQsIGJvZHksIGhpZGRlbkRhdGVzKSB7XG4gIGlmIChoaWRkZW5EYXRlcyAmJiAhQXJyYXkuaXNBcnJheShoaWRkZW5EYXRlcykpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jb252ZXJ0SGlkZGVuT3B0aW9ucyhtb21lbnQsIGJvZHksIFtoaWRkZW5EYXRlc10pXG4gIH1cblxuICBib2R5LmhpZGRlbkRhdGVzID0gW107XG4gIGlmIChoaWRkZW5EYXRlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhpZGRlbkRhdGVzKSA9PSB0cnVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChoaWRkZW5EYXRlc1tpXS5yZXBlYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBkYXRlSXRlbSA9IHt9O1xuICAgICAgICAgIGRhdGVJdGVtLnN0YXJ0ID0gbW9tZW50KGhpZGRlbkRhdGVzW2ldLnN0YXJ0KS50b0RhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgICAgZGF0ZUl0ZW0uZW5kID0gbW9tZW50KGhpZGRlbkRhdGVzW2ldLmVuZCkudG9EYXRlKCkudmFsdWVPZigpO1xuICAgICAgICAgIGJvZHkuaGlkZGVuRGF0ZXMucHVzaChkYXRlSXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJvZHkuaGlkZGVuRGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICB9KTsgLy8gc29ydCBieSBzdGFydCB0aW1lXG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogY3JlYXRlIG5ldyBlbnRyZWVzIGZvciB0aGUgcmVwZWF0aW5nIGhpZGRlbiBkYXRlc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gbW9tZW50XG4gKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICogQHBhcmFtIHtBcnJheSB8IE9iamVjdH0gaGlkZGVuRGF0ZXNcbiAqL1xuZXhwb3J0cy51cGRhdGVIaWRkZW5EYXRlcyA9IGZ1bmN0aW9uIChtb21lbnQsIGJvZHksIGhpZGRlbkRhdGVzKSB7XG4gIGlmIChoaWRkZW5EYXRlcyAmJiAhQXJyYXkuaXNBcnJheShoaWRkZW5EYXRlcykpIHtcbiAgICByZXR1cm4gZXhwb3J0cy51cGRhdGVIaWRkZW5EYXRlcyhtb21lbnQsIGJvZHksIFtoaWRkZW5EYXRlc10pXG4gIH1cblxuICBpZiAoaGlkZGVuRGF0ZXMgJiYgYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIud2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGV4cG9ydHMuY29udmVydEhpZGRlbk9wdGlvbnMobW9tZW50LCBib2R5LCBoaWRkZW5EYXRlcyk7XG5cbiAgICB2YXIgc3RhcnQgPSBtb21lbnQoYm9keS5yYW5nZS5zdGFydCk7XG4gICAgdmFyIGVuZCA9IG1vbWVudChib2R5LnJhbmdlLmVuZCk7XG5cbiAgICB2YXIgdG90YWxSYW5nZSA9IChib2R5LnJhbmdlLmVuZCAtIGJvZHkucmFuZ2Uuc3RhcnQpO1xuICAgIHZhciBwaXhlbFRpbWUgPSB0b3RhbFJhbmdlIC8gYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIud2lkdGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaGlkZGVuRGF0ZXNbaV0ucmVwZWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHN0YXJ0RGF0ZSA9IG1vbWVudChoaWRkZW5EYXRlc1tpXS5zdGFydCk7XG4gICAgICAgIHZhciBlbmREYXRlID0gbW9tZW50KGhpZGRlbkRhdGVzW2ldLmVuZCk7XG5cbiAgICAgICAgaWYgKHN0YXJ0RGF0ZS5fZCA9PSBcIkludmFsaWQgRGF0ZVwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VwcGxpZWQgc3RhcnQgZGF0ZSBpcyBub3QgdmFsaWQ6IFwiICsgaGlkZGVuRGF0ZXNbaV0uc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmREYXRlLl9kID09IFwiSW52YWxpZCBEYXRlXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwbGllZCBlbmQgZGF0ZSBpcyBub3QgdmFsaWQ6IFwiICsgaGlkZGVuRGF0ZXNbaV0uZW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGVuZERhdGUgLSBzdGFydERhdGU7XG4gICAgICAgIGlmIChkdXJhdGlvbiA+PSA0ICogcGl4ZWxUaW1lKSB7XG5cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICB2YXIgcnVuVW50aWwgPSBlbmQuY2xvbmUoKTtcbiAgICAgICAgICBzd2l0Y2ggKGhpZGRlbkRhdGVzW2ldLnJlcGVhdCkge1xuICAgICAgICAgICAgY2FzZSBcImRhaWx5XCI6IC8vIGNhc2Ugb2YgdGltZVxuICAgICAgICAgICAgICBpZiAoc3RhcnREYXRlLmRheSgpICE9IGVuZERhdGUuZGF5KCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS5kYXlPZlllYXIoc3RhcnQuZGF5T2ZZZWFyKCkpO1xuICAgICAgICAgICAgICBzdGFydERhdGUueWVhcihzdGFydC55ZWFyKCkpO1xuICAgICAgICAgICAgICBzdGFydERhdGUuc3VidHJhY3QoNywnZGF5cycpO1xuXG4gICAgICAgICAgICAgIGVuZERhdGUuZGF5T2ZZZWFyKHN0YXJ0LmRheU9mWWVhcigpKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgIGVuZERhdGUuc3VidHJhY3QoNyAtIG9mZnNldCwnZGF5cycpO1xuXG4gICAgICAgICAgICAgIHJ1blVudGlsLmFkZCgxLCAnd2Vla3MnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwid2Vla2x5XCI6XG4gICAgICAgICAgICAgIHZhciBkYXlPZmZzZXQgPSBlbmREYXRlLmRpZmYoc3RhcnREYXRlLCdkYXlzJylcbiAgICAgICAgICAgICAgdmFyIGRheSA9IHN0YXJ0RGF0ZS5kYXkoKTtcblxuICAgICAgICAgICAgICAvLyBzZXQgdGhlIHN0YXJ0IGRhdGUgdG8gdGhlIHJhbmdlLnN0YXJ0XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS5kYXRlKHN0YXJ0LmRhdGUoKSk7XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS5tb250aChzdGFydC5tb250aCgpKTtcbiAgICAgICAgICAgICAgc3RhcnREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZSA9IHN0YXJ0RGF0ZS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgIC8vIGZvcmNlXG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS5kYXkoZGF5KTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5kYXkoZGF5KTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQoZGF5T2Zmc2V0LCdkYXlzJyk7XG5cbiAgICAgICAgICAgICAgc3RhcnREYXRlLnN1YnRyYWN0KDEsJ3dlZWtzJyk7XG4gICAgICAgICAgICAgIGVuZERhdGUuc3VidHJhY3QoMSwnd2Vla3MnKTtcblxuICAgICAgICAgICAgICBydW5VbnRpbC5hZGQoMSwgJ3dlZWtzJyk7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIFwibW9udGhseVwiOlxuICAgICAgICAgICAgICBpZiAoc3RhcnREYXRlLm1vbnRoKCkgIT0gZW5kRGF0ZS5tb250aCgpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGFydERhdGUubW9udGgoc3RhcnQubW9udGgoKSk7XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zdWJ0cmFjdCgxLCdtb250aHMnKTtcblxuICAgICAgICAgICAgICBlbmREYXRlLm1vbnRoKHN0YXJ0Lm1vbnRoKCkpO1xuICAgICAgICAgICAgICBlbmREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5zdWJ0cmFjdCgxLCdtb250aHMnKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQob2Zmc2V0LCdtb250aHMnKTtcblxuICAgICAgICAgICAgICBydW5VbnRpbC5hZGQoMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ5ZWFybHlcIjpcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0RGF0ZS55ZWFyKCkgIT0gZW5kRGF0ZS55ZWFyKCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS55ZWFyKHN0YXJ0LnllYXIoKSk7XG4gICAgICAgICAgICAgIHN0YXJ0RGF0ZS5zdWJ0cmFjdCgxLCd5ZWFycycpO1xuICAgICAgICAgICAgICBlbmREYXRlLnllYXIoc3RhcnQueWVhcigpKTtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5zdWJ0cmFjdCgxLCd5ZWFycycpO1xuICAgICAgICAgICAgICBlbmREYXRlLmFkZChvZmZzZXQsJ3llYXJzJyk7XG5cbiAgICAgICAgICAgICAgcnVuVW50aWwuYWRkKDEsICd5ZWFycycpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV3JvbmcgcmVwZWF0IGZvcm1hdCwgYWxsb3dlZCBhcmU6IGRhaWx5LCB3ZWVrbHksIG1vbnRobHksIHllYXJseS4gR2l2ZW46XCIsIGhpZGRlbkRhdGVzW2ldLnJlcGVhdCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHN0YXJ0RGF0ZSA8IHJ1blVudGlsKSB7XG4gICAgICAgICAgICBib2R5LmhpZGRlbkRhdGVzLnB1c2goe3N0YXJ0OiBzdGFydERhdGUudmFsdWVPZigpLCBlbmQ6IGVuZERhdGUudmFsdWVPZigpfSk7XG4gICAgICAgICAgICBzd2l0Y2ggKGhpZGRlbkRhdGVzW2ldLnJlcGVhdCkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGFpbHlcIjpcbiAgICAgICAgICAgICAgICBzdGFydERhdGUuYWRkKDEsICdkYXlzJyk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQoMSwgJ2RheXMnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIndlZWtseVwiOlxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZS5hZGQoMSwgJ3dlZWtzJyk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQoMSwgJ3dlZWtzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJtb250aGx5XCI6XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLmFkZCgxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAgICAgZW5kRGF0ZS5hZGQoMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwieWVhcmx5XCI6XG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLmFkZCgxLCAneScpO1xuICAgICAgICAgICAgICAgIGVuZERhdGUuYWRkKDEsICd5Jyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXcm9uZyByZXBlYXQgZm9ybWF0LCBhbGxvd2VkIGFyZTogZGFpbHksIHdlZWtseSwgbW9udGhseSwgeWVhcmx5LiBHaXZlbjpcIiwgaGlkZGVuRGF0ZXNbaV0ucmVwZWF0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHkuaGlkZGVuRGF0ZXMucHVzaCh7c3RhcnQ6IHN0YXJ0RGF0ZS52YWx1ZU9mKCksIGVuZDogZW5kRGF0ZS52YWx1ZU9mKCl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyByZW1vdmUgZHVwbGljYXRlcywgbWVyZ2Ugd2hlcmUgcG9zc2libGVcbiAgICBleHBvcnRzLnJlbW92ZUR1cGxpY2F0ZXMoYm9keSk7XG4gICAgLy8gZW5zdXJlIHRoZSBuZXcgcG9zaXRpb25zIGFyZSBub3Qgb24gaGlkZGVuIGRhdGVzXG4gICAgdmFyIHN0YXJ0SGlkZGVuID0gZXhwb3J0cy5pc0hpZGRlbihib2R5LnJhbmdlLnN0YXJ0LCBib2R5LmhpZGRlbkRhdGVzKTtcbiAgICB2YXIgZW5kSGlkZGVuID0gZXhwb3J0cy5pc0hpZGRlbihib2R5LnJhbmdlLmVuZCxib2R5LmhpZGRlbkRhdGVzKTtcbiAgICB2YXIgcmFuZ2VTdGFydCA9IGJvZHkucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIHJhbmdlRW5kID0gYm9keS5yYW5nZS5lbmQ7XG4gICAgaWYgKHN0YXJ0SGlkZGVuLmhpZGRlbiA9PSB0cnVlKSB7cmFuZ2VTdGFydCA9IGJvZHkucmFuZ2Uuc3RhcnRUb0Zyb250ID09IHRydWUgPyBzdGFydEhpZGRlbi5zdGFydERhdGUgLSAxIDogc3RhcnRIaWRkZW4uZW5kRGF0ZSArIDE7fVxuICAgIGlmIChlbmRIaWRkZW4uaGlkZGVuID09IHRydWUpICAge3JhbmdlRW5kICAgPSBib2R5LnJhbmdlLmVuZFRvRnJvbnQgPT0gdHJ1ZSA/ICAgZW5kSGlkZGVuLnN0YXJ0RGF0ZSAtIDEgICA6IGVuZEhpZGRlbi5lbmREYXRlICsgMTt9XG4gICAgaWYgKHN0YXJ0SGlkZGVuLmhpZGRlbiA9PSB0cnVlIHx8IGVuZEhpZGRlbi5oaWRkZW4gPT0gdHJ1ZSkge1xuICAgICAgYm9keS5yYW5nZS5fYXBwbHlSYW5nZShyYW5nZVN0YXJ0LCByYW5nZUVuZCk7XG4gICAgfVxuICB9XG5cbn1cblxuXG4vKipcbiAqIHJlbW92ZSBkdXBsaWNhdGVzIGZyb20gdGhlIGhpZGRlbiBkYXRlcyBsaXN0LiBEdXBsaWNhdGVzIGFyZSBldmlsLiBUaGV5IG1lc3MgZXZlcnl0aGluZyB1cC5cbiAqIFNjYWxlcyB3aXRoIE5eMlxuICogQHBhcmFtIGJvZHlcbiAqL1xuZXhwb3J0cy5yZW1vdmVEdXBsaWNhdGVzID0gZnVuY3Rpb24oYm9keSkge1xuICB2YXIgaGlkZGVuRGF0ZXMgPSBib2R5LmhpZGRlbkRhdGVzO1xuICB2YXIgc2FmZURhdGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoaSAhPSBqICYmIGhpZGRlbkRhdGVzW2pdLnJlbW92ZSAhPSB0cnVlICYmIGhpZGRlbkRhdGVzW2ldLnJlbW92ZSAhPSB0cnVlKSB7XG4gICAgICAgIC8vIGogaW5zaWRlIGlcbiAgICAgICAgaWYgKGhpZGRlbkRhdGVzW2pdLnN0YXJ0ID49IGhpZGRlbkRhdGVzW2ldLnN0YXJ0ICYmIGhpZGRlbkRhdGVzW2pdLmVuZCA8PSBoaWRkZW5EYXRlc1tpXS5lbmQpIHtcbiAgICAgICAgICBoaWRkZW5EYXRlc1tqXS5yZW1vdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGogc3RhcnQgaW5zaWRlIGlcbiAgICAgICAgZWxzZSBpZiAoaGlkZGVuRGF0ZXNbal0uc3RhcnQgPj0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQgJiYgaGlkZGVuRGF0ZXNbal0uc3RhcnQgPD0gaGlkZGVuRGF0ZXNbaV0uZW5kKSB7XG4gICAgICAgICAgaGlkZGVuRGF0ZXNbaV0uZW5kID0gaGlkZGVuRGF0ZXNbal0uZW5kO1xuICAgICAgICAgIGhpZGRlbkRhdGVzW2pdLnJlbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaiBlbmQgaW5zaWRlIGlcbiAgICAgICAgZWxzZSBpZiAoaGlkZGVuRGF0ZXNbal0uZW5kID49IGhpZGRlbkRhdGVzW2ldLnN0YXJ0ICYmIGhpZGRlbkRhdGVzW2pdLmVuZCA8PSBoaWRkZW5EYXRlc1tpXS5lbmQpIHtcbiAgICAgICAgICBoaWRkZW5EYXRlc1tpXS5zdGFydCA9IGhpZGRlbkRhdGVzW2pdLnN0YXJ0O1xuICAgICAgICAgIGhpZGRlbkRhdGVzW2pdLnJlbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhpZGRlbkRhdGVzW2ldLnJlbW92ZSAhPT0gdHJ1ZSkge1xuICAgICAgc2FmZURhdGVzLnB1c2goaGlkZGVuRGF0ZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGJvZHkuaGlkZGVuRGF0ZXMgPSBzYWZlRGF0ZXM7XG4gIGJvZHkuaGlkZGVuRGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydDtcbiAgfSk7IC8vIHNvcnQgYnkgc3RhcnQgdGltZVxufTtcblxuZXhwb3J0cy5wcmludERhdGVzID0gZnVuY3Rpb24oZGF0ZXMpIHtcbiAgZm9yICh2YXIgaSA9MDsgaSA8IGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc29sZS5sb2coaSwgbmV3IERhdGUoZGF0ZXNbaV0uc3RhcnQpLG5ldyBEYXRlKGRhdGVzW2ldLmVuZCksIGRhdGVzW2ldLnN0YXJ0LCBkYXRlc1tpXS5lbmQsIGRhdGVzW2ldLnJlbW92ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogVXNlZCBpbiBUaW1lU3RlcCB0byBhdm9pZCB0aGUgaGlkZGVuIHRpbWVzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbW9tZW50XG4gKiBAcGFyYW0ge1RpbWVTdGVwfSB0aW1lU3RlcFxuICogQHBhcmFtIHByZXZpb3VzVGltZVxuICovXG5leHBvcnRzLnN0ZXBPdmVySGlkZGVuRGF0ZXMgPSBmdW5jdGlvbihtb21lbnQsIHRpbWVTdGVwLCBwcmV2aW91c1RpbWUpIHtcbiAgdmFyIHN0ZXBJbkhpZGRlbiA9IGZhbHNlO1xuICB2YXIgY3VycmVudFZhbHVlID0gdGltZVN0ZXAuY3VycmVudC52YWx1ZU9mKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZVN0ZXAuaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhcnREYXRlID0gdGltZVN0ZXAuaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4gICAgdmFyIGVuZERhdGUgPSB0aW1lU3RlcC5oaWRkZW5EYXRlc1tpXS5lbmQ7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBzdGFydERhdGUgJiYgY3VycmVudFZhbHVlIDwgZW5kRGF0ZSkge1xuICAgICAgc3RlcEluSGlkZGVuID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGVwSW5IaWRkZW4gPT0gdHJ1ZSAmJiBjdXJyZW50VmFsdWUgPCB0aW1lU3RlcC5fZW5kLnZhbHVlT2YoKSAmJiBjdXJyZW50VmFsdWUgIT0gcHJldmlvdXNUaW1lKSB7XG4gICAgdmFyIHByZXZWYWx1ZSA9IG1vbWVudChwcmV2aW91c1RpbWUpO1xuICAgIHZhciBuZXdWYWx1ZSA9IG1vbWVudChlbmREYXRlKTtcbiAgICAvL2NoZWNrIGlmIHRoZSBuZXh0IHN0ZXAgc2hvdWxkIGJlIG1ham9yXG4gICAgaWYgKHByZXZWYWx1ZS55ZWFyKCkgIT0gbmV3VmFsdWUueWVhcigpKSB7dGltZVN0ZXAuc3dpdGNoZWRZZWFyID0gdHJ1ZTt9XG4gICAgZWxzZSBpZiAocHJldlZhbHVlLm1vbnRoKCkgIT0gbmV3VmFsdWUubW9udGgoKSkge3RpbWVTdGVwLnN3aXRjaGVkTW9udGggPSB0cnVlO31cbiAgICBlbHNlIGlmIChwcmV2VmFsdWUuZGF5T2ZZZWFyKCkgIT0gbmV3VmFsdWUuZGF5T2ZZZWFyKCkpIHt0aW1lU3RlcC5zd2l0Y2hlZERheSA9IHRydWU7fVxuXG4gICAgdGltZVN0ZXAuY3VycmVudCA9IG5ld1ZhbHVlO1xuICB9XG59O1xuXG5cbi8vLyoqXG4vLyAqIFVzZWQgaW4gVGltZVN0ZXAgdG8gYXZvaWQgdGhlIGhpZGRlbiB0aW1lcy5cbi8vICogQHBhcmFtIHRpbWVTdGVwXG4vLyAqIEBwYXJhbSBwcmV2aW91c1RpbWVcbi8vICovXG4vL2V4cG9ydHMuY2hlY2tGaXJzdFN0ZXAgPSBmdW5jdGlvbih0aW1lU3RlcCkge1xuLy8gIHZhciBzdGVwSW5IaWRkZW4gPSBmYWxzZTtcbi8vICB2YXIgY3VycmVudFZhbHVlID0gdGltZVN0ZXAuY3VycmVudC52YWx1ZU9mKCk7XG4vLyAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lU3RlcC5oaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuLy8gICAgdmFyIHN0YXJ0RGF0ZSA9IHRpbWVTdGVwLmhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuLy8gICAgdmFyIGVuZERhdGUgPSB0aW1lU3RlcC5oaWRkZW5EYXRlc1tpXS5lbmQ7XG4vLyAgICBpZiAoY3VycmVudFZhbHVlID49IHN0YXJ0RGF0ZSAmJiBjdXJyZW50VmFsdWUgPCBlbmREYXRlKSB7XG4vLyAgICAgIHN0ZXBJbkhpZGRlbiA9IHRydWU7XG4vLyAgICAgIGJyZWFrO1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgaWYgKHN0ZXBJbkhpZGRlbiA9PSB0cnVlICYmIGN1cnJlbnRWYWx1ZSA8PSB0aW1lU3RlcC5fZW5kLnZhbHVlT2YoKSkge1xuLy8gICAgdmFyIG5ld1ZhbHVlID0gbW9tZW50KGVuZERhdGUpO1xuLy8gICAgdGltZVN0ZXAuY3VycmVudCA9IG5ld1ZhbHVlLnRvRGF0ZSgpO1xuLy8gIH1cbi8vfTtcblxuLyoqXG4gKiByZXBsYWNlcyB0aGUgQ29yZSB0b1NjcmVlbiBtZXRob2RzXG4gKiBAcGFyYW0gQ29yZVxuICogQHBhcmFtIHRpbWVcbiAqIEBwYXJhbSB3aWR0aFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy50b1NjcmVlbiA9IGZ1bmN0aW9uKENvcmUsIHRpbWUsIHdpZHRoKSB7XG4gIGlmIChDb3JlLmJvZHkuaGlkZGVuRGF0ZXMubGVuZ3RoID09IDApIHtcbiAgICB2YXIgY29udmVyc2lvbiA9IENvcmUucmFuZ2UuY29udmVyc2lvbih3aWR0aCk7XG4gICAgcmV0dXJuICh0aW1lLnZhbHVlT2YoKSAtIGNvbnZlcnNpb24ub2Zmc2V0KSAqIGNvbnZlcnNpb24uc2NhbGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGhpZGRlbiA9IGV4cG9ydHMuaXNIaWRkZW4odGltZSwgQ29yZS5ib2R5LmhpZGRlbkRhdGVzKTtcbiAgICBpZiAoaGlkZGVuLmhpZGRlbiA9PSB0cnVlKSB7XG4gICAgICB0aW1lID0gaGlkZGVuLnN0YXJ0RGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZHVyYXRpb24gPSBleHBvcnRzLmdldEhpZGRlbkR1cmF0aW9uQmV0d2VlbihDb3JlLmJvZHkuaGlkZGVuRGF0ZXMsIENvcmUucmFuZ2Uuc3RhcnQsIENvcmUucmFuZ2UuZW5kKTtcbiAgICB0aW1lID0gZXhwb3J0cy5jb3JyZWN0VGltZUZvckhpZGRlbihDb3JlLm9wdGlvbnMubW9tZW50LCBDb3JlLmJvZHkuaGlkZGVuRGF0ZXMsIENvcmUucmFuZ2UsIHRpbWUpO1xuXG4gICAgdmFyIGNvbnZlcnNpb24gPSBDb3JlLnJhbmdlLmNvbnZlcnNpb24od2lkdGgsIGR1cmF0aW9uKTtcbiAgICByZXR1cm4gKHRpbWUudmFsdWVPZigpIC0gY29udmVyc2lvbi5vZmZzZXQpICogY29udmVyc2lvbi5zY2FsZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJlcGxhY2VzIHRoZSBjb3JlIHRvVGltZSBtZXRob2RzXG4gKiBAcGFyYW0gYm9keVxuICogQHBhcmFtIHJhbmdlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHdpZHRoXG4gKiBAcmV0dXJucyB7RGF0ZX1cbiAqL1xuZXhwb3J0cy50b1RpbWUgPSBmdW5jdGlvbihDb3JlLCB4LCB3aWR0aCkge1xuICBpZiAoQ29yZS5ib2R5LmhpZGRlbkRhdGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgdmFyIGNvbnZlcnNpb24gPSBDb3JlLnJhbmdlLmNvbnZlcnNpb24od2lkdGgpO1xuICAgIHJldHVybiBuZXcgRGF0ZSh4IC8gY29udmVyc2lvbi5zY2FsZSArIGNvbnZlcnNpb24ub2Zmc2V0KTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgaGlkZGVuRHVyYXRpb24gPSBleHBvcnRzLmdldEhpZGRlbkR1cmF0aW9uQmV0d2VlbihDb3JlLmJvZHkuaGlkZGVuRGF0ZXMsIENvcmUucmFuZ2Uuc3RhcnQsIENvcmUucmFuZ2UuZW5kKTtcbiAgICB2YXIgdG90YWxEdXJhdGlvbiA9IENvcmUucmFuZ2UuZW5kIC0gQ29yZS5yYW5nZS5zdGFydCAtIGhpZGRlbkR1cmF0aW9uO1xuICAgIHZhciBwYXJ0aWFsRHVyYXRpb24gPSB0b3RhbER1cmF0aW9uICogeCAvIHdpZHRoO1xuICAgIHZhciBhY2N1bXVsYXRlZEhpZGRlbkR1cmF0aW9uID0gZXhwb3J0cy5nZXRBY2N1bXVsYXRlZEhpZGRlbkR1cmF0aW9uKENvcmUuYm9keS5oaWRkZW5EYXRlcywgQ29yZS5yYW5nZSwgcGFydGlhbER1cmF0aW9uKTtcblxuICAgIHZhciBuZXdUaW1lID0gbmV3IERhdGUoYWNjdW11bGF0ZWRIaWRkZW5EdXJhdGlvbiArIHBhcnRpYWxEdXJhdGlvbiArIENvcmUucmFuZ2Uuc3RhcnQpO1xuICAgIHJldHVybiBuZXdUaW1lO1xuICB9XG59O1xuXG5cbi8qKlxuICogU3VwcG9ydCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBoaWRkZW5EYXRlc1xuICogQHBhcmFtIHJhbmdlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmdldEhpZGRlbkR1cmF0aW9uQmV0d2VlbiA9IGZ1bmN0aW9uKGhpZGRlbkRhdGVzLCBzdGFydCwgZW5kKSB7XG4gIHZhciBkdXJhdGlvbiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhcnREYXRlID0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4gICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG4gICAgLy8gaWYgdGltZSBhZnRlciB0aGUgY3V0b3V0LCBhbmQgdGhlXG4gICAgaWYgKHN0YXJ0RGF0ZSA+PSBzdGFydCAmJiBlbmREYXRlIDwgZW5kKSB7XG4gICAgICBkdXJhdGlvbiArPSBlbmREYXRlIC0gc3RhcnREYXRlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHVyYXRpb247XG59O1xuXG5cbi8qKlxuICogU3VwcG9ydCBmdW5jdGlvblxuICogQHBhcmFtIG1vbWVudFxuICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gKiBAcGFyYW0gcmFuZ2VcbiAqIEBwYXJhbSB0aW1lXG4gKiBAcmV0dXJucyB7e2R1cmF0aW9uOiBudW1iZXIsIHRpbWU6ICosIG9mZnNldDogbnVtYmVyfX1cbiAqL1xuZXhwb3J0cy5jb3JyZWN0VGltZUZvckhpZGRlbiA9IGZ1bmN0aW9uKG1vbWVudCwgaGlkZGVuRGF0ZXMsIHJhbmdlLCB0aW1lKSB7XG4gIHRpbWUgPSBtb21lbnQodGltZSkudG9EYXRlKCkudmFsdWVPZigpO1xuICB0aW1lIC09IGV4cG9ydHMuZ2V0SGlkZGVuRHVyYXRpb25CZWZvcmUobW9tZW50LCBoaWRkZW5EYXRlcyxyYW5nZSx0aW1lKTtcbiAgcmV0dXJuIHRpbWU7XG59O1xuXG5leHBvcnRzLmdldEhpZGRlbkR1cmF0aW9uQmVmb3JlID0gZnVuY3Rpb24obW9tZW50LCBoaWRkZW5EYXRlcywgcmFuZ2UsIHRpbWUpIHtcbiAgdmFyIHRpbWVPZmZzZXQgPSAwO1xuICB0aW1lID0gbW9tZW50KHRpbWUpLnRvRGF0ZSgpLnZhbHVlT2YoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0YXJ0RGF0ZSA9IGhpZGRlbkRhdGVzW2ldLnN0YXJ0O1xuICAgIHZhciBlbmREYXRlID0gaGlkZGVuRGF0ZXNbaV0uZW5kO1xuICAgIC8vIGlmIHRpbWUgYWZ0ZXIgdGhlIGN1dG91dCwgYW5kIHRoZVxuICAgIGlmIChzdGFydERhdGUgPj0gcmFuZ2Uuc3RhcnQgJiYgZW5kRGF0ZSA8IHJhbmdlLmVuZCkge1xuICAgICAgaWYgKHRpbWUgPj0gZW5kRGF0ZSkge1xuICAgICAgICB0aW1lT2Zmc2V0ICs9IChlbmREYXRlIC0gc3RhcnREYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbWVPZmZzZXQ7XG59XG5cbi8qKlxuICogc3VtIHRoZSBkdXJhdGlvbiBmcm9tIHN0YXJ0IHRvIGZpbmlzaCwgaW5jbHVkaW5nIHRoZSBoaWRkZW4gZHVyYXRpb24sXG4gKiB1bnRpbCB0aGUgcmVxdWlyZWQgYW1vdW50IGhhcyBiZWVuIHJlYWNoZWQsIHJldHVybiB0aGUgYWNjdW11bGF0ZWQgaGlkZGVuIGR1cmF0aW9uXG4gKiBAcGFyYW0gaGlkZGVuRGF0ZXNcbiAqIEBwYXJhbSByYW5nZVxuICogQHBhcmFtIHRpbWVcbiAqIEByZXR1cm5zIHt7ZHVyYXRpb246IG51bWJlciwgdGltZTogKiwgb2Zmc2V0OiBudW1iZXJ9fVxuICovXG5leHBvcnRzLmdldEFjY3VtdWxhdGVkSGlkZGVuRHVyYXRpb24gPSBmdW5jdGlvbihoaWRkZW5EYXRlcywgcmFuZ2UsIHJlcXVpcmVkRHVyYXRpb24pIHtcbiAgdmFyIGhpZGRlbkR1cmF0aW9uID0gMDtcbiAgdmFyIGR1cmF0aW9uID0gMDtcbiAgdmFyIHByZXZpb3VzUG9pbnQgPSByYW5nZS5zdGFydDtcbiAgLy9leHBvcnRzLnByaW50RGF0ZXMoaGlkZGVuRGF0ZXMpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RhcnREYXRlID0gaGlkZGVuRGF0ZXNbaV0uc3RhcnQ7XG4gICAgdmFyIGVuZERhdGUgPSBoaWRkZW5EYXRlc1tpXS5lbmQ7XG4gICAgLy8gaWYgdGltZSBhZnRlciB0aGUgY3V0b3V0LCBhbmQgdGhlXG4gICAgaWYgKHN0YXJ0RGF0ZSA+PSByYW5nZS5zdGFydCAmJiBlbmREYXRlIDwgcmFuZ2UuZW5kKSB7XG4gICAgICBkdXJhdGlvbiArPSBzdGFydERhdGUgLSBwcmV2aW91c1BvaW50O1xuICAgICAgcHJldmlvdXNQb2ludCA9IGVuZERhdGU7XG4gICAgICBpZiAoZHVyYXRpb24gPj0gcmVxdWlyZWREdXJhdGlvbikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBoaWRkZW5EdXJhdGlvbiArPSBlbmREYXRlIC0gc3RhcnREYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoaWRkZW5EdXJhdGlvbjtcbn07XG5cblxuXG4vKipcbiAqIHVzZWQgdG8gc3RlcCBvdmVyIHRvIGVpdGhlciBzaWRlIG9mIGEgaGlkZGVuIGJsb2NrLiBDb3JyZWN0aW9uIGlzIGRpc2FibGVkIG9uIHRhYmxldHMsIG1pZ2h0IGJlIHNldCB0byB0cnVlXG4gKiBAcGFyYW0gaGlkZGVuRGF0ZXNcbiAqIEBwYXJhbSB0aW1lXG4gKiBAcGFyYW0gZGlyZWN0aW9uXG4gKiBAcGFyYW0gY29ycmVjdGlvbkVuYWJsZWRcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnRzLnNuYXBBd2F5RnJvbUhpZGRlbiA9IGZ1bmN0aW9uKGhpZGRlbkRhdGVzLCB0aW1lLCBkaXJlY3Rpb24sIGNvcnJlY3Rpb25FbmFibGVkKSB7XG4gIHZhciBpc0hpZGRlbiA9IGV4cG9ydHMuaXNIaWRkZW4odGltZSwgaGlkZGVuRGF0ZXMpO1xuICBpZiAoaXNIaWRkZW4uaGlkZGVuID09IHRydWUpIHtcbiAgICBpZiAoZGlyZWN0aW9uIDwgMCkge1xuICAgICAgaWYgKGNvcnJlY3Rpb25FbmFibGVkID09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGlzSGlkZGVuLnN0YXJ0RGF0ZSAtIChpc0hpZGRlbi5lbmREYXRlIC0gdGltZSkgLSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0hpZGRlbi5zdGFydERhdGUgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjb3JyZWN0aW9uRW5hYmxlZCA9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBpc0hpZGRlbi5lbmREYXRlICsgKHRpbWUgLSBpc0hpZGRlbi5zdGFydERhdGUpICsgMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNIaWRkZW4uZW5kRGF0ZSArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB0aW1lO1xuICB9XG5cbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGltZSBpcyBoaWRkZW5cbiAqXG4gKiBAcGFyYW0gdGltZVxuICogQHBhcmFtIGhpZGRlbkRhdGVzXG4gKiBAcmV0dXJucyB7e2hpZGRlbjogYm9vbGVhbiwgc3RhcnREYXRlOiBXaW5kb3cuc3RhcnQsIGVuZERhdGU6ICp9fVxuICovXG5leHBvcnRzLmlzSGlkZGVuID0gZnVuY3Rpb24odGltZSwgaGlkZGVuRGF0ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5EYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdGFydERhdGUgPSBoaWRkZW5EYXRlc1tpXS5zdGFydDtcbiAgICB2YXIgZW5kRGF0ZSA9IGhpZGRlbkRhdGVzW2ldLmVuZDtcblxuICAgIGlmICh0aW1lID49IHN0YXJ0RGF0ZSAmJiB0aW1lIDwgZW5kRGF0ZSkgeyAvLyBpZiB0aGUgc3RhcnQgaXMgZW50ZXJpbmcgYSBoaWRkZW4gem9uZVxuICAgICAgcmV0dXJuIHtoaWRkZW46IHRydWUsIHN0YXJ0RGF0ZTogc3RhcnREYXRlLCBlbmREYXRlOiBlbmREYXRlfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2hpZGRlbjogZmFsc2UsIHN0YXJ0RGF0ZTogc3RhcnREYXRlLCBlbmREYXRlOiBlbmREYXRlfTtcbn0iXX0=
},{}],28:[function(require,module,exports){
'use strict';

var util = require('../util');
var hammerUtil = require('../hammerUtil');
var moment = require('../module/moment');
var Component = require('./component/Component');
var DateUtil = require('./DateUtil');

/**
 * @constructor Range
 * A Range controls a numeric range with a start and end value.
 * The Range adjusts the range based on mouse events or programmatic changes,
 * and triggers events when the range is changing or has been changed.
 * @param {{dom: Object, domProps: Object, emitter: Emitter}} body
 * @param {Object} [options]    See description at Range.setOptions
 */
function Range(body, options) {
  var now = moment().hours(0).minutes(0).seconds(0).milliseconds(0);
  this.start = now.clone().add(-3, 'days').valueOf(); // Number
  this.end = now.clone().add(4, 'days').valueOf(); // Number

  this.body = body;
  this.deltaDifference = 0;
  this.scaleOffset = 0;
  this.startToFront = false;
  this.endToFront = true;

  // default options
  this.defaultOptions = {
    start: null,
    end: null,
    moment: moment,
    direction: 'horizontal', // 'horizontal' or 'vertical'
    moveable: true,
    zoomable: true,
    min: null,
    max: null,
    zoomMin: 10, // milliseconds
    zoomMax: 1000 * 60 * 60 * 24 * 365 * 10000 // milliseconds
  };
  this.options = util.extend({}, this.defaultOptions);

  this.props = {
    touch: {}
  };
  this.animationTimer = null;

  // drag listeners for dragging
  this.body.emitter.on('panstart', this._onDragStart.bind(this));
  this.body.emitter.on('panmove', this._onDrag.bind(this));
  this.body.emitter.on('panend', this._onDragEnd.bind(this));

  // mouse wheel for zooming
  this.body.emitter.on('mousewheel', this._onMouseWheel.bind(this));

  // pinch to zoom
  this.body.emitter.on('touch', this._onTouch.bind(this));
  this.body.emitter.on('pinch', this._onPinch.bind(this));

  this.setOptions(options);
}

Range.prototype = new Component();

/**
 * Set options for the range controller
 * @param {Object} options      Available options:
 *                              {Number | Date | String} start  Start date for the range
 *                              {Number | Date | String} end    End date for the range
 *                              {Number} min    Minimum value for start
 *                              {Number} max    Maximum value for end
 *                              {Number} zoomMin    Set a minimum value for
 *                                                  (end - start).
 *                              {Number} zoomMax    Set a maximum value for
 *                                                  (end - start).
 *                              {Boolean} moveable Enable moving of the range
 *                                                 by dragging. True by default
 *                              {Boolean} zoomable Enable zooming of the range
 *                                                 by pinching/scrolling. True by default
 */
Range.prototype.setOptions = function (options) {
  if (options) {
    // copy the options that we know
    var fields = ['direction', 'min', 'max', 'zoomMin', 'zoomMax', 'moveable', 'zoomable', 'moment', 'activate', 'hiddenDates', 'zoomKey'];
    util.selectiveExtend(fields, this.options, options);

    if ('start' in options || 'end' in options) {
      // apply a new range. both start and end are optional
      this.setRange(options.start, options.end);
    }
  }
};

/**
 * Test whether direction has a valid value
 * @param {String} direction    'horizontal' or 'vertical'
 */
function validateDirection(direction) {
  if (direction != 'horizontal' && direction != 'vertical') {
    throw new TypeError('Unknown direction "' + direction + '". ' + 'Choose "horizontal" or "vertical".');
  }
}

/**
 * Set a new start and end range
 * @param {Date | Number | String} [start]
 * @param {Date | Number | String} [end]
 * @param {boolean | {duration: number, easingFunction: string}} [animation=false]
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 * @param {Boolean} [byUser=false]
 *
 */
Range.prototype.setRange = function (start, end, animation, byUser) {
  if (byUser !== true) {
    byUser = false;
  }
  var finalStart = start != undefined ? util.convert(start, 'Date').valueOf() : null;
  var finalEnd = end != undefined ? util.convert(end, 'Date').valueOf() : null;
  this._cancelAnimation();

  if (animation) {
    // true or an Object
    var me = this;
    var initStart = this.start;
    var initEnd = this.end;
    var duration = typeof animation === 'object' && 'duration' in animation ? animation.duration : 500;
    var easingName = typeof animation === 'object' && 'easingFunction' in animation ? animation.easingFunction : 'easeInOutQuad';
    var easingFunction = util.easingFunctions[easingName];
    if (!easingFunction) {
      throw new Error('Unknown easing function ' + JSON.stringify(easingName) + '. ' + 'Choose from: ' + Object.keys(util.easingFunctions).join(', '));
    }

    var initTime = new Date().valueOf();
    var anyChanged = false;

    var next = function next() {
      if (!me.props.touch.dragging) {
        var now = new Date().valueOf();
        var time = now - initTime;
        var ease = easingFunction(time / duration);
        var done = time > duration;
        var s = done || finalStart === null ? finalStart : initStart + (finalStart - initStart) * ease;
        var e = done || finalEnd === null ? finalEnd : initEnd + (finalEnd - initEnd) * ease;

        changed = me._applyRange(s, e);
        DateUtil.updateHiddenDates(me.options.moment, me.body, me.options.hiddenDates);
        anyChanged = anyChanged || changed;
        if (changed) {
          me.body.emitter.emit('rangechange', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
        }

        if (done) {
          if (anyChanged) {
            me.body.emitter.emit('rangechanged', { start: new Date(me.start), end: new Date(me.end), byUser: byUser });
          }
        } else {
          // animate with as high as possible frame rate, leave 20 ms in between
          // each to prevent the browser from blocking
          me.animationTimer = setTimeout(next, 20);
        }
      }
    };

    return next();
  } else {
    var changed = this._applyRange(finalStart, finalEnd);
    DateUtil.updateHiddenDates(this.options.moment, this.body, this.options.hiddenDates);
    if (changed) {
      var params = { start: new Date(this.start), end: new Date(this.end), byUser: byUser };
      this.body.emitter.emit('rangechange', params);
      this.body.emitter.emit('rangechanged', params);
    }
  }
};

/**
 * Stop an animation
 * @private
 */
Range.prototype._cancelAnimation = function () {
  if (this.animationTimer) {
    clearTimeout(this.animationTimer);
    this.animationTimer = null;
  }
};

/**
 * Set a new start and end range. This method is the same as setRange, but
 * does not trigger a range change and range changed event, and it returns
 * true when the range is changed
 * @param {Number} [start]
 * @param {Number} [end]
 * @return {Boolean} changed
 * @private
 */
Range.prototype._applyRange = function (start, end) {
  var newStart = start != null ? util.convert(start, 'Date').valueOf() : this.start,
      newEnd = end != null ? util.convert(end, 'Date').valueOf() : this.end,
      max = this.options.max != null ? util.convert(this.options.max, 'Date').valueOf() : null,
      min = this.options.min != null ? util.convert(this.options.min, 'Date').valueOf() : null,
      diff;

  // check for valid number
  if (isNaN(newStart) || newStart === null) {
    throw new Error('Invalid start "' + start + '"');
  }
  if (isNaN(newEnd) || newEnd === null) {
    throw new Error('Invalid end "' + end + '"');
  }

  // prevent start < end
  if (newEnd < newStart) {
    newEnd = newStart;
  }

  // prevent start < min
  if (min !== null) {
    if (newStart < min) {
      diff = min - newStart;
      newStart += diff;
      newEnd += diff;

      // prevent end > max
      if (max != null) {
        if (newEnd > max) {
          newEnd = max;
        }
      }
    }
  }

  // prevent end > max
  if (max !== null) {
    if (newEnd > max) {
      diff = newEnd - max;
      newStart -= diff;
      newEnd -= diff;

      // prevent start < min
      if (min != null) {
        if (newStart < min) {
          newStart = min;
        }
      }
    }
  }

  // prevent (end-start) < zoomMin
  if (this.options.zoomMin !== null) {
    var zoomMin = parseFloat(this.options.zoomMin);
    if (zoomMin < 0) {
      zoomMin = 0;
    }
    if (newEnd - newStart < zoomMin) {
      if (this.end - this.start === zoomMin && newStart > this.start && newEnd < this.end) {
        // ignore this action, we are already zoomed to the minimum
        newStart = this.start;
        newEnd = this.end;
      } else {
        // zoom to the minimum
        diff = zoomMin - (newEnd - newStart);
        newStart -= diff / 2;
        newEnd += diff / 2;
      }
    }
  }

  // prevent (end-start) > zoomMax
  if (this.options.zoomMax !== null) {
    var zoomMax = parseFloat(this.options.zoomMax);
    if (zoomMax < 0) {
      zoomMax = 0;
    }

    if (newEnd - newStart > zoomMax) {
      if (this.end - this.start === zoomMax && newStart < this.start && newEnd > this.end) {
        // ignore this action, we are already zoomed to the maximum
        newStart = this.start;
        newEnd = this.end;
      } else {
        // zoom to the maximum
        diff = newEnd - newStart - zoomMax;
        newStart += diff / 2;
        newEnd -= diff / 2;
      }
    }
  }

  var changed = this.start != newStart || this.end != newEnd;

  // if the new range does NOT overlap with the old range, emit checkRangedItems to avoid not showing ranged items (ranged meaning has end time, not necessarily of type Range)
  if (!(newStart >= this.start && newStart <= this.end || newEnd >= this.start && newEnd <= this.end) && !(this.start >= newStart && this.start <= newEnd || this.end >= newStart && this.end <= newEnd)) {
    this.body.emitter.emit('checkRangedItems');
  }

  this.start = newStart;
  this.end = newEnd;
  return changed;
};

/**
 * Retrieve the current range.
 * @return {Object} An object with start and end properties
 */
Range.prototype.getRange = function () {
  return {
    start: this.start,
    end: this.end
  };
};

/**
 * Calculate the conversion offset and scale for current range, based on
 * the provided width
 * @param {Number} width
 * @returns {{offset: number, scale: number}} conversion
 */
Range.prototype.conversion = function (width, totalHidden) {
  return Range.conversion(this.start, this.end, width, totalHidden);
};

/**
 * Static method to calculate the conversion offset and scale for a range,
 * based on the provided start, end, and width
 * @param {Number} start
 * @param {Number} end
 * @param {Number} width
 * @returns {{offset: number, scale: number}} conversion
 */
Range.conversion = function (start, end, width, totalHidden) {
  if (totalHidden === undefined) {
    totalHidden = 0;
  }
  if (width != 0 && end - start != 0) {
    return {
      offset: start,
      scale: width / (end - start - totalHidden)
    };
  } else {
    return {
      offset: 0,
      scale: 1
    };
  }
};

/**
 * Start dragging horizontally or vertically
 * @param {Event} event
 * @private
 */
Range.prototype._onDragStart = function (event) {
  this.deltaDifference = 0;
  this.previousDelta = 0;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // only start dragging when the mouse is inside the current range
  if (!this._isInsideRange(event)) return;

  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  this.props.touch.start = this.start;
  this.props.touch.end = this.end;
  this.props.touch.dragging = true;

  if (this.body.dom.root) {
    this.body.dom.root.style.cursor = 'move';
  }
};

/**
 * Perform dragging operation
 * @param {Event} event
 * @private
 */
Range.prototype._onDrag = function (event) {
  if (!this.props.touch.dragging) return;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // TODO: this may be redundant in hammerjs2
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  var direction = this.options.direction;
  validateDirection(direction);
  var delta = direction == 'horizontal' ? event.deltaX : event.deltaY;
  delta -= this.deltaDifference;
  var interval = this.props.touch.end - this.props.touch.start;

  // normalize dragging speed if cutout is in between.
  var duration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  interval -= duration;

  var width = direction == 'horizontal' ? this.body.domProps.center.width : this.body.domProps.center.height;
  var diffRange = -delta / width * interval;
  var newStart = this.props.touch.start + diffRange;
  var newEnd = this.props.touch.end + diffRange;

  // snapping times away from hidden zones
  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, this.previousDelta - delta, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, this.previousDelta - delta, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    this.deltaDifference += delta;
    this.props.touch.start = safeStart;
    this.props.touch.end = safeEnd;
    this._onDrag(event);
    return;
  }

  this.previousDelta = delta;
  this._applyRange(newStart, newEnd);

  // fire a rangechange event
  this.body.emitter.emit('rangechange', {
    start: new Date(this.start),
    end: new Date(this.end),
    byUser: true
  });
};

/**
 * Stop dragging operation
 * @param {event} event
 * @private
 */
Range.prototype._onDragEnd = function (event) {
  if (!this.props.touch.dragging) return;

  // only allow dragging when configured as movable
  if (!this.options.moveable) return;

  // TODO: this may be redundant in hammerjs2
  // refuse to drag when we where pinching to prevent the timeline make a jump
  // when releasing the fingers in opposite order from the touch screen
  if (!this.props.touch.allowDragging) return;

  this.props.touch.dragging = false;
  if (this.body.dom.root) {
    this.body.dom.root.style.cursor = 'auto';
  }

  // fire a rangechanged event
  this.body.emitter.emit('rangechanged', {
    start: new Date(this.start),
    end: new Date(this.end),
    byUser: true
  });
};

/**
 * Event handler for mouse wheel event, used to zoom
 * Code from http://adomas.org/javascript-mouse-wheel/
 * @param {Event} event
 * @private
 */
Range.prototype._onMouseWheel = function (event) {
  // only allow zooming when configured as zoomable and moveable
  if (!(this.options.zoomable && this.options.moveable)) return;

  // only zoom when the mouse is inside the current range
  if (!this._isInsideRange(event)) return;

  // only zoom when the according key is pressed and the zoomKey option is set
  if (this.options.zoomKey && !event[this.options.zoomKey]) return;

  // retrieve delta
  var delta = 0;
  if (event.wheelDelta) {
    /* IE/Opera. */
    delta = event.wheelDelta / 120;
  } else if (event.detail) {
    /* Mozilla case. */
    // In Mozilla, sign of delta is different than in IE.
    // Also, delta is multiple of 3.
    delta = -event.detail / 3;
  }

  // If delta is nonzero, handle it.
  // Basically, delta is now positive if wheel was scrolled up,
  // and negative, if wheel was scrolled down.
  if (delta) {
    // perform the zoom action. Delta is normally 1 or -1

    // adjust a negative delta such that zooming in with delta 0.1
    // equals zooming out with a delta -0.1
    var scale;
    if (delta < 0) {
      scale = 1 - delta / 5;
    } else {
      scale = 1 / (1 + delta / 5);
    }

    // calculate center, the date to zoom around
    var pointer = getPointer({ x: event.clientX, y: event.clientY }, this.body.dom.center);
    var pointerDate = this._pointerToDate(pointer);

    this.zoom(scale, pointerDate, delta);
  }

  // Prevent default actions caused by mouse wheel
  // (else the page and timeline both zoom and scroll)
  event.preventDefault();
};

/**
 * Start of a touch gesture
 * @private
 */
Range.prototype._onTouch = function (event) {
  this.props.touch.start = this.start;
  this.props.touch.end = this.end;
  this.props.touch.allowDragging = true;
  this.props.touch.center = null;
  this.scaleOffset = 0;
  this.deltaDifference = 0;
};

/**
 * Handle pinch event
 * @param {Event} event
 * @private
 */
Range.prototype._onPinch = function (event) {
  // only allow zooming when configured as zoomable and moveable
  if (!(this.options.zoomable && this.options.moveable)) return;

  this.props.touch.allowDragging = false;

  if (!this.props.touch.center) {
    this.props.touch.center = getPointer(event.center, this.body.dom.center);
  }

  var scale = 1 / (event.scale + this.scaleOffset);
  var centerDate = this._pointerToDate(this.props.touch.center);

  var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, centerDate);
  var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

  // calculate new start and end
  var newStart = centerDate - hiddenDurationBefore + (this.props.touch.start - (centerDate - hiddenDurationBefore)) * scale;
  var newEnd = centerDate + hiddenDurationAfter + (this.props.touch.end - (centerDate + hiddenDurationAfter)) * scale;

  // snapping times away from hidden zones
  this.startToFront = 1 - scale <= 0; // used to do the right auto correction with periodic hidden times
  this.endToFront = scale - 1 <= 0; // used to do the right auto correction with periodic hidden times

  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, 1 - scale, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, scale - 1, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    this.props.touch.start = safeStart;
    this.props.touch.end = safeEnd;
    this.scaleOffset = 1 - event.scale;
    newStart = safeStart;
    newEnd = safeEnd;
  }

  this.setRange(newStart, newEnd, false, true);

  this.startToFront = false; // revert to default
  this.endToFront = true; // revert to default
};

/**
 * Test whether the mouse from a mouse event is inside the visible window,
 * between the current start and end date
 * @param {Object} event
 * @return {boolean} Returns true when inside the visible window
 * @private
 */
Range.prototype._isInsideRange = function (event) {
  // calculate the time where the mouse is, check whether inside
  // and no scroll action should happen.
  var clientX = event.center ? event.center.x : event.clientX;
  var x = clientX - util.getAbsoluteLeft(this.body.dom.centerContainer);
  var time = this.body.util.toTime(x);

  return time >= this.start && time <= this.end;
};

/**
 * Helper function to calculate the center date for zooming
 * @param {{x: Number, y: Number}} pointer
 * @return {number} date
 * @private
 */
Range.prototype._pointerToDate = function (pointer) {
  var conversion;
  var direction = this.options.direction;

  validateDirection(direction);

  if (direction == 'horizontal') {
    return this.body.util.toTime(pointer.x).valueOf();
  } else {
    var height = this.body.domProps.center.height;
    conversion = this.conversion(height);
    return pointer.y / conversion.scale + conversion.offset;
  }
};

/**
 * Get the pointer location relative to the location of the dom element
 * @param {{x: Number, y: Number}} touch
 * @param {Element} element   HTML DOM element
 * @return {{x: Number, y: Number}} pointer
 * @private
 */
function getPointer(touch, element) {
  return {
    x: touch.x - util.getAbsoluteLeft(element),
    y: touch.y - util.getAbsoluteTop(element)
  };
}

/**
 * Zoom the range the given scale in or out. Start and end date will
 * be adjusted, and the timeline will be redrawn. You can optionally give a
 * date around which to zoom.
 * For example, try scale = 0.9 or 1.1
 * @param {Number} scale      Scaling factor. Values above 1 will zoom out,
 *                            values below 1 will zoom in.
 * @param {Number} [center]   Value representing a date around which will
 *                            be zoomed.
 */
Range.prototype.zoom = function (scale, center, delta) {
  // if centerDate is not provided, take it half between start Date and end Date
  if (center == null) {
    center = (this.start + this.end) / 2;
  }

  var hiddenDuration = DateUtil.getHiddenDurationBetween(this.body.hiddenDates, this.start, this.end);
  var hiddenDurationBefore = DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this, center);
  var hiddenDurationAfter = hiddenDuration - hiddenDurationBefore;

  // calculate new start and end
  var newStart = center - hiddenDurationBefore + (this.start - (center - hiddenDurationBefore)) * scale;
  var newEnd = center + hiddenDurationAfter + (this.end - (center + hiddenDurationAfter)) * scale;

  // snapping times away from hidden zones
  this.startToFront = delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
  this.endToFront = -delta > 0 ? false : true; // used to do the right autocorrection with periodic hidden times
  var safeStart = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newStart, delta, true);
  var safeEnd = DateUtil.snapAwayFromHidden(this.body.hiddenDates, newEnd, -delta, true);
  if (safeStart != newStart || safeEnd != newEnd) {
    newStart = safeStart;
    newEnd = safeEnd;
  }

  this.setRange(newStart, newEnd, false, true);

  this.startToFront = false; // revert to default
  this.endToFront = true; // revert to default
};

/**
 * Move the range with a given delta to the left or right. Start and end
 * value will be adjusted. For example, try delta = 0.1 or -0.1
 * @param {Number}  delta     Moving amount. Positive value will move right,
 *                            negative value will move left
 */
Range.prototype.move = function (delta) {
  // zoom start Date and end Date relative to the centerDate
  var diff = this.end - this.start;

  // apply new values
  var newStart = this.start + diff * delta;
  var newEnd = this.end + diff * delta;

  // TODO: reckon with min and max range

  this.start = newStart;
  this.end = newEnd;
};

/**
 * Move the range to a new center point
 * @param {Number} moveTo      New center point of the range
 */
Range.prototype.moveTo = function (moveTo) {
  var center = (this.start + this.end) / 2;

  var diff = center - moveTo;

  // calculate new start and end
  var newStart = this.start - diff;
  var newEnd = this.end - diff;

  this.setRange(newStart, newEnd);
};

module.exports = Range;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9SYW5nZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUM5QixJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDMUMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDekMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUM7QUFDakQsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7Ozs7Ozs7O0FBVXJDLFNBQVMsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDNUIsTUFBSSxHQUFHLEdBQUcsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xFLE1BQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUNuRCxNQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDOztBQUVoRCxNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNqQixNQUFJLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQztBQUN6QixNQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztBQUNyQixNQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztBQUMxQixNQUFJLENBQUMsVUFBVSxHQUFH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Q0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDO0NBQ25CLENBQUM7Ozs7OztBQU1GLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFVBQVMsTUFBTSxFQUFFO0FBQ3hDLE1BQUksTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFBLEdBQUksQ0FBQyxDQUFDOztBQUV6QyxNQUFJLElBQUksR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDOzs7QUFHM0IsTUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7QUFDakMsTUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7O0FBRTdCLE1BQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0NBQ2pDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL1JhbmdlLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgaGFtbWVyVXRpbCA9IHJlcXVpcmUoJy4uL2hhbW1lclV0aWwnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCcuLi9tb2R1bGUvbW9tZW50Jyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9jb21wb25lbnQvQ29tcG9uZW50Jyk7XG52YXIgRGF0ZVV0aWwgPSByZXF1aXJlKCcuL0RhdGVVdGlsJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIFJhbmdlXG4gKiBBIFJhbmdlIGNvbnRyb2xzIGEgbnVtZXJpYyByYW5nZSB3aXRoIGEgc3RhcnQgYW5kIGVuZCB2YWx1ZS5cbiAqIFRoZSBSYW5nZSBhZGp1c3RzIHRoZSByYW5nZSBiYXNlZCBvbiBtb3VzZSBldmVudHMgb3IgcHJvZ3JhbW1hdGljIGNoYW5nZXMsXG4gKiBhbmQgdHJpZ2dlcnMgZXZlbnRzIHdoZW4gdGhlIHJhbmdlIGlzIGNoYW5naW5nIG9yIGhhcyBiZWVuIGNoYW5nZWQuXG4gKiBAcGFyYW0ge3tkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdCwgZW1pdHRlcjogRW1pdHRlcn19IGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgU2VlIGRlc2NyaXB0aW9uIGF0IFJhbmdlLnNldE9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gUmFuZ2UoYm9keSwgb3B0aW9ucykge1xuICB2YXIgbm93ID0gbW9tZW50KCkuaG91cnMoMCkubWludXRlcygwKS5zZWNvbmRzKDApLm1pbGxpc2Vjb25kcygwKTtcbiAgdGhpcy5zdGFydCA9IG5vdy5jbG9uZSgpLmFkZCgtMywgJ2RheXMnKS52YWx1ZU9mKCk7IC8vIE51bWJlclxuICB0aGlzLmVuZCA9IG5vdy5jbG9uZSgpLmFkZCg0LCAnZGF5cycpLnZhbHVlT2YoKTsgICAvLyBOdW1iZXJcblxuICB0aGlzLmJvZHkgPSBib2R5O1xuICB0aGlzLmRlbHRhRGlmZmVyZW5jZSA9IDA7XG4gIHRoaXMuc2NhbGVPZmZzZXQgPSAwO1xuICB0aGlzLnN0YXJ0VG9Gcm9udCA9IGZhbHNlO1xuICB0aGlzLmVuZFRvRnJvbnQgPSB0cnVlO1xuXG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIHN0YXJ0OiBudWxsLFxuICAgIGVuZDogbnVsbCxcbiAgICBtb21lbnQ6IG1vbWVudCxcbiAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJywgLy8gJ2hvcml6b250YWwnIG9yICd2ZXJ0aWNhbCdcbiAgICBtb3ZlYWJsZTogdHJ1ZSxcbiAgICB6b29tYWJsZTogdHJ1ZSxcbiAgICBtaW46IG51bGwsXG4gICAgbWF4OiBudWxsLFxuICAgIHpvb21NaW46IDEwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlsbGlzZWNvbmRzXG4gICAgem9vbU1heDogMTAwMCAqIDYwICogNjAgKiAyNCAqIDM2NSAqIDEwMDAwICAvLyBtaWxsaXNlY29uZHNcbiAgfTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gIHRoaXMucHJvcHMgPSB7XG4gICAgdG91Y2g6IHt9XG4gIH07XG4gIHRoaXMuYW5pbWF0aW9uVGltZXIgPSBudWxsO1xuXG4gIC8vIGRyYWcgbGlzdGVuZXJzIGZvciBkcmFnZ2luZ1xuICB0aGlzLmJvZHkuZW1pdHRlci5vbigncGFuc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpKTtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ3Bhbm1vdmUnLCAgdGhpcy5fb25EcmFnLmJpbmQodGhpcykpO1xuICB0aGlzLmJvZHkuZW1pdHRlci5vbigncGFuZW5kJywgICB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKSk7XG5cbiAgLy8gbW91c2Ugd2hlZWwgZm9yIHpvb21pbmdcbiAgdGhpcy5ib2R5LmVtaXR0ZXIub24oJ21vdXNld2hlZWwnLCB0aGlzLl9vbk1vdXNlV2hlZWwuYmluZCh0aGlzKSk7XG5cbiAgLy8gcGluY2ggdG8gem9vbVxuICB0aGlzLmJvZHkuZW1pdHRlci5vbigndG91Y2gnLCB0aGlzLl9vblRvdWNoLmJpbmQodGhpcykpO1xuICB0aGlzLmJvZHkuZW1pdHRlci5vbigncGluY2gnLCB0aGlzLl9vblBpbmNoLmJpbmQodGhpcykpO1xuXG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbn1cblxuUmFuZ2UucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIFNldCBvcHRpb25zIGZvciB0aGUgcmFuZ2UgY29udHJvbGxlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICBBdmFpbGFibGUgb3B0aW9uczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlciB8IERhdGUgfCBTdHJpbmd9IHN0YXJ0ICBTdGFydCBkYXRlIGZvciB0aGUgcmFuZ2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlciB8IERhdGUgfCBTdHJpbmd9IGVuZCAgICBFbmQgZGF0ZSBmb3IgdGhlIHJhbmdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1pbiAgICBNaW5pbXVtIHZhbHVlIGZvciBzdGFydFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXggICAgTWF4aW11bSB2YWx1ZSBmb3IgZW5kXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IHpvb21NaW4gICAgU2V0IGEgbWluaW11bSB2YWx1ZSBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZW5kIC0gc3RhcnQpLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSB6b29tTWF4ICAgIFNldCBhIG1heGltdW0gdmFsdWUgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVuZCAtIHN0YXJ0KS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IG1vdmVhYmxlIEVuYWJsZSBtb3Zpbmcgb2YgdGhlIHJhbmdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieSBkcmFnZ2luZy4gVHJ1ZSBieSBkZWZhdWx0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSB6b29tYWJsZSBFbmFibGUgem9vbWluZyBvZiB0aGUgcmFuZ2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHBpbmNoaW5nL3Njcm9sbGluZy4gVHJ1ZSBieSBkZWZhdWx0XG4gKi9cblJhbmdlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBjb3B5IHRoZSBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgIHZhciBmaWVsZHMgPSBbXG4gICAgICAnZGlyZWN0aW9uJywgJ21pbicsICdtYXgnLCAnem9vbU1pbicsICd6b29tTWF4JywgJ21vdmVhYmxlJywgJ3pvb21hYmxlJyxcbiAgICAgICdtb21lbnQnLCAnYWN0aXZhdGUnLCAnaGlkZGVuRGF0ZXMnLCAnem9vbUtleSdcbiAgICBdO1xuICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICgnc3RhcnQnIGluIG9wdGlvbnMgfHwgJ2VuZCcgaW4gb3B0aW9ucykge1xuICAgICAgLy8gYXBwbHkgYSBuZXcgcmFuZ2UuIGJvdGggc3RhcnQgYW5kIGVuZCBhcmUgb3B0aW9uYWxcbiAgICAgIHRoaXMuc2V0UmFuZ2Uob3B0aW9ucy5zdGFydCwgb3B0aW9ucy5lbmQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgZGlyZWN0aW9uIGhhcyBhIHZhbGlkIHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uICAgICdob3Jpem9udGFsJyBvciAndmVydGljYWwnXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aW9uIChkaXJlY3Rpb24pIHtcbiAgaWYgKGRpcmVjdGlvbiAhPSAnaG9yaXpvbnRhbCcgJiYgZGlyZWN0aW9uICE9ICd2ZXJ0aWNhbCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGRpcmVjdGlvbiBcIicgKyBkaXJlY3Rpb24gKyAnXCIuICcgK1xuICAgICAgICAnQ2hvb3NlIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi4nKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIG5ldyBzdGFydCBhbmQgZW5kIHJhbmdlXG4gKiBAcGFyYW0ge0RhdGUgfCBOdW1iZXIgfCBTdHJpbmd9IFtzdGFydF1cbiAqIEBwYXJhbSB7RGF0ZSB8IE51bWJlciB8IFN0cmluZ30gW2VuZF1cbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfX0gW2FuaW1hdGlvbj1mYWxzZV1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICogQHBhcmFtIHtCb29sZWFufSBbYnlVc2VyPWZhbHNlXVxuICpcbiAqL1xuUmFuZ2UucHJvdG90eXBlLnNldFJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgYW5pbWF0aW9uLCBieVVzZXIpIHtcbiAgaWYgKGJ5VXNlciAhPT0gdHJ1ZSkge1xuICAgIGJ5VXNlciA9IGZhbHNlO1xuICB9XG4gIHZhciBmaW5hbFN0YXJ0ID0gc3RhcnQgIT0gdW5kZWZpbmVkID8gdXRpbC5jb252ZXJ0KHN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKSA6IG51bGw7XG4gIHZhciBmaW5hbEVuZCAgID0gZW5kICE9IHVuZGVmaW5lZCAgID8gdXRpbC5jb252ZXJ0KGVuZCwgJ0RhdGUnKS52YWx1ZU9mKCkgICA6IG51bGw7XG4gIHRoaXMuX2NhbmNlbEFuaW1hdGlvbigpO1xuXG4gIGlmIChhbmltYXRpb24pIHsgLy8gdHJ1ZSBvciBhbiBPYmplY3RcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBpbml0U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgIHZhciBpbml0RW5kID0gdGhpcy5lbmQ7XG4gICAgdmFyIGR1cmF0aW9uID0gKHR5cGVvZiBhbmltYXRpb24gPT09ICdvYmplY3QnICYmICdkdXJhdGlvbicgaW4gYW5pbWF0aW9uKSA/IGFuaW1hdGlvbi5kdXJhdGlvbiA6IDUwMDtcbiAgICB2YXIgZWFzaW5nTmFtZSA9ICh0eXBlb2YgYW5pbWF0aW9uID09PSAnb2JqZWN0JyAmJiAnZWFzaW5nRnVuY3Rpb24nIGluIGFuaW1hdGlvbikgPyBhbmltYXRpb24uZWFzaW5nRnVuY3Rpb24gOiAnZWFzZUluT3V0UXVhZCc7XG4gICAgdmFyIGVhc2luZ0Z1bmN0aW9uID0gdXRpbC5lYXNpbmdGdW5jdGlvbnNbZWFzaW5nTmFtZV07XG4gICAgaWYgKCFlYXNpbmdGdW5jdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVhc2luZyBmdW5jdGlvbiAnICsgSlNPTi5zdHJpbmdpZnkoZWFzaW5nTmFtZSkgKyAnLiAnICtcbiAgICAgICAgICAnQ2hvb3NlIGZyb206ICcgKyBPYmplY3Qua2V5cyh1dGlsLmVhc2luZ0Z1bmN0aW9ucykuam9pbignLCAnKSk7XG4gICAgfVxuXG4gICAgdmFyIGluaXRUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgdmFyIGFueUNoYW5nZWQgPSBmYWxzZTtcblxuICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFtZS5wcm9wcy50b3VjaC5kcmFnZ2luZykge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIHZhciB0aW1lID0gbm93IC0gaW5pdFRpbWU7XG4gICAgICAgIHZhciBlYXNlID0gZWFzaW5nRnVuY3Rpb24odGltZSAvIGR1cmF0aW9uKTtcbiAgICAgICAgdmFyIGRvbmUgPSB0aW1lID4gZHVyYXRpb247XG4gICAgICAgIHZhciBzID0gKGRvbmUgfHwgZmluYWxTdGFydCA9PT0gbnVsbCkgPyBmaW5hbFN0YXJ0IDogaW5pdFN0YXJ0ICsgKGZpbmFsU3RhcnQgLSBpbml0U3RhcnQpICogZWFzZTtcbiAgICAgICAgdmFyIGUgPSAoZG9uZSB8fCBmaW5hbEVuZCAgID09PSBudWxsKSA/IGZpbmFsRW5kICAgOiBpbml0RW5kICAgKyAoZmluYWxFbmQgICAtIGluaXRFbmQpICAgKiBlYXNlO1xuXG4gICAgICAgIGNoYW5nZWQgPSBtZS5fYXBwbHlSYW5nZShzLCBlKTtcbiAgICAgICAgRGF0ZVV0aWwudXBkYXRlSGlkZGVuRGF0ZXMobWUub3B0aW9ucy5tb21lbnQsIG1lLmJvZHksIG1lLm9wdGlvbnMuaGlkZGVuRGF0ZXMpO1xuICAgICAgICBhbnlDaGFuZ2VkID0gYW55Q2hhbmdlZCB8fCBjaGFuZ2VkO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZScsIHtzdGFydDogbmV3IERhdGUobWUuc3RhcnQpLCBlbmQ6IG5ldyBEYXRlKG1lLmVuZCksIGJ5VXNlcjpieVVzZXJ9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgaWYgKGFueUNoYW5nZWQpIHtcbiAgICAgICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdyYW5nZWNoYW5nZWQnLCB7c3RhcnQ6IG5ldyBEYXRlKG1lLnN0YXJ0KSwgZW5kOiBuZXcgRGF0ZShtZS5lbmQpLCBieVVzZXI6YnlVc2VyfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGFuaW1hdGUgd2l0aCBhcyBoaWdoIGFzIHBvc3NpYmxlIGZyYW1lIHJhdGUsIGxlYXZlIDIwIG1zIGluIGJldHdlZW5cbiAgICAgICAgICAvLyBlYWNoIHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBibG9ja2luZ1xuICAgICAgICAgIG1lLmFuaW1hdGlvblRpbWVyID0gc2V0VGltZW91dChuZXh0LCAyMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX2FwcGx5UmFuZ2UoZmluYWxTdGFydCwgZmluYWxFbmQpO1xuICAgIERhdGVVdGlsLnVwZGF0ZUhpZGRlbkRhdGVzKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keSwgdGhpcy5vcHRpb25zLmhpZGRlbkRhdGVzKTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHtzdGFydDogbmV3IERhdGUodGhpcy5zdGFydCksIGVuZDogbmV3IERhdGUodGhpcy5lbmQpLCBieVVzZXI6YnlVc2VyfTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlJywgcGFyYW1zKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3JhbmdlY2hhbmdlZCcsIHBhcmFtcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFN0b3AgYW4gYW5pbWF0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5SYW5nZS5wcm90b3R5cGUuX2NhbmNlbEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYW5pbWF0aW9uVGltZXIpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltYXRpb25UaW1lcik7XG4gICAgdGhpcy5hbmltYXRpb25UaW1lciA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGEgbmV3IHN0YXJ0IGFuZCBlbmQgcmFuZ2UuIFRoaXMgbWV0aG9kIGlzIHRoZSBzYW1lIGFzIHNldFJhbmdlLCBidXRcbiAqIGRvZXMgbm90IHRyaWdnZXIgYSByYW5nZSBjaGFuZ2UgYW5kIHJhbmdlIGNoYW5nZWQgZXZlbnQsIGFuZCBpdCByZXR1cm5zXG4gKiB0cnVlIHdoZW4gdGhlIHJhbmdlIGlzIGNoYW5nZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdXG4gKiBAcGFyYW0ge051bWJlcn0gW2VuZF1cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fYXBwbHlSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIG5ld1N0YXJ0ID0gKHN0YXJ0ICE9IG51bGwpID8gdXRpbC5jb252ZXJ0KHN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKSA6IHRoaXMuc3RhcnQsXG4gICAgICBuZXdFbmQgICA9IChlbmQgIT0gbnVsbCkgICA/IHV0aWwuY29udmVydChlbmQsICdEYXRlJykudmFsdWVPZigpICAgOiB0aGlzLmVuZCxcbiAgICAgIG1heCA9ICh0aGlzLm9wdGlvbnMubWF4ICE9IG51bGwpID8gdXRpbC5jb252ZXJ0KHRoaXMub3B0aW9ucy5tYXgsICdEYXRlJykudmFsdWVPZigpIDogbnVsbCxcbiAgICAgIG1pbiA9ICh0aGlzLm9wdGlvbnMubWluICE9IG51bGwpID8gdXRpbC5jb252ZXJ0KHRoaXMub3B0aW9ucy5taW4sICdEYXRlJykudmFsdWVPZigpIDogbnVsbCxcbiAgICAgIGRpZmY7XG5cbiAgLy8gY2hlY2sgZm9yIHZhbGlkIG51bWJlclxuICBpZiAoaXNOYU4obmV3U3RhcnQpIHx8IG5ld1N0YXJ0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXJ0IFwiJyArIHN0YXJ0ICsgJ1wiJyk7XG4gIH1cbiAgaWYgKGlzTmFOKG5ld0VuZCkgfHwgbmV3RW5kID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuZCBcIicgKyBlbmQgKyAnXCInKTtcbiAgfVxuXG4gIC8vIHByZXZlbnQgc3RhcnQgPCBlbmRcbiAgaWYgKG5ld0VuZCA8IG5ld1N0YXJ0KSB7XG4gICAgbmV3RW5kID0gbmV3U3RhcnQ7XG4gIH1cblxuICAvLyBwcmV2ZW50IHN0YXJ0IDwgbWluXG4gIGlmIChtaW4gIT09IG51bGwpIHtcbiAgICBpZiAobmV3U3RhcnQgPCBtaW4pIHtcbiAgICAgIGRpZmYgPSAobWluIC0gbmV3U3RhcnQpO1xuICAgICAgbmV3U3RhcnQgKz0gZGlmZjtcbiAgICAgIG5ld0VuZCArPSBkaWZmO1xuXG4gICAgICAvLyBwcmV2ZW50IGVuZCA+IG1heFxuICAgICAgaWYgKG1heCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXdFbmQgPiBtYXgpIHtcbiAgICAgICAgICBuZXdFbmQgPSBtYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwcmV2ZW50IGVuZCA+IG1heFxuICBpZiAobWF4ICE9PSBudWxsKSB7XG4gICAgaWYgKG5ld0VuZCA+IG1heCkge1xuICAgICAgZGlmZiA9IChuZXdFbmQgLSBtYXgpO1xuICAgICAgbmV3U3RhcnQgLT0gZGlmZjtcbiAgICAgIG5ld0VuZCAtPSBkaWZmO1xuXG4gICAgICAvLyBwcmV2ZW50IHN0YXJ0IDwgbWluXG4gICAgICBpZiAobWluICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5ld1N0YXJ0IDwgbWluKSB7XG4gICAgICAgICAgbmV3U3RhcnQgPSBtaW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwcmV2ZW50IChlbmQtc3RhcnQpIDwgem9vbU1pblxuICBpZiAodGhpcy5vcHRpb25zLnpvb21NaW4gIT09IG51bGwpIHtcbiAgICB2YXIgem9vbU1pbiA9IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21NaW4pO1xuICAgIGlmICh6b29tTWluIDwgMCkge1xuICAgICAgem9vbU1pbiA9IDA7XG4gICAgfVxuICAgIGlmICgobmV3RW5kIC0gbmV3U3RhcnQpIDwgem9vbU1pbikge1xuICAgICAgaWYgKCh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpID09PSB6b29tTWluICYmIG5ld1N0YXJ0ID4gdGhpcy5zdGFydCAmJiBuZXdFbmQgPCB0aGlzLmVuZCkge1xuICAgICAgICAvLyBpZ25vcmUgdGhpcyBhY3Rpb24sIHdlIGFyZSBhbHJlYWR5IHpvb21lZCB0byB0aGUgbWluaW11bVxuICAgICAgICBuZXdTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIG5ld0VuZCA9IHRoaXMuZW5kO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHpvb20gdG8gdGhlIG1pbmltdW1cbiAgICAgICAgZGlmZiA9ICh6b29tTWluIC0gKG5ld0VuZCAtIG5ld1N0YXJ0KSk7XG4gICAgICAgIG5ld1N0YXJ0IC09IGRpZmYgLyAyO1xuICAgICAgICBuZXdFbmQgKz0gZGlmZiAvIDI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcHJldmVudCAoZW5kLXN0YXJ0KSA+IHpvb21NYXhcbiAgaWYgKHRoaXMub3B0aW9ucy56b29tTWF4ICE9PSBudWxsKSB7XG4gICAgdmFyIHpvb21NYXggPSBwYXJzZUZsb2F0KHRoaXMub3B0aW9ucy56b29tTWF4KTtcbiAgICBpZiAoem9vbU1heCA8IDApIHtcbiAgICAgIHpvb21NYXggPSAwO1xuICAgIH1cblxuICAgIGlmICgobmV3RW5kIC0gbmV3U3RhcnQpID4gem9vbU1heCkge1xuICAgICAgaWYgKCh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpID09PSB6b29tTWF4ICYmIG5ld1N0YXJ0IDwgdGhpcy5zdGFydCAmJiBuZXdFbmQgPiB0aGlzLmVuZCkge1xuICAgICAgICAvLyBpZ25vcmUgdGhpcyBhY3Rpb24sIHdlIGFyZSBhbHJlYWR5IHpvb21lZCB0byB0aGUgbWF4aW11bVxuICAgICAgICBuZXdTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIG5ld0VuZCA9IHRoaXMuZW5kO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHpvb20gdG8gdGhlIG1heGltdW1cbiAgICAgICAgZGlmZiA9ICgobmV3RW5kIC0gbmV3U3RhcnQpIC0gem9vbU1heCk7XG4gICAgICAgIG5ld1N0YXJ0ICs9IGRpZmYgLyAyO1xuICAgICAgICBuZXdFbmQgLT0gZGlmZiAvIDI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoYW5nZWQgPSAodGhpcy5zdGFydCAhPSBuZXdTdGFydCB8fCB0aGlzLmVuZCAhPSBuZXdFbmQpO1xuXG4gIC8vIGlmIHRoZSBuZXcgcmFuZ2UgZG9lcyBOT1Qgb3ZlcmxhcCB3aXRoIHRoZSBvbGQgcmFuZ2UsIGVtaXQgY2hlY2tSYW5nZWRJdGVtcyB0byBhdm9pZCBub3Qgc2hvd2luZyByYW5nZWQgaXRlbXMgKHJhbmdlZCBtZWFuaW5nIGhhcyBlbmQgdGltZSwgbm90IG5lY2Vzc2FyaWx5IG9mIHR5cGUgUmFuZ2UpXG4gIGlmICghKChuZXdTdGFydCA+PSB0aGlzLnN0YXJ0ICYmIG5ld1N0YXJ0ICAgPD0gdGhpcy5lbmQpIHx8IChuZXdFbmQgICA+PSB0aGlzLnN0YXJ0ICYmIG5ld0VuZCAgIDw9IHRoaXMuZW5kKSkgJiZcbiAgICAgICEoKHRoaXMuc3RhcnQgPj0gbmV3U3RhcnQgJiYgdGhpcy5zdGFydCA8PSBuZXdFbmQpICAgfHwgKHRoaXMuZW5kID49IG5ld1N0YXJ0ICAgJiYgdGhpcy5lbmQgPD0gbmV3RW5kKSApKSB7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgnY2hlY2tSYW5nZWRJdGVtcycpO1xuICB9XG5cbiAgdGhpcy5zdGFydCA9IG5ld1N0YXJ0O1xuICB0aGlzLmVuZCA9IG5ld0VuZDtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IHJhbmdlLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXNcbiAqL1xuUmFuZ2UucHJvdG90eXBlLmdldFJhbmdlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgZW5kOiB0aGlzLmVuZFxuICB9O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGNvbnZlcnNpb24gb2Zmc2V0IGFuZCBzY2FsZSBmb3IgY3VycmVudCByYW5nZSwgYmFzZWQgb25cbiAqIHRoZSBwcm92aWRlZCB3aWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gKiBAcmV0dXJucyB7e29mZnNldDogbnVtYmVyLCBzY2FsZTogbnVtYmVyfX0gY29udmVyc2lvblxuICovXG5SYW5nZS5wcm90b3R5cGUuY29udmVyc2lvbiA9IGZ1bmN0aW9uICh3aWR0aCwgdG90YWxIaWRkZW4pIHtcbiAgcmV0dXJuIFJhbmdlLmNvbnZlcnNpb24odGhpcy5zdGFydCwgdGhpcy5lbmQsIHdpZHRoLCB0b3RhbEhpZGRlbik7XG59O1xuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgdG8gY2FsY3VsYXRlIHRoZSBjb252ZXJzaW9uIG9mZnNldCBhbmQgc2NhbGUgZm9yIGEgcmFuZ2UsXG4gKiBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgc3RhcnQsIGVuZCwgYW5kIHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogQHJldHVybnMge3tvZmZzZXQ6IG51bWJlciwgc2NhbGU6IG51bWJlcn19IGNvbnZlcnNpb25cbiAqL1xuUmFuZ2UuY29udmVyc2lvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB3aWR0aCwgdG90YWxIaWRkZW4pIHtcbiAgaWYgKHRvdGFsSGlkZGVuID09PSB1bmRlZmluZWQpIHtcbiAgICB0b3RhbEhpZGRlbiA9IDA7XG4gIH1cbiAgaWYgKHdpZHRoICE9IDAgJiYgKGVuZCAtIHN0YXJ0ICE9IDApKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICBzY2FsZTogd2lkdGggLyAoZW5kIC0gc3RhcnQgLSB0b3RhbEhpZGRlbilcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIHNjYWxlOiAxXG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydCBkcmFnZ2luZyBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuICB0aGlzLmRlbHRhRGlmZmVyZW5jZSA9IDA7XG4gIHRoaXMucHJldmlvdXNEZWx0YSA9IDA7XG5cbiAgLy8gb25seSBhbGxvdyBkcmFnZ2luZyB3aGVuIGNvbmZpZ3VyZWQgYXMgbW92YWJsZVxuICBpZiAoIXRoaXMub3B0aW9ucy5tb3ZlYWJsZSkgcmV0dXJuO1xuXG4gIC8vIG9ubHkgc3RhcnQgZHJhZ2dpbmcgd2hlbiB0aGUgbW91c2UgaXMgaW5zaWRlIHRoZSBjdXJyZW50IHJhbmdlXG4gIGlmICghdGhpcy5faXNJbnNpZGVSYW5nZShldmVudCkpIHJldHVybjtcblxuICAvLyByZWZ1c2UgdG8gZHJhZyB3aGVuIHdlIHdoZXJlIHBpbmNoaW5nIHRvIHByZXZlbnQgdGhlIHRpbWVsaW5lIG1ha2UgYSBqdW1wXG4gIC8vIHdoZW4gcmVsZWFzaW5nIHRoZSBmaW5nZXJzIGluIG9wcG9zaXRlIG9yZGVyIGZyb20gdGhlIHRvdWNoIHNjcmVlblxuICBpZiAoIXRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZykgcmV0dXJuO1xuXG4gIHRoaXMucHJvcHMudG91Y2guc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICB0aGlzLnByb3BzLnRvdWNoLmVuZCA9IHRoaXMuZW5kO1xuICB0aGlzLnByb3BzLnRvdWNoLmRyYWdnaW5nID0gdHJ1ZTtcblxuICBpZiAodGhpcy5ib2R5LmRvbS5yb290KSB7XG4gICAgdGhpcy5ib2R5LmRvbS5yb290LnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtIGRyYWdnaW5nIG9wZXJhdGlvblxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghdGhpcy5wcm9wcy50b3VjaC5kcmFnZ2luZykgcmV0dXJuO1xuXG4gIC8vIG9ubHkgYWxsb3cgZHJhZ2dpbmcgd2hlbiBjb25maWd1cmVkIGFzIG1vdmFibGVcbiAgaWYgKCF0aGlzLm9wdGlvbnMubW92ZWFibGUpIHJldHVybjtcblxuICAvLyBUT0RPOiB0aGlzIG1heSBiZSByZWR1bmRhbnQgaW4gaGFtbWVyanMyXG4gIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgLy8gd2hlbiByZWxlYXNpbmcgdGhlIGZpbmdlcnMgaW4gb3Bwb3NpdGUgb3JkZXIgZnJvbSB0aGUgdG91Y2ggc2NyZWVuXG4gIGlmICghdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nKSByZXR1cm47XG5cbiAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gIHZhbGlkYXRlRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gIHZhciBkZWx0YSA9IChkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKSA/IGV2ZW50LmRlbHRhWCA6IGV2ZW50LmRlbHRhWTtcbiAgZGVsdGEgLT0gdGhpcy5kZWx0YURpZmZlcmVuY2U7XG4gIHZhciBpbnRlcnZhbCA9ICh0aGlzLnByb3BzLnRvdWNoLmVuZCAtIHRoaXMucHJvcHMudG91Y2guc3RhcnQpO1xuXG4gIC8vIG5vcm1hbGl6ZSBkcmFnZ2luZyBzcGVlZCBpZiBjdXRvdXQgaXMgaW4gYmV0d2Vlbi5cbiAgdmFyIGR1cmF0aW9uID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgdGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICBpbnRlcnZhbCAtPSBkdXJhdGlvbjtcblxuICB2YXIgd2lkdGggPSAoZGlyZWN0aW9uID09ICdob3Jpem9udGFsJykgPyB0aGlzLmJvZHkuZG9tUHJvcHMuY2VudGVyLndpZHRoIDogdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlci5oZWlnaHQ7XG4gIHZhciBkaWZmUmFuZ2UgPSAtZGVsdGEgLyB3aWR0aCAqIGludGVydmFsO1xuICB2YXIgbmV3U3RhcnQgPSB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ICsgZGlmZlJhbmdlO1xuICB2YXIgbmV3RW5kID0gdGhpcy5wcm9wcy50b3VjaC5lbmQgKyBkaWZmUmFuZ2U7XG5cbiAgLy8gc25hcHBpbmcgdGltZXMgYXdheSBmcm9tIGhpZGRlbiB6b25lc1xuICB2YXIgc2FmZVN0YXJ0ID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3U3RhcnQsIHRoaXMucHJldmlvdXNEZWx0YS1kZWx0YSwgdHJ1ZSk7XG4gIHZhciBzYWZlRW5kID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3RW5kLCB0aGlzLnByZXZpb3VzRGVsdGEtZGVsdGEsIHRydWUpO1xuICBpZiAoc2FmZVN0YXJ0ICE9IG5ld1N0YXJ0IHx8IHNhZmVFbmQgIT0gbmV3RW5kKSB7XG4gICAgdGhpcy5kZWx0YURpZmZlcmVuY2UgKz0gZGVsdGE7XG4gICAgdGhpcy5wcm9wcy50b3VjaC5zdGFydCA9IHNhZmVTdGFydDtcbiAgICB0aGlzLnByb3BzLnRvdWNoLmVuZCA9IHNhZmVFbmQ7XG4gICAgdGhpcy5fb25EcmFnKGV2ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnByZXZpb3VzRGVsdGEgPSBkZWx0YTtcbiAgdGhpcy5fYXBwbHlSYW5nZShuZXdTdGFydCwgbmV3RW5kKTtcblxuICAvLyBmaXJlIGEgcmFuZ2VjaGFuZ2UgZXZlbnRcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2UnLCB7XG4gICAgc3RhcnQ6IG5ldyBEYXRlKHRoaXMuc3RhcnQpLFxuICAgIGVuZDogICBuZXcgRGF0ZSh0aGlzLmVuZCksXG4gICAgYnlVc2VyOiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBTdG9wIGRyYWdnaW5nIG9wZXJhdGlvblxuICogQHBhcmFtIHtldmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghdGhpcy5wcm9wcy50b3VjaC5kcmFnZ2luZykgcmV0dXJuO1xuXG4gIC8vIG9ubHkgYWxsb3cgZHJhZ2dpbmcgd2hlbiBjb25maWd1cmVkIGFzIG1vdmFibGVcbiAgaWYgKCF0aGlzLm9wdGlvbnMubW92ZWFibGUpIHJldHVybjtcblxuICAvLyBUT0RPOiB0aGlzIG1heSBiZSByZWR1bmRhbnQgaW4gaGFtbWVyanMyXG4gIC8vIHJlZnVzZSB0byBkcmFnIHdoZW4gd2Ugd2hlcmUgcGluY2hpbmcgdG8gcHJldmVudCB0aGUgdGltZWxpbmUgbWFrZSBhIGp1bXBcbiAgLy8gd2hlbiByZWxlYXNpbmcgdGhlIGZpbmdlcnMgaW4gb3Bwb3NpdGUgb3JkZXIgZnJvbSB0aGUgdG91Y2ggc2NyZWVuXG4gIGlmICghdGhpcy5wcm9wcy50b3VjaC5hbGxvd0RyYWdnaW5nKSByZXR1cm47XG5cbiAgdGhpcy5wcm9wcy50b3VjaC5kcmFnZ2luZyA9IGZhbHNlO1xuICBpZiAodGhpcy5ib2R5LmRvbS5yb290KSB7XG4gICAgdGhpcy5ib2R5LmRvbS5yb290LnN0eWxlLmN1cnNvciA9ICdhdXRvJztcbiAgfVxuXG4gIC8vIGZpcmUgYSByYW5nZWNoYW5nZWQgZXZlbnRcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdCgncmFuZ2VjaGFuZ2VkJywge1xuICAgIHN0YXJ0OiBuZXcgRGF0ZSh0aGlzLnN0YXJ0KSxcbiAgICBlbmQ6ICAgbmV3IERhdGUodGhpcy5lbmQpLFxuICAgIGJ5VXNlcjogdHJ1ZVxuICB9KTtcbn07XG5cbi8qKlxuICogRXZlbnQgaGFuZGxlciBmb3IgbW91c2Ugd2hlZWwgZXZlbnQsIHVzZWQgdG8gem9vbVxuICogQ29kZSBmcm9tIGh0dHA6Ly9hZG9tYXMub3JnL2phdmFzY3JpcHQtbW91c2Utd2hlZWwvXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9vbk1vdXNlV2hlZWwgPSBmdW5jdGlvbihldmVudCkge1xuICAvLyBvbmx5IGFsbG93IHpvb21pbmcgd2hlbiBjb25maWd1cmVkIGFzIHpvb21hYmxlIGFuZCBtb3ZlYWJsZVxuICBpZiAoISh0aGlzLm9wdGlvbnMuem9vbWFibGUgJiYgdGhpcy5vcHRpb25zLm1vdmVhYmxlKSkgcmV0dXJuO1xuXG4gIC8vIG9ubHkgem9vbSB3aGVuIHRoZSBtb3VzZSBpcyBpbnNpZGUgdGhlIGN1cnJlbnQgcmFuZ2VcbiAgaWYgKCF0aGlzLl9pc0luc2lkZVJhbmdlKGV2ZW50KSkgcmV0dXJuO1xuICBcbiAgLy8gb25seSB6b29tIHdoZW4gdGhlIGFjY29yZGluZyBrZXkgaXMgcHJlc3NlZCBhbmQgdGhlIHpvb21LZXkgb3B0aW9uIGlzIHNldFxuICBpZiAodGhpcy5vcHRpb25zLnpvb21LZXkgJiYgIWV2ZW50W3RoaXMub3B0aW9ucy56b29tS2V5XSkgcmV0dXJuO1xuXG4gIC8vIHJldHJpZXZlIGRlbHRhXG4gIHZhciBkZWx0YSA9IDA7XG4gIGlmIChldmVudC53aGVlbERlbHRhKSB7IC8qIElFL09wZXJhLiAqL1xuICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YSAvIDEyMDtcbiAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwpIHsgLyogTW96aWxsYSBjYXNlLiAqL1xuICAgIC8vIEluIE1vemlsbGEsIHNpZ24gb2YgZGVsdGEgaXMgZGlmZmVyZW50IHRoYW4gaW4gSUUuXG4gICAgLy8gQWxzbywgZGVsdGEgaXMgbXVsdGlwbGUgb2YgMy5cbiAgICBkZWx0YSA9IC1ldmVudC5kZXRhaWwgLyAzO1xuICB9XG5cbiAgLy8gSWYgZGVsdGEgaXMgbm9uemVybywgaGFuZGxlIGl0LlxuICAvLyBCYXNpY2FsbHksIGRlbHRhIGlzIG5vdyBwb3NpdGl2ZSBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgdXAsXG4gIC8vIGFuZCBuZWdhdGl2ZSwgaWYgd2hlZWwgd2FzIHNjcm9sbGVkIGRvd24uXG4gIGlmIChkZWx0YSkge1xuICAgIC8vIHBlcmZvcm0gdGhlIHpvb20gYWN0aW9uLiBEZWx0YSBpcyBub3JtYWxseSAxIG9yIC0xXG5cbiAgICAvLyBhZGp1c3QgYSBuZWdhdGl2ZSBkZWx0YSBzdWNoIHRoYXQgem9vbWluZyBpbiB3aXRoIGRlbHRhIDAuMVxuICAgIC8vIGVxdWFscyB6b29taW5nIG91dCB3aXRoIGEgZGVsdGEgLTAuMVxuICAgIHZhciBzY2FsZTtcbiAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICBzY2FsZSA9IDEgLSAoZGVsdGEgLyA1KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzY2FsZSA9IDEgLyAoMSArIChkZWx0YSAvIDUpKSA7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIGNlbnRlciwgdGhlIGRhdGUgdG8gem9vbSBhcm91bmRcbiAgICB2YXIgcG9pbnRlciA9IGdldFBvaW50ZXIoe3g6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFl9LCB0aGlzLmJvZHkuZG9tLmNlbnRlcik7XG4gICAgdmFyIHBvaW50ZXJEYXRlID0gdGhpcy5fcG9pbnRlclRvRGF0ZShwb2ludGVyKTtcblxuICAgIHRoaXMuem9vbShzY2FsZSwgcG9pbnRlckRhdGUsIGRlbHRhKTtcbiAgfVxuXG4gIC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25zIGNhdXNlZCBieSBtb3VzZSB3aGVlbFxuICAvLyAoZWxzZSB0aGUgcGFnZSBhbmQgdGltZWxpbmUgYm90aCB6b29tIGFuZCBzY3JvbGwpXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG4vKipcbiAqIFN0YXJ0IG9mIGEgdG91Y2ggZ2VzdHVyZVxuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9vblRvdWNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHRoaXMucHJvcHMudG91Y2guc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICB0aGlzLnByb3BzLnRvdWNoLmVuZCA9IHRoaXMuZW5kO1xuICB0aGlzLnByb3BzLnRvdWNoLmFsbG93RHJhZ2dpbmcgPSB0cnVlO1xuICB0aGlzLnByb3BzLnRvdWNoLmNlbnRlciA9IG51bGw7XG4gIHRoaXMuc2NhbGVPZmZzZXQgPSAwO1xuICB0aGlzLmRlbHRhRGlmZmVyZW5jZSA9IDA7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBwaW5jaCBldmVudFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fb25QaW5jaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBvbmx5IGFsbG93IHpvb21pbmcgd2hlbiBjb25maWd1cmVkIGFzIHpvb21hYmxlIGFuZCBtb3ZlYWJsZVxuICBpZiAoISh0aGlzLm9wdGlvbnMuem9vbWFibGUgJiYgdGhpcy5vcHRpb25zLm1vdmVhYmxlKSkgcmV0dXJuO1xuXG4gIHRoaXMucHJvcHMudG91Y2guYWxsb3dEcmFnZ2luZyA9IGZhbHNlO1xuXG4gIGlmICghdGhpcy5wcm9wcy50b3VjaC5jZW50ZXIpIHtcbiAgICB0aGlzLnByb3BzLnRvdWNoLmNlbnRlciA9IGdldFBvaW50ZXIoZXZlbnQuY2VudGVyLCB0aGlzLmJvZHkuZG9tLmNlbnRlcik7XG4gIH1cblxuICB2YXIgc2NhbGUgPSAxIC8gKGV2ZW50LnNjYWxlICsgdGhpcy5zY2FsZU9mZnNldCk7XG4gIHZhciBjZW50ZXJEYXRlID0gdGhpcy5fcG9pbnRlclRvRGF0ZSh0aGlzLnByb3BzLnRvdWNoLmNlbnRlcik7XG5cbiAgdmFyIGhpZGRlbkR1cmF0aW9uID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgdGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICB2YXIgaGlkZGVuRHVyYXRpb25CZWZvcmUgPSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJlZm9yZSh0aGlzLm9wdGlvbnMubW9tZW50LCB0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIHRoaXMsIGNlbnRlckRhdGUpO1xuICB2YXIgaGlkZGVuRHVyYXRpb25BZnRlciA9IGhpZGRlbkR1cmF0aW9uIC0gaGlkZGVuRHVyYXRpb25CZWZvcmU7XG5cbiAgLy8gY2FsY3VsYXRlIG5ldyBzdGFydCBhbmQgZW5kXG4gIHZhciBuZXdTdGFydCA9IChjZW50ZXJEYXRlIC0gaGlkZGVuRHVyYXRpb25CZWZvcmUpICsgKHRoaXMucHJvcHMudG91Y2guc3RhcnQgLSAoY2VudGVyRGF0ZSAtIGhpZGRlbkR1cmF0aW9uQmVmb3JlKSkgKiBzY2FsZTtcbiAgdmFyIG5ld0VuZCA9IChjZW50ZXJEYXRlICsgaGlkZGVuRHVyYXRpb25BZnRlcikgKyAodGhpcy5wcm9wcy50b3VjaC5lbmQgLSAoY2VudGVyRGF0ZSArIGhpZGRlbkR1cmF0aW9uQWZ0ZXIpKSAqIHNjYWxlO1xuXG4gIC8vIHNuYXBwaW5nIHRpbWVzIGF3YXkgZnJvbSBoaWRkZW4gem9uZXNcbiAgdGhpcy5zdGFydFRvRnJvbnQgPSAxIC0gc2NhbGUgPD0gMDsgLy8gdXNlZCB0byBkbyB0aGUgcmlnaHQgYXV0byBjb3JyZWN0aW9uIHdpdGggcGVyaW9kaWMgaGlkZGVuIHRpbWVzXG4gIHRoaXMuZW5kVG9Gcm9udCA9IHNjYWxlIC0gMSA8PSAwOyAgIC8vIHVzZWQgdG8gZG8gdGhlIHJpZ2h0IGF1dG8gY29ycmVjdGlvbiB3aXRoIHBlcmlvZGljIGhpZGRlbiB0aW1lc1xuXG4gIHZhciBzYWZlU3RhcnQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdTdGFydCwgMSAtIHNjYWxlLCB0cnVlKTtcbiAgdmFyIHNhZmVFbmQgPSBEYXRlVXRpbC5zbmFwQXdheUZyb21IaWRkZW4odGhpcy5ib2R5LmhpZGRlbkRhdGVzLCBuZXdFbmQsIHNjYWxlIC0gMSwgdHJ1ZSk7XG4gIGlmIChzYWZlU3RhcnQgIT0gbmV3U3RhcnQgfHwgc2FmZUVuZCAhPSBuZXdFbmQpIHtcbiAgICB0aGlzLnByb3BzLnRvdWNoLnN0YXJ0ID0gc2FmZVN0YXJ0O1xuICAgIHRoaXMucHJvcHMudG91Y2guZW5kID0gc2FmZUVuZDtcbiAgICB0aGlzLnNjYWxlT2Zmc2V0ID0gMSAtIGV2ZW50LnNjYWxlO1xuICAgIG5ld1N0YXJ0ID0gc2FmZVN0YXJ0O1xuICAgIG5ld0VuZCA9IHNhZmVFbmQ7XG4gIH1cblxuICB0aGlzLnNldFJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQsIGZhbHNlLCB0cnVlKTtcblxuICB0aGlzLnN0YXJ0VG9Gcm9udCA9IGZhbHNlOyAvLyByZXZlcnQgdG8gZGVmYXVsdFxuICB0aGlzLmVuZFRvRnJvbnQgPSB0cnVlOyAvLyByZXZlcnQgdG8gZGVmYXVsdFxufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIG1vdXNlIGZyb20gYSBtb3VzZSBldmVudCBpcyBpbnNpZGUgdGhlIHZpc2libGUgd2luZG93LFxuICogYmV0d2VlbiB0aGUgY3VycmVudCBzdGFydCBhbmQgZW5kIGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gaW5zaWRlIHRoZSB2aXNpYmxlIHdpbmRvd1xuICogQHByaXZhdGVcbiAqL1xuUmFuZ2UucHJvdG90eXBlLl9pc0luc2lkZVJhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgLy8gY2FsY3VsYXRlIHRoZSB0aW1lIHdoZXJlIHRoZSBtb3VzZSBpcywgY2hlY2sgd2hldGhlciBpbnNpZGVcbiAgLy8gYW5kIG5vIHNjcm9sbCBhY3Rpb24gc2hvdWxkIGhhcHBlbi5cbiAgdmFyIGNsaWVudFggPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueCA6IGV2ZW50LmNsaWVudFg7XG4gIHZhciB4ID0gY2xpZW50WCAtIHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuYm9keS5kb20uY2VudGVyQ29udGFpbmVyKTtcbiAgdmFyIHRpbWUgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoeCk7XG5cbiAgcmV0dXJuIHRpbWUgPj0gdGhpcy5zdGFydCAmJiB0aW1lIDw9IHRoaXMuZW5kO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBjZW50ZXIgZGF0ZSBmb3Igem9vbWluZ1xuICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb2ludGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGRhdGVcbiAqIEBwcml2YXRlXG4gKi9cblJhbmdlLnByb3RvdHlwZS5fcG9pbnRlclRvRGF0ZSA9IGZ1bmN0aW9uIChwb2ludGVyKSB7XG4gIHZhciBjb252ZXJzaW9uO1xuICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcblxuICB2YWxpZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pO1xuXG4gIGlmIChkaXJlY3Rpb24gPT0gJ2hvcml6b250YWwnKSB7XG4gICAgcmV0dXJuIHRoaXMuYm9keS51dGlsLnRvVGltZShwb2ludGVyLngpLnZhbHVlT2YoKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5ib2R5LmRvbVByb3BzLmNlbnRlci5oZWlnaHQ7XG4gICAgY29udmVyc2lvbiA9IHRoaXMuY29udmVyc2lvbihoZWlnaHQpO1xuICAgIHJldHVybiBwb2ludGVyLnkgLyBjb252ZXJzaW9uLnNjYWxlICsgY29udmVyc2lvbi5vZmZzZXQ7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBwb2ludGVyIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBsb2NhdGlvbiBvZiB0aGUgZG9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7e3g6IE51bWJlciwgeTogTnVtYmVyfX0gdG91Y2hcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAgIEhUTUwgRE9NIGVsZW1lbnRcbiAqIEByZXR1cm4ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvaW50ZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50ZXIgKHRvdWNoLCBlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgeDogdG91Y2gueCAtIHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KGVsZW1lbnQpLFxuICAgIHk6IHRvdWNoLnkgLSB1dGlsLmdldEFic29sdXRlVG9wKGVsZW1lbnQpXG4gIH07XG59XG5cbi8qKlxuICogWm9vbSB0aGUgcmFuZ2UgdGhlIGdpdmVuIHNjYWxlIGluIG9yIG91dC4gU3RhcnQgYW5kIGVuZCBkYXRlIHdpbGxcbiAqIGJlIGFkanVzdGVkLCBhbmQgdGhlIHRpbWVsaW5lIHdpbGwgYmUgcmVkcmF3bi4gWW91IGNhbiBvcHRpb25hbGx5IGdpdmUgYVxuICogZGF0ZSBhcm91bmQgd2hpY2ggdG8gem9vbS5cbiAqIEZvciBleGFtcGxlLCB0cnkgc2NhbGUgPSAwLjkgb3IgMS4xXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgICAgICBTY2FsaW5nIGZhY3Rvci4gVmFsdWVzIGFib3ZlIDEgd2lsbCB6b29tIG91dCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBiZWxvdyAxIHdpbGwgem9vbSBpbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY2VudGVyXSAgIFZhbHVlIHJlcHJlc2VudGluZyBhIGRhdGUgYXJvdW5kIHdoaWNoIHdpbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHpvb21lZC5cbiAqL1xuUmFuZ2UucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbihzY2FsZSwgY2VudGVyLCBkZWx0YSkge1xuICAvLyBpZiBjZW50ZXJEYXRlIGlzIG5vdCBwcm92aWRlZCwgdGFrZSBpdCBoYWxmIGJldHdlZW4gc3RhcnQgRGF0ZSBhbmQgZW5kIERhdGVcbiAgaWYgKGNlbnRlciA9PSBudWxsKSB7XG4gICAgY2VudGVyID0gKHRoaXMuc3RhcnQgKyB0aGlzLmVuZCkgLyAyO1xuICB9XG5cbiAgdmFyIGhpZGRlbkR1cmF0aW9uID0gRGF0ZVV0aWwuZ2V0SGlkZGVuRHVyYXRpb25CZXR3ZWVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgdGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICB2YXIgaGlkZGVuRHVyYXRpb25CZWZvcmUgPSBEYXRlVXRpbC5nZXRIaWRkZW5EdXJhdGlvbkJlZm9yZSh0aGlzLm9wdGlvbnMubW9tZW50LCB0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIHRoaXMsIGNlbnRlcik7XG4gIHZhciBoaWRkZW5EdXJhdGlvbkFmdGVyID0gaGlkZGVuRHVyYXRpb24gLSBoaWRkZW5EdXJhdGlvbkJlZm9yZTtcblxuICAvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IGFuZCBlbmRcbiAgdmFyIG5ld1N0YXJ0ID0gKGNlbnRlci1oaWRkZW5EdXJhdGlvbkJlZm9yZSkgKyAodGhpcy5zdGFydCAtIChjZW50ZXItaGlkZGVuRHVyYXRpb25CZWZvcmUpKSAqIHNjYWxlO1xuICB2YXIgbmV3RW5kICAgPSAoY2VudGVyK2hpZGRlbkR1cmF0aW9uQWZ0ZXIpICsgKHRoaXMuZW5kIC0gKGNlbnRlcitoaWRkZW5EdXJhdGlvbkFmdGVyKSkgKiBzY2FsZTtcblxuICAvLyBzbmFwcGluZyB0aW1lcyBhd2F5IGZyb20gaGlkZGVuIHpvbmVzXG4gIHRoaXMuc3RhcnRUb0Zyb250ID0gZGVsdGEgPiAwID8gZmFsc2UgOiB0cnVlOyAvLyB1c2VkIHRvIGRvIHRoZSByaWdodCBhdXRvY29ycmVjdGlvbiB3aXRoIHBlcmlvZGljIGhpZGRlbiB0aW1lc1xuICB0aGlzLmVuZFRvRnJvbnQgPSAtZGVsdGEgID4gMCA/IGZhbHNlIDogdHJ1ZTsgLy8gdXNlZCB0byBkbyB0aGUgcmlnaHQgYXV0b2NvcnJlY3Rpb24gd2l0aCBwZXJpb2RpYyBoaWRkZW4gdGltZXNcbiAgdmFyIHNhZmVTdGFydCA9IERhdGVVdGlsLnNuYXBBd2F5RnJvbUhpZGRlbih0aGlzLmJvZHkuaGlkZGVuRGF0ZXMsIG5ld1N0YXJ0LCBkZWx0YSwgdHJ1ZSk7XG4gIHZhciBzYWZlRW5kID0gRGF0ZVV0aWwuc25hcEF3YXlGcm9tSGlkZGVuKHRoaXMuYm9keS5oaWRkZW5EYXRlcywgbmV3RW5kLCAtZGVsdGEsIHRydWUpO1xuICBpZiAoc2FmZVN0YXJ0ICE9IG5ld1N0YXJ0IHx8IHNhZmVFbmQgIT0gbmV3RW5kKSB7XG4gICAgbmV3U3RhcnQgPSBzYWZlU3RhcnQ7XG4gICAgbmV3RW5kID0gc2FmZUVuZDtcbiAgfVxuXG4gIHRoaXMuc2V0UmFuZ2UobmV3U3RhcnQsIG5ld0VuZCwgZmFsc2UsIHRydWUpO1xuXG4gIHRoaXMuc3RhcnRUb0Zyb250ID0gZmFsc2U7IC8vIHJldmVydCB0byBkZWZhdWx0XG4gIHRoaXMuZW5kVG9Gcm9udCA9IHRydWU7IC8vIHJldmVydCB0byBkZWZhdWx0XG59O1xuXG5cblxuLyoqXG4gKiBNb3ZlIHRoZSByYW5nZSB3aXRoIGEgZ2l2ZW4gZGVsdGEgdG8gdGhlIGxlZnQgb3IgcmlnaHQuIFN0YXJ0IGFuZCBlbmRcbiAqIHZhbHVlIHdpbGwgYmUgYWRqdXN0ZWQuIEZvciBleGFtcGxlLCB0cnkgZGVsdGEgPSAwLjEgb3IgLTAuMVxuICogQHBhcmFtIHtOdW1iZXJ9ICBkZWx0YSAgICAgTW92aW5nIGFtb3VudC4gUG9zaXRpdmUgdmFsdWUgd2lsbCBtb3ZlIHJpZ2h0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVnYXRpdmUgdmFsdWUgd2lsbCBtb3ZlIGxlZnRcbiAqL1xuUmFuZ2UucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihkZWx0YSkge1xuICAvLyB6b29tIHN0YXJ0IERhdGUgYW5kIGVuZCBEYXRlIHJlbGF0aXZlIHRvIHRoZSBjZW50ZXJEYXRlXG4gIHZhciBkaWZmID0gKHRoaXMuZW5kIC0gdGhpcy5zdGFydCk7XG5cbiAgLy8gYXBwbHkgbmV3IHZhbHVlc1xuICB2YXIgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0ICsgZGlmZiAqIGRlbHRhO1xuICB2YXIgbmV3RW5kID0gdGhpcy5lbmQgKyBkaWZmICogZGVsdGE7XG5cbiAgLy8gVE9ETzogcmVja29uIHdpdGggbWluIGFuZCBtYXggcmFuZ2VcblxuICB0aGlzLnN0YXJ0ID0gbmV3U3RhcnQ7XG4gIHRoaXMuZW5kID0gbmV3RW5kO1xufTtcblxuLyoqXG4gKiBNb3ZlIHRoZSByYW5nZSB0byBhIG5ldyBjZW50ZXIgcG9pbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtb3ZlVG8gICAgICBOZXcgY2VudGVyIHBvaW50IG9mIHRoZSByYW5nZVxuICovXG5SYW5nZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24obW92ZVRvKSB7XG4gIHZhciBjZW50ZXIgPSAodGhpcy5zdGFydCArIHRoaXMuZW5kKSAvIDI7XG5cbiAgdmFyIGRpZmYgPSBjZW50ZXIgLSBtb3ZlVG87XG5cbiAgLy8gY2FsY3VsYXRlIG5ldyBzdGFydCBhbmQgZW5kXG4gIHZhciBuZXdTdGFydCA9IHRoaXMuc3RhcnQgLSBkaWZmO1xuICB2YXIgbmV3RW5kID0gdGhpcy5lbmQgLSBkaWZmO1xuXG4gIHRoaXMuc2V0UmFuZ2UobmV3U3RhcnQsIG5ld0VuZCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlO1xuIl19
},{"../hammerUtil":18,"../module/moment":20,"../util":46,"./DateUtil":27,"./component/Component":33}],29:[function(require,module,exports){
// Utility functions for ordering and stacking of items
'use strict';

var EPSILON = 0.001; // used when checking collisions, to prevent round-off errors

/**
 * Order items by their start data
 * @param {Item[]} items
 */
exports.orderByStart = function (items) {
  items.sort(function (a, b) {
    return a.data.start - b.data.start;
  });
};

/**
 * Order items by their end date. If they have no end date, their start date
 * is used.
 * @param {Item[]} items
 */
exports.orderByEnd = function (items) {
  items.sort(function (a, b) {
    var aTime = 'end' in a.data ? a.data.end : a.data.start,
        bTime = 'end' in b.data ? b.data.end : b.data.start;

    return aTime - bTime;
  });
};

/**
 * Adjust vertical positions of the items such that they don't overlap each
 * other.
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 * @param {boolean} [force=false]
 *            If true, all items will be repositioned. If false (default), only
 *            items having a top===null will be re-stacked
 */
exports.stack = function (items, margin, force) {
  var i, iMax;

  if (force) {
    // reset top position of all items
    for (i = 0, iMax = items.length; i < iMax; i++) {
      items[i].top = null;
    }
  }

  // calculate new, non-overlapping positions
  for (i = 0, iMax = items.length; i < iMax; i++) {
    var item = items[i];
    if (item.stack && item.top === null) {
      // initialize top position
      item.top = margin.axis;

      do {
        // TODO: optimize checking for overlap. when there is a gap without items,
        //       you only need to check for items from the next item on, not from zero
        var collidingItem = null;
        for (var j = 0, jj = items.length; j < jj; j++) {
          var other = items[j];
          if (other.top !== null && other !== item && other.stack && exports.collision(item, other, margin.item)) {
            collidingItem = other;
            break;
          }
        }

        if (collidingItem != null) {
          // There is a collision. Reposition the items above the colliding element
          item.top = collidingItem.top + collidingItem.height + margin.item.vertical;
        }
      } while (collidingItem);
    }
  }
};

/**
 * Adjust vertical positions of the items without stacking them
 * @param {Item[]} items
 *            All visible items
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 *            Margins between items and between items and the axis.
 */
exports.nostack = function (items, margin, subgroups) {
  var i, iMax, newTop;

  // reset top position of all items
  for (i = 0, iMax = items.length; i < iMax; i++) {
    if (items[i].data.subgroup !== undefined) {
      newTop = margin.axis;
      for (var subgroup in subgroups) {
        if (subgroups.hasOwnProperty(subgroup)) {
          if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroups[items[i].data.subgroup].index) {
            newTop += subgroups[subgroup].height + margin.item.vertical;
          }
        }
      }
      items[i].top = newTop;
    } else {
      items[i].top = margin.axis;
    }
  }
};

/**
 * Test if the two provided items collide
 * The items must have parameters left, width, top, and height.
 * @param {Item} a          The first item
 * @param {Item} b          The second item
 * @param {{horizontal: number, vertical: number}} margin
 *                          An object containing a horizontal and vertical
 *                          minimum required margin.
 * @return {boolean}        true if a and b collide, else false
 */
exports.collision = function (a, b, margin) {
  return a.left - margin.horizontal + EPSILON < b.left + b.width && a.left + a.width + margin.horizontal - EPSILON > b.left && a.top - margin.vertical + EPSILON < b.top + b.height && a.top + a.height + margin.vertical - EPSILON > b.top;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9TdGFjay5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7Ozs7OztBQU1wQixPQUFPLENBQUMsWUFBWSxHQUFHLFVBQVMsS0FBSyxFQUFFO0FBQ3JDLE9BQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ3pCLFdBQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7R0FDcEMsQ0FBQyxDQUFDO0NBQ0osQ0FBQzs7Ozs7OztBQU9GLE9BQU8sQ0FBQyxVQUFVLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDbkMsT0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDekIsUUFBSSxLQUFLLEdBQUcsQUFBQyxLQUFLLElBQUksQ0FBQyxDQUFDLElBQUksR0FBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUs7UUFDckQsS0FBSyxHQUFHLEFBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7O0FBRTFELFdBQU8sS0FBSyxHQUFHLEtBQUssQ0FBQztHQUN0QixDQUFDLENBQUM7Q0FDSixDQUFDOzs7Ozs7Ozs7Ozs7O0FBYUYsT0FBTyxDQUFDLEtBQUssR0FBRyxVQUFTLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO0FBQzdDLE1BQUksQ0FBQyxFQUFFLElBQUksQ0FBQzs7QUFFWixNQUFJLEtBQUssRUFBRTs7QUFFVCxTQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFH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QUFNLENBQUMsVUFBVSxHQUFHLE9BQU8sR0FBVyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxLQUFLLEFBQUMsSUFDckUsQUFBQyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLFVBQVUsR0FBRyxPQUFPLEdBQUksQ0FBQyxDQUFDLElBQUksSUFDekQsQUFBQyxDQUFDLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxRQUFRLEdBQUcsT0FBTyxHQUFrQixDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLEFBQUMsSUFDckUsQUFBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFFBQVEsR0FBRyxPQUFPLEdBQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBRTtDQUMvRCxDQUFDIiwiZmlsZSI6Ii91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9TdGFjay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBvcmRlcmluZyBhbmQgc3RhY2tpbmcgb2YgaXRlbXNcbnZhciBFUFNJTE9OID0gMC4wMDE7IC8vIHVzZWQgd2hlbiBjaGVja2luZyBjb2xsaXNpb25zLCB0byBwcmV2ZW50IHJvdW5kLW9mZiBlcnJvcnNcblxuLyoqXG4gKiBPcmRlciBpdGVtcyBieSB0aGVpciBzdGFydCBkYXRhXG4gKiBAcGFyYW0ge0l0ZW1bXX0gaXRlbXNcbiAqL1xuZXhwb3J0cy5vcmRlckJ5U3RhcnQgPSBmdW5jdGlvbihpdGVtcykge1xuICBpdGVtcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZGF0YS5zdGFydCAtIGIuZGF0YS5zdGFydDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIE9yZGVyIGl0ZW1zIGJ5IHRoZWlyIGVuZCBkYXRlLiBJZiB0aGV5IGhhdmUgbm8gZW5kIGRhdGUsIHRoZWlyIHN0YXJ0IGRhdGVcbiAqIGlzIHVzZWQuXG4gKiBAcGFyYW0ge0l0ZW1bXX0gaXRlbXNcbiAqL1xuZXhwb3J0cy5vcmRlckJ5RW5kID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgaXRlbXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhVGltZSA9ICgnZW5kJyBpbiBhLmRhdGEpID8gYS5kYXRhLmVuZCA6IGEuZGF0YS5zdGFydCxcbiAgICAgICAgYlRpbWUgPSAoJ2VuZCcgaW4gYi5kYXRhKSA/IGIuZGF0YS5lbmQgOiBiLmRhdGEuc3RhcnQ7XG5cbiAgICByZXR1cm4gYVRpbWUgLSBiVGltZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkanVzdCB2ZXJ0aWNhbCBwb3NpdGlvbnMgb2YgdGhlIGl0ZW1zIHN1Y2ggdGhhdCB0aGV5IGRvbid0IG92ZXJsYXAgZWFjaFxuICogb3RoZXIuXG4gKiBAcGFyYW0ge0l0ZW1bXX0gaXRlbXNcbiAqICAgICAgICAgICAgQWxsIHZpc2libGUgaXRlbXNcbiAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAqICAgICAgICAgICAgTWFyZ2lucyBiZXR3ZWVuIGl0ZW1zIGFuZCBiZXR3ZWVuIGl0ZW1zIGFuZCB0aGUgYXhpcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXVxuICogICAgICAgICAgICBJZiB0cnVlLCBhbGwgaXRlbXMgd2lsbCBiZSByZXBvc2l0aW9uZWQuIElmIGZhbHNlIChkZWZhdWx0KSwgb25seVxuICogICAgICAgICAgICBpdGVtcyBoYXZpbmcgYSB0b3A9PT1udWxsIHdpbGwgYmUgcmUtc3RhY2tlZFxuICovXG5leHBvcnRzLnN0YWNrID0gZnVuY3Rpb24oaXRlbXMsIG1hcmdpbiwgZm9yY2UpIHtcbiAgdmFyIGksIGlNYXg7XG5cbiAgaWYgKGZvcmNlKSB7XG4gICAgLy8gcmVzZXQgdG9wIHBvc2l0aW9uIG9mIGFsbCBpdGVtc1xuICAgIGZvciAoaSA9IDAsIGlNYXggPSBpdGVtcy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGl0ZW1zW2ldLnRvcCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIG5ldywgbm9uLW92ZXJsYXBwaW5nIHBvc2l0aW9uc1xuICBmb3IgKGkgPSAwLCBpTWF4ID0gaXRlbXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBpZiAoaXRlbS5zdGFjayAmJiBpdGVtLnRvcCA9PT0gbnVsbCkge1xuICAgICAgLy8gaW5pdGlhbGl6ZSB0b3AgcG9zaXRpb25cbiAgICAgIGl0ZW0udG9wID0gbWFyZ2luLmF4aXM7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgY2hlY2tpbmcgZm9yIG92ZXJsYXAuIHdoZW4gdGhlcmUgaXMgYSBnYXAgd2l0aG91dCBpdGVtcyxcbiAgICAgICAgLy8gICAgICAgeW91IG9ubHkgbmVlZCB0byBjaGVjayBmb3IgaXRlbXMgZnJvbSB0aGUgbmV4dCBpdGVtIG9uLCBub3QgZnJvbSB6ZXJvXG4gICAgICAgIHZhciBjb2xsaWRpbmdJdGVtID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gaXRlbXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIHZhciBvdGhlciA9IGl0ZW1zW2pdO1xuICAgICAgICAgIGlmIChvdGhlci50b3AgIT09IG51bGwgJiYgb3RoZXIgIT09IGl0ZW0gJiYgb3RoZXIuc3RhY2sgJiYgZXhwb3J0cy5jb2xsaXNpb24oaXRlbSwgb3RoZXIsIG1hcmdpbi5pdGVtKSkge1xuICAgICAgICAgICAgY29sbGlkaW5nSXRlbSA9IG90aGVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbGxpZGluZ0l0ZW0gIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIGEgY29sbGlzaW9uLiBSZXBvc2l0aW9uIHRoZSBpdGVtcyBhYm92ZSB0aGUgY29sbGlkaW5nIGVsZW1lbnRcbiAgICAgICAgICBpdGVtLnRvcCA9IGNvbGxpZGluZ0l0ZW0udG9wICsgY29sbGlkaW5nSXRlbS5oZWlnaHQgKyBtYXJnaW4uaXRlbS52ZXJ0aWNhbDtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoY29sbGlkaW5nSXRlbSk7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQWRqdXN0IHZlcnRpY2FsIHBvc2l0aW9ucyBvZiB0aGUgaXRlbXMgd2l0aG91dCBzdGFja2luZyB0aGVtXG4gKiBAcGFyYW0ge0l0ZW1bXX0gaXRlbXNcbiAqICAgICAgICAgICAgQWxsIHZpc2libGUgaXRlbXNcbiAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAqICAgICAgICAgICAgTWFyZ2lucyBiZXR3ZWVuIGl0ZW1zIGFuZCBiZXR3ZWVuIGl0ZW1zIGFuZCB0aGUgYXhpcy5cbiAqL1xuZXhwb3J0cy5ub3N0YWNrID0gZnVuY3Rpb24oaXRlbXMsIG1hcmdpbiwgc3ViZ3JvdXBzKSB7XG4gIHZhciBpLCBpTWF4LCBuZXdUb3A7XG5cbiAgLy8gcmVzZXQgdG9wIHBvc2l0aW9uIG9mIGFsbCBpdGVtc1xuICBmb3IgKGkgPSAwLCBpTWF4ID0gaXRlbXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgaWYgKGl0ZW1zW2ldLmRhdGEuc3ViZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VG9wID0gbWFyZ2luLmF4aXM7XG4gICAgICBmb3IgKHZhciBzdWJncm91cCBpbiBzdWJncm91cHMpIHtcbiAgICAgICAgaWYgKHN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgICBpZiAoc3ViZ3JvdXBzW3N1Ymdyb3VwXS52aXNpYmxlID09IHRydWUgJiYgc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pbmRleCA8IHN1Ymdyb3Vwc1tpdGVtc1tpXS5kYXRhLnN1Ymdyb3VwXS5pbmRleCkge1xuICAgICAgICAgICAgbmV3VG9wICs9IHN1Ymdyb3Vwc1tzdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpdGVtc1tpXS50b3AgPSBuZXdUb3A7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXRlbXNbaV0udG9wID0gbWFyZ2luLmF4aXM7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhlIHR3byBwcm92aWRlZCBpdGVtcyBjb2xsaWRlXG4gKiBUaGUgaXRlbXMgbXVzdCBoYXZlIHBhcmFtZXRlcnMgbGVmdCwgd2lkdGgsIHRvcCwgYW5kIGhlaWdodC5cbiAqIEBwYXJhbSB7SXRlbX0gYSAgICAgICAgICBUaGUgZmlyc3QgaXRlbVxuICogQHBhcmFtIHtJdGVtfSBiICAgICAgICAgIFRoZSBzZWNvbmQgaXRlbVxuICogQHBhcmFtIHt7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfX0gbWFyZ2luXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW0gcmVxdWlyZWQgbWFyZ2luLlxuICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgIHRydWUgaWYgYSBhbmQgYiBjb2xsaWRlLCBlbHNlIGZhbHNlXG4gKi9cbmV4cG9ydHMuY29sbGlzaW9uID0gZnVuY3Rpb24oYSwgYiwgbWFyZ2luKSB7XG4gIHJldHVybiAoKGEubGVmdCAtIG1hcmdpbi5ob3Jpem9udGFsICsgRVBTSUxPTikgICAgICAgPCAoYi5sZWZ0ICsgYi53aWR0aCkgJiZcbiAgICAgIChhLmxlZnQgKyBhLndpZHRoICsgbWFyZ2luLmhvcml6b250YWwgLSBFUFNJTE9OKSA+IGIubGVmdCAmJlxuICAgICAgKGEudG9wIC0gbWFyZ2luLnZlcnRpY2FsICsgRVBTSUxPTikgICAgICAgICAgICAgIDwgKGIudG9wICsgYi5oZWlnaHQpICYmXG4gICAgICAoYS50b3AgKyBhLmhlaWdodCArIG1hcmdpbi52ZXJ0aWNhbCAtIEVQU0lMT04pICAgPiBiLnRvcCk7XG59O1xuIl19
},{}],30:[function(require,module,exports){
'use strict';

var moment = require('../module/moment');
var DateUtil = require('./DateUtil');
var util = require('../util');

/**
 * @constructor  TimeStep
 * The class TimeStep is an iterator for dates. You provide a start date and an
 * end date. The class itself determines the best scale (step size) based on the
 * provided start Date, end Date, and minimumStep.
 *
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 *
 * Alternatively, you can set a scale by hand.
 * After creation, you can initialize the class by executing first(). Then you
 * can iterate from the start date to the end date via next(). You can check if
 * the end date is reached with the function hasNext(). After each step, you can
 * retrieve the current date via getCurrent().
 * The TimeStep has scales ranging from milliseconds, seconds, minutes, hours,
 * days, to years.
 *
 * Version: 1.2
 *
 * @param {Date} [start]         The start date, for example new Date(2010, 9, 21)
 *                               or new Date(2010, 9, 21, 23, 45, 00)
 * @param {Date} [end]           The end date
 * @param {Number} [minimumStep] Optional. Minimum step size in milliseconds
 */
function TimeStep(start, end, minimumStep, hiddenDates) {
  this.moment = moment;

  // variables
  this.current = this.moment();
  this._start = this.moment();
  this._end = this.moment();

  this.autoScale = true;
  this.scale = 'day';
  this.step = 1;

  // initialize the range
  this.setRange(start, end, minimumStep);

  // hidden Dates options
  this.switchedDay = false;
  this.switchedMonth = false;
  this.switchedYear = false;
  if (Array.isArray(hiddenDates)) {
    this.hiddenDates = hiddenDates;
  } else if (hiddenDates != undefined) {
    this.hiddenDates = [hiddenDates];
  } else {
    this.hiddenDates = [];
  }

  this.format = TimeStep.FORMAT; // default formatting
}

// Time formatting
TimeStep.FORMAT = {
  minorLabels: {
    millisecond: 'SSS',
    second: 's',
    minute: 'HH:mm',
    hour: 'HH:mm',
    weekday: 'ddd D',
    day: 'D',
    month: 'MMM',
    year: 'YYYY'
  },
  majorLabels: {
    millisecond: 'HH:mm:ss',
    second: 'D MMMM HH:mm',
    minute: 'ddd D MMMM',
    hour: 'ddd D MMMM',
    weekday: 'MMMM YYYY',
    day: 'MMMM YYYY',
    month: 'YYYY',
    year: ''
  }
};

/**
 * Set custom constructor function for moment. Can be used to set dates
 * to UTC or to set a utcOffset.
 * @param {function} moment
 */
TimeStep.prototype.setMoment = function (moment) {
  this.moment = moment;

  // update the date properties, can have a new utcOffset
  this.current = this.moment(this.current);
  this._start = this.moment(this._start);
  this._end = this.moment(this._end);
};

/**
 * Set custom formatting for the minor an major labels of the TimeStep.
 * Both `minorLabels` and `majorLabels` are an Object with properties:
 * 'millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
 * @param {{minorLabels: Object, majorLabels: Object}} format
 */
TimeStep.prototype.setFormat = function (format) {
  var defaultFormat = util.deepExtend({}, TimeStep.FORMAT);
  this.format = util.deepExtend(defaultFormat, format);
};

/**
 * Set a new range
 * If minimumStep is provided, the step size is chosen as close as possible
 * to the minimumStep but larger than minimumStep. If minimumStep is not
 * provided, the scale is set to 1 DAY.
 * The minimumStep should correspond with the onscreen size of about 6 characters
 * @param {Date} [start]      The start date and time.
 * @param {Date} [end]        The end date and time.
 * @param {int} [minimumStep] Optional. Minimum step size in milliseconds
 */
TimeStep.prototype.setRange = function (start, end, minimumStep) {
  if (!(start instanceof Date) || !(end instanceof Date)) {
    throw "No legal start or end date in method setRange";
  }

  this._start = start != undefined ? this.moment(start.valueOf()) : new Date();
  this._end = end != undefined ? this.moment(end.valueOf()) : new Date();

  if (this.autoScale) {
    this.setMinimumStep(minimumStep);
  }
};

/**
 * Set the range iterator to the start date.
 */
TimeStep.prototype.start = function () {
  this.current = this._start.clone();
  this.roundToMinor();
};

/**
 * Round the current date to the first minor date value
 * This must be executed once when the current date is set to start Date
 */
TimeStep.prototype.roundToMinor = function () {
  // round to floor
  // IMPORTANT: we have no breaks in this switch! (this is no bug)
  // noinspection FallThroughInSwitchStatementJS
  switch (this.scale) {
    case 'year':
      this.current.year(this.step * Math.floor(this.current.year() / this.step));
      this.current.month(0);
    case 'month':
      this.current.date(1);
    case 'day': // intentional fall through
    case 'weekday':
      this.current.hours(0);
    case 'hour':
      this.current.minutes(0);
    case 'minute':
      this.current.seconds(0);
    case 'second':
      this.current.milliseconds(0);
    //case 'millisecond': // nothing to do for milliseconds
  }

  if (this.step != 1) {
    // round down to the first minor value that is a multiple of the current step size
    switch (this.scale) {
      case 'millisecond':
        this.current.subtract(this.current.milliseconds() % this.step, 'milliseconds');break;
      case 'second':
        this.current.subtract(this.current.seconds() % this.step, 'seconds');break;
      case 'minute':
        this.current.subtract(this.current.minutes() % this.step, 'minutes');break;
      case 'hour':
        this.current.subtract(this.current.hours() % this.step, 'hours');break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.subtract((this.current.date() - 1) % this.step, 'day');break;
      case 'month':
        this.current.subtract(this.current.month() % this.step, 'month');break;
      case 'year':
        this.current.subtract(this.current.year() % this.step, 'year');break;
      default:
        break;
    }
  }
};

/**
 * Check if the there is a next step
 * @return {boolean}  true if the current date has not passed the end date
 */
TimeStep.prototype.hasNext = function () {
  return this.current.valueOf() <= this._end.valueOf();
};

/**
 * Do the next step
 */
TimeStep.prototype.next = function () {
  var prev = this.current.valueOf();

  // Two cases, needed to prevent issues with switching daylight savings
  // (end of March and end of October)
  if (this.current.month() < 6) {
    switch (this.scale) {
      case 'millisecond':
        this.current.add(this.step, 'millisecond');break;
      case 'second':
        this.current.add(this.step, 'second');break;
      case 'minute':
        this.current.add(this.step, 'minute');break;
      case 'hour':
        this.current.add(this.step, 'hour');
        // in case of skipping an hour for daylight savings, adjust the hour again (else you get: 0h 5h 9h ... instead of 0h 4h 8h ...)
        // TODO: is this still needed now we use the function of moment.js?
        this.current.subtract(this.current.hours() % this.step, 'hour');
        break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.add(this.step, 'day');break;
      case 'month':
        this.current.add(this.step, 'month');break;
      case 'year':
        this.current.add(this.step, 'year');break;
      default:
        break;
    }
  } else {
    switch (this.scale) {
      case 'millisecond':
        this.current.add(this.step, 'millisecond');break;
      case 'second':
        this.current.add(this.step, 'second');break;
      case 'minute':
        this.current.add(this.step, 'minute');break;
      case 'hour':
        this.current.add(this.step, 'hour');break;
      case 'weekday': // intentional fall through
      case 'day':
        this.current.add(this.step, 'day');break;
      case 'month':
        this.current.add(this.step, 'month');break;
      case 'year':
        this.current.add(this.step, 'year');break;
      default:
        break;
    }
  }

  if (this.step != 1) {
    // round down to the correct major value
    switch (this.scale) {
      case 'millisecond':
        if (this.current.milliseconds() < this.step) this.current.milliseconds(0);break;
      case 'second':
        if (this.current.seconds() < this.step) this.current.seconds(0);break;
      case 'minute':
        if (this.current.minutes() < this.step) this.current.minutes(0);break;
      case 'hour':
        if (this.current.hours() < this.step) this.current.hours(0);break;
      case 'weekday': // intentional fall through
      case 'day':
        if (this.current.date() < this.step + 1) this.current.date(1);break;
      case 'month':
        if (this.current.month() < this.step) this.current.month(0);break;
      case 'year':
        break; // nothing to do for year
      default:
        break;
    }
  }

  // safety mechanism: if current time is still unchanged, move to the end
  if (this.current.valueOf() == prev) {
    this.current = this._end.clone();
  }

  DateUtil.stepOverHiddenDates(this.moment, this, prev);
};

/**
 * Get the current datetime
 * @return {Moment}  current The current date
 */
TimeStep.prototype.getCurrent = function () {
  return this.current;
};

/**
 * Set a custom scale. Autoscaling will be disabled.
 * For example setScale('minute', 5) will result
 * in minor steps of 5 minutes, and major steps of an hour.
 *
 * @param {{scale: string, step: number}} params
 *                               An object containing two properties:
 *                               - A string 'scale'. Choose from 'millisecond', 'second',
 *                                 'minute', 'hour', 'weekday', 'day', 'month', 'year'.
 *                               - A number 'step'. A step size, by default 1.
 *                                 Choose for example 1, 2, 5, or 10.
 */
TimeStep.prototype.setScale = function (params) {
  if (params && typeof params.scale == 'string') {
    this.scale = params.scale;
    this.step = params.step > 0 ? params.step : 1;
    this.autoScale = false;
  }
};

/**
 * Enable or disable autoscaling
 * @param {boolean} enable  If true, autoascaling is set true
 */
TimeStep.prototype.setAutoScale = function (enable) {
  this.autoScale = enable;
};

/**
 * Automatically determine the scale that bests fits the provided minimum step
 * @param {Number} [minimumStep]  The minimum step size in milliseconds
 */
TimeStep.prototype.setMinimumStep = function (minimumStep) {
  if (minimumStep == undefined) {
    return;
  }

  //var b = asc + ds;

  var stepYear = 1000 * 60 * 60 * 24 * 30 * 12;
  var stepMonth = 1000 * 60 * 60 * 24 * 30;
  var stepDay = 1000 * 60 * 60 * 24;
  var stepHour = 1000 * 60 * 60;
  var stepMinute = 1000 * 60;
  var stepSecond = 1000;
  var stepMillisecond = 1;

  // find the smallest step that is larger than the provided minimumStep
  if (stepYear * 1000 > minimumStep) {
    this.scale = 'year';this.step = 1000;
  }
  if (stepYear * 500 > minimumStep) {
    this.scale = 'year';this.step = 500;
  }
  if (stepYear * 100 > minimumStep) {
    this.scale = 'year';this.step = 100;
  }
  if (stepYear * 50 > minimumStep) {
    this.scale = 'year';this.step = 50;
  }
  if (stepYear * 10 > minimumStep) {
    this.scale = 'year';this.step = 10;
  }
  if (stepYear * 5 > minimumStep) {
    this.scale = 'year';this.step = 5;
  }
  if (stepYear > minimumStep) {
    this.scale = 'year';this.step = 1;
  }
  if (stepMonth * 3 > minimumStep) {
    this.scale = 'month';this.step = 3;
  }
  if (stepMonth > minimumStep) {
    this.scale = 'month';this.step = 1;
  }
  if (stepDay * 5 > minimumStep) {
    this.scale = 'day';this.step = 5;
  }
  if (stepDay * 2 > minimumStep) {
    this.scale = 'day';this.step = 2;
  }
  if (stepDay > minimumStep) {
    this.scale = 'day';this.step = 1;
  }
  if (stepDay / 2 > minimumStep) {
    this.scale = 'weekday';this.step = 1;
  }
  if (stepHour * 4 > minimumStep) {
    this.scale = 'hour';this.step = 4;
  }
  if (stepHour > minimumStep) {
    this.scale = 'hour';this.step = 1;
  }
  if (stepMinute * 15 > minimumStep) {
    this.scale = 'minute';this.step = 15;
  }
  if (stepMinute * 10 > minimumStep) {
    this.scale = 'minute';this.step = 10;
  }
  if (stepMinute * 5 > minimumStep) {
    this.scale = 'minute';this.step = 5;
  }
  if (stepMinute > minimumStep) {
    this.scale = 'minute';this.step = 1;
  }
  if (stepSecond * 15 > minimumStep) {
    this.scale = 'second';this.step = 15;
  }
  if (stepSecond * 10 > minimumStep) {
    this.scale = 'second';this.step = 10;
  }
  if (stepSecond * 5 > minimumStep) {
    this.scale = 'second';this.step = 5;
  }
  if (stepSecond > minimumStep) {
    this.scale = 'second';this.step = 1;
  }
  if (stepMillisecond * 200 > minimumStep) {
    this.scale = 'millisecond';this.step = 200;
  }
  if (stepMillisecond * 100 > minimumStep) {
    this.scale = 'millisecond';this.step = 100;
  }
  if (stepMillisecond * 50 > minimumStep) {
    this.scale = 'millisecond';this.step = 50;
  }
  if (stepMillisecond * 10 > minimumStep) {
    this.scale = 'millisecond';this.step = 10;
  }
  if (stepMillisecond * 5 > minimumStep) {
    this.scale = 'millisecond';this.step = 5;
  }
  if (stepMillisecond > minimumStep) {
    this.scale = 'millisecond';this.step = 1;
  }
};

/**
 * Snap a date to a rounded value.
 * The snap intervals are dependent on the current scale and step.
 * Static function
 * @param {Date} date    the date to be snapped.
 * @param {string} scale Current scale, can be 'millisecond', 'second',
 *                       'minute', 'hour', 'weekday, 'day', 'month', 'year'.
 * @param {number} step  Current step (1, 2, 4, 5, ...
 * @return {Date} snappedDate
 */
TimeStep.snap = function (date, scale, step) {
  var clone = moment(date);

  if (scale == 'year') {
    var year = clone.year() + Math.round(clone.month() / 12);
    clone.year(Math.round(year / step) * step);
    clone.month(0);
    clone.date(0);
    clone.hours(0);
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'month') {
    if (clone.date() > 15) {
      clone.date(1);
      clone.add(1, 'month');
      // important: first set Date to 1, after that change the month.
    } else {
        clone.date(1);
      }

    clone.hours(0);
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'day') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 5:
      case 2:
        clone.hours(Math.round(clone.hours() / 24) * 24);break;
      default:
        clone.hours(Math.round(clone.hours() / 12) * 12);break;
    }
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'weekday') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 5:
      case 2:
        clone.hours(Math.round(clone.hours() / 12) * 12);break;
      default:
        clone.hours(Math.round(clone.hours() / 6) * 6);break;
    }
    clone.minutes(0);
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'hour') {
    switch (step) {
      case 4:
        clone.minutes(Math.round(clone.minutes() / 60) * 60);break;
      default:
        clone.minutes(Math.round(clone.minutes() / 30) * 30);break;
    }
    clone.seconds(0);
    clone.milliseconds(0);
  } else if (scale == 'minute') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 15:
      case 10:
        clone.minutes(Math.round(clone.minutes() / 5) * 5);
        clone.seconds(0);
        break;
      case 5:
        clone.seconds(Math.round(clone.seconds() / 60) * 60);break;
      default:
        clone.seconds(Math.round(clone.seconds() / 30) * 30);break;
    }
    clone.milliseconds(0);
  } else if (scale == 'second') {
    //noinspection FallthroughInSwitchStatementJS
    switch (step) {
      case 15:
      case 10:
        clone.seconds(Math.round(clone.seconds() / 5) * 5);
        clone.milliseconds(0);
        break;
      case 5:
        clone.milliseconds(Math.round(clone.milliseconds() / 1000) * 1000);break;
      default:
        clone.milliseconds(Math.round(clone.milliseconds() / 500) * 500);break;
    }
  } else if (scale == 'millisecond') {
    var _step = step > 5 ? step / 2 : 1;
    clone.milliseconds(Math.round(clone.milliseconds() / _step) * _step);
  }

  return clone;
};

/**
 * Check if the current value is a major value (for example when the step
 * is DAY, a major value is each first day of the MONTH)
 * @return {boolean} true if current date is major, else false.
 */
TimeStep.prototype.isMajor = function () {
  if (this.switchedYear == true) {
    this.switchedYear = false;
    switch (this.scale) {
      case 'year':
      case 'month':
      case 'weekday':
      case 'day':
      case 'hour':
      case 'minute':
      case 'second':
      case 'millisecond':
        return true;
      default:
        return false;
    }
  } else if (this.switchedMonth == true) {
    this.switchedMonth = false;
    switch (this.scale) {
      case 'weekday':
      case 'day':
      case 'hour':
      case 'minute':
      case 'second':
      case 'millisecond':
        return true;
      default:
        return false;
    }
  } else if (this.switchedDay == true) {
    this.switchedDay = false;
    switch (this.scale) {
      case 'millisecond':
      case 'second':
      case 'minute':
      case 'hour':
        return true;
      default:
        return false;
    }
  }

  var date = this.moment(this.current);
  switch (this.scale) {
    case 'millisecond':
      return date.milliseconds() == 0;
    case 'second':
      return date.seconds() == 0;
    case 'minute':
      return date.hours() == 0 && date.minutes() == 0;
    case 'hour':
      return date.hours() == 0;
    case 'weekday': // intentional fall through
    case 'day':
      return date.date() == 1;
    case 'month':
      return date.month() == 0;
    case 'year':
      return false;
    default:
      return false;
  }
};

/**
 * Returns formatted text for the minor axislabel, depending on the current
 * date and the scale. For example when scale is MINUTE, the current time is
 * formatted as "hh:mm".
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
TimeStep.prototype.getLabelMinor = function (date) {
  if (date == undefined) {
    date = this.current;
  }

  var format = this.format.minorLabels[this.scale];
  return format && format.length > 0 ? this.moment(date).format(format) : '';
};

/**
 * Returns formatted text for the major axis label, depending on the current
 * date and the scale. For example when scale is MINUTE, the major scale is
 * hours, and the hour will be formatted as "hh".
 * @param {Date} [date] custom date. if not provided, current date is taken
 */
TimeStep.prototype.getLabelMajor = function (date) {
  if (date == undefined) {
    date = this.current;
  }

  var format = this.format.majorLabels[this.scale];
  return format && format.length > 0 ? this.moment(date).format(format) : '';
};

TimeStep.prototype.getClassName = function () {
  var _moment = this.moment;
  var m = this.moment(this.current);
  var current = m.locale ? m.locale('en') : m.lang('en'); // old versions of moment have .lang() function
  var step = this.step;

  function even(value) {
    return value / step % 2 == 0 ? ' vis-even' : ' vis-odd';
  }

  function today(date) {
    if (date.isSame(new Date(), 'day')) {
      return ' vis-today';
    }
    if (date.isSame(_moment().add(1, 'day'), 'day')) {
      return ' vis-tomorrow';
    }
    if (date.isSame(_moment().add(-1, 'day'), 'day')) {
      return ' vis-yesterday';
    }
    return '';
  }

  function currentWeek(date) {
    return date.isSame(new Date(), 'week') ? ' vis-current-week' : '';
  }

  function currentMonth(date) {
    return date.isSame(new Date(), 'month') ? ' vis-current-month' : '';
  }

  function currentYear(date) {
    return date.isSame(new Date(), 'year') ? ' vis-current-year' : '';
  }

  switch (this.scale) {
    case 'millisecond':
      return even(current.milliseconds()).trim();

    case 'second':
      return even(current.seconds()).trim();

    case 'minute':
      return even(current.minutes()).trim();

    case 'hour':
      var hours = current.hours();
      if (this.step == 4) {
        hours = hours + '-h' + (hours + 4);
      }
      return 'vis-h' + hours + today(current) + even(current.hours());

    case 'weekday':
      return 'vis-' + current.format('dddd').toLowerCase() + today(current) + currentWeek(current) + even(current.date());

    case 'day':
      var day = current.date();
      var month = current.format('MMMM').toLowerCase();
      return 'vis-day' + day + ' vis-' + month + currentMonth(current) + even(day - 1);

    case 'month':
      return 'vis-' + current.format('MMMM').toLowerCase() + currentMonth(current) + even(current.month());

    case 'year':
      var year = current.year();
      return 'vis-year' + year + currentYear(current) + even(year);

    default:
      return '';
  }
};

module.exports = TimeStep;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9UaW1lU3RlcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3pDLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNyQyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QjlCLFNBQVMsUUFBUSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRTtBQUN0RCxNQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQzs7O0FBR3JCLE1BQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQzdCLE1BQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQzVCLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDOztBQUUxQixNQUFJLENBQUMsU0FBUyxHQUFJLElBQUksQ0FBQztBQUN2QixNQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNuQixNQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQzs7O0FBR2QsTUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLFdBQVcsQ0FBQyxDQUFDOzs7QUFHdkMsTUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7QUFDekIsTUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7QUFDM0IsTUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7QUFDMUIsTUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFO0FBQzlCLFFBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0dBQ2hDLE1BQ0ks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QUM7QUFDcEYsTUFBSSxPQUFPLEdBQUcsV0FBVyxFQUFlO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsQUFBUyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksT0FBTyxHQUFDLENBQUMsR0FBRyxXQUFXLEVBQWE7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQyxBQUFLLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxRQUFRLEdBQUMsQ0FBQyxHQUFHLFdBQVcsRUFBWTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEFBQVEsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLFFBQVEsR0FBRyxXQUFXLEVBQWM7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxBQUFRLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxVQUFVLEdBQUMsRUFBRSxHQUFHLFdBQVcsRUFBUztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEFBQU0sSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7R0FBQztBQUNyRixNQUFJLFVBQVUsR0FBQyxFQUFFLEdBQUcsV0FBVyxFQUFTO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsQUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztHQUFDO0FBQ3JGLE1BQUksVUFBVSxHQUFDLENBQUMsR0FBRyxXQUFXLEVBQVU7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxBQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0dBQUM7QUFDcEYsTUFBSSxVQUFVLEdBQUcsV0FBVyxFQUFZO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsQUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksVUFBVSxHQUFDLEVBQUUsR0FBRyxXQUFXLEVBQVM7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxBQUFNLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0dBQUM7QUFDckYsTUFBSSxVQUFVLEdBQUMsRUFBRSxHQUFHLFdBQVcsRUFBUztBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEFBQU0sSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7R0FBQztBQUNyRixNQUFJLFVBQVUsR0FBQyxDQUFDLEdBQUcsV0FBVyxFQUFVO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsQUFBTSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztHQUFDO0FBQ3BGLE1BQUksVUFBVSxHQUFHLFdBQVcsRUFBWTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEFBQU0sSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7R0FBQztBQUNwRixNQUFJLGVBQWUsR0FBQyxHQUFHLEdBQUcsV0FBVyxFQUFHO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxhQUFhLENBQUMsQUFBQyxJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztHQUFDO0FBQ3RGLE1BQUksZUFBZSxHQUFDLEdBQUcsR0FBRyxXQUFXLEVBQUc7QUFBQyxRQUFJLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQyxBQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO0dBQUM7QUFDdEYsTUFBSSxlQUFlLEdBQUMsRUFBRSxHQUFHLFdBQVcsRUFBSTtBQUFDLFFBQUksQ0FBQyxLQUFLLEdBQUcsYUFBYSxDQUFDLEFBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7R0FBQztBQUNyRixNQUFJLGVBQWUsR0FBQyxFQUFFLEdBQUcsV0FBVyxFQUFJO0FBQUMsUUFBSSxDQUFDLEtBQUssR0FBRyxhQUFhLENBQUMsQUFBQyxJQUFJLENBQUMsSUFBSSxH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RSxDQUFDO0FBQ2pELGFBQU8sU0FBUyxHQUFHLEdBQUcsR0FBRyxPQUFPLEdBQUcsS0FBSyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDOztBQUFBLEFBRW5GLFNBQUssT0FBTztBQUNWLGFBQU8sTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQ2hELFlBQVksQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7O0FBQUEsQUFFcEQsU0FBSyxNQUFNO0FBQ1QsVUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO0FBQzFCLGFBQU8sVUFBVSxHQUFHLElBQUksR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUFBLEFBRTlEO0FBQ0UsYUFBTyxFQUFFLENBQUM7QUFBQSxHQUNiO0NBQ0YsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyIsImZpbGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvVGltZVN0ZXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbW9tZW50ID0gcmVxdWlyZSgnLi4vbW9kdWxlL21vbWVudCcpO1xudmFyIERhdGVVdGlsID0gcmVxdWlyZSgnLi9EYXRlVXRpbCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yICBUaW1lU3RlcFxuICogVGhlIGNsYXNzIFRpbWVTdGVwIGlzIGFuIGl0ZXJhdG9yIGZvciBkYXRlcy4gWW91IHByb3ZpZGUgYSBzdGFydCBkYXRlIGFuZCBhblxuICogZW5kIGRhdGUuIFRoZSBjbGFzcyBpdHNlbGYgZGV0ZXJtaW5lcyB0aGUgYmVzdCBzY2FsZSAoc3RlcCBzaXplKSBiYXNlZCBvbiB0aGVcbiAqIHByb3ZpZGVkIHN0YXJ0IERhdGUsIGVuZCBEYXRlLCBhbmQgbWluaW11bVN0ZXAuXG4gKlxuICogSWYgbWluaW11bVN0ZXAgaXMgcHJvdmlkZWQsIHRoZSBzdGVwIHNpemUgaXMgY2hvc2VuIGFzIGNsb3NlIGFzIHBvc3NpYmxlXG4gKiB0byB0aGUgbWluaW11bVN0ZXAgYnV0IGxhcmdlciB0aGFuIG1pbmltdW1TdGVwLiBJZiBtaW5pbXVtU3RlcCBpcyBub3RcbiAqIHByb3ZpZGVkLCB0aGUgc2NhbGUgaXMgc2V0IHRvIDEgREFZLlxuICogVGhlIG1pbmltdW1TdGVwIHNob3VsZCBjb3JyZXNwb25kIHdpdGggdGhlIG9uc2NyZWVuIHNpemUgb2YgYWJvdXQgNiBjaGFyYWN0ZXJzXG4gKlxuICogQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBzZXQgYSBzY2FsZSBieSBoYW5kLlxuICogQWZ0ZXIgY3JlYXRpb24sIHlvdSBjYW4gaW5pdGlhbGl6ZSB0aGUgY2xhc3MgYnkgZXhlY3V0aW5nIGZpcnN0KCkuIFRoZW4geW91XG4gKiBjYW4gaXRlcmF0ZSBmcm9tIHRoZSBzdGFydCBkYXRlIHRvIHRoZSBlbmQgZGF0ZSB2aWEgbmV4dCgpLiBZb3UgY2FuIGNoZWNrIGlmXG4gKiB0aGUgZW5kIGRhdGUgaXMgcmVhY2hlZCB3aXRoIHRoZSBmdW5jdGlvbiBoYXNOZXh0KCkuIEFmdGVyIGVhY2ggc3RlcCwgeW91IGNhblxuICogcmV0cmlldmUgdGhlIGN1cnJlbnQgZGF0ZSB2aWEgZ2V0Q3VycmVudCgpLlxuICogVGhlIFRpbWVTdGVwIGhhcyBzY2FsZXMgcmFuZ2luZyBmcm9tIG1pbGxpc2Vjb25kcywgc2Vjb25kcywgbWludXRlcywgaG91cnMsXG4gKiBkYXlzLCB0byB5ZWFycy5cbiAqXG4gKiBWZXJzaW9uOiAxLjJcbiAqXG4gKiBAcGFyYW0ge0RhdGV9IFtzdGFydF0gICAgICAgICBUaGUgc3RhcnQgZGF0ZSwgZm9yIGV4YW1wbGUgbmV3IERhdGUoMjAxMCwgOSwgMjEpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBuZXcgRGF0ZSgyMDEwLCA5LCAyMSwgMjMsIDQ1LCAwMClcbiAqIEBwYXJhbSB7RGF0ZX0gW2VuZF0gICAgICAgICAgIFRoZSBlbmQgZGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFttaW5pbXVtU3RlcF0gT3B0aW9uYWwuIE1pbmltdW0gc3RlcCBzaXplIGluIG1pbGxpc2Vjb25kc1xuICovXG5mdW5jdGlvbiBUaW1lU3RlcChzdGFydCwgZW5kLCBtaW5pbXVtU3RlcCwgaGlkZGVuRGF0ZXMpIHtcbiAgdGhpcy5tb21lbnQgPSBtb21lbnQ7XG5cbiAgLy8gdmFyaWFibGVzXG4gIHRoaXMuY3VycmVudCA9IHRoaXMubW9tZW50KCk7XG4gIHRoaXMuX3N0YXJ0ID0gdGhpcy5tb21lbnQoKTtcbiAgdGhpcy5fZW5kID0gdGhpcy5tb21lbnQoKTtcblxuICB0aGlzLmF1dG9TY2FsZSAgPSB0cnVlO1xuICB0aGlzLnNjYWxlID0gJ2RheSc7XG4gIHRoaXMuc3RlcCA9IDE7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgcmFuZ2VcbiAgdGhpcy5zZXRSYW5nZShzdGFydCwgZW5kLCBtaW5pbXVtU3RlcCk7XG5cbiAgLy8gaGlkZGVuIERhdGVzIG9wdGlvbnNcbiAgdGhpcy5zd2l0Y2hlZERheSA9IGZhbHNlO1xuICB0aGlzLnN3aXRjaGVkTW9udGggPSBmYWxzZTtcbiAgdGhpcy5zd2l0Y2hlZFllYXIgPSBmYWxzZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaGlkZGVuRGF0ZXMpKSB7XG4gICAgdGhpcy5oaWRkZW5EYXRlcyA9IGhpZGRlbkRhdGVzO1xuICB9XG4gIGVsc2UgaWYgKGhpZGRlbkRhdGVzICE9IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuaGlkZGVuRGF0ZXMgPSBbaGlkZGVuRGF0ZXNdO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuaGlkZGVuRGF0ZXMgPSBbXTtcbiAgfVxuXG4gIHRoaXMuZm9ybWF0ID0gVGltZVN0ZXAuRk9STUFUOyAvLyBkZWZhdWx0IGZvcm1hdHRpbmdcbn1cblxuLy8gVGltZSBmb3JtYXR0aW5nXG5UaW1lU3RlcC5GT1JNQVQgPSB7XG4gIG1pbm9yTGFiZWxzOiB7XG4gICAgbWlsbGlzZWNvbmQ6J1NTUycsXG4gICAgc2Vjb25kOiAgICAgJ3MnLFxuICAgIG1pbnV0ZTogICAgICdISDptbScsXG4gICAgaG91cjogICAgICAgJ0hIOm1tJyxcbiAgICB3ZWVrZGF5OiAgICAnZGRkIEQnLFxuICAgIGRheTogICAgICAgICdEJyxcbiAgICBtb250aDogICAgICAnTU1NJyxcbiAgICB5ZWFyOiAgICAgICAnWVlZWSdcbiAgfSxcbiAgbWFqb3JMYWJlbHM6IHtcbiAgICBtaWxsaXNlY29uZDonSEg6bW06c3MnLFxuICAgIHNlY29uZDogICAgICdEIE1NTU0gSEg6bW0nLFxuICAgIG1pbnV0ZTogICAgICdkZGQgRCBNTU1NJyxcbiAgICBob3VyOiAgICAgICAnZGRkIEQgTU1NTScsXG4gICAgd2Vla2RheTogICAgJ01NTU0gWVlZWScsXG4gICAgZGF5OiAgICAgICAgJ01NTU0gWVlZWScsXG4gICAgbW9udGg6ICAgICAgJ1lZWVknLFxuICAgIHllYXI6ICAgICAgICcnXG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGN1c3RvbSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgbW9tZW50LiBDYW4gYmUgdXNlZCB0byBzZXQgZGF0ZXNcbiAqIHRvIFVUQyBvciB0byBzZXQgYSB1dGNPZmZzZXQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb21lbnRcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLnNldE1vbWVudCA9IGZ1bmN0aW9uIChtb21lbnQpIHtcbiAgdGhpcy5tb21lbnQgPSBtb21lbnQ7XG5cbiAgLy8gdXBkYXRlIHRoZSBkYXRlIHByb3BlcnRpZXMsIGNhbiBoYXZlIGEgbmV3IHV0Y09mZnNldFxuICB0aGlzLmN1cnJlbnQgPSB0aGlzLm1vbWVudCh0aGlzLmN1cnJlbnQpO1xuICB0aGlzLl9zdGFydCA9IHRoaXMubW9tZW50KHRoaXMuX3N0YXJ0KTtcbiAgdGhpcy5fZW5kID0gdGhpcy5tb21lbnQodGhpcy5fZW5kKTtcbn07XG5cbi8qKlxuICogU2V0IGN1c3RvbSBmb3JtYXR0aW5nIGZvciB0aGUgbWlub3IgYW4gbWFqb3IgbGFiZWxzIG9mIHRoZSBUaW1lU3RlcC5cbiAqIEJvdGggYG1pbm9yTGFiZWxzYCBhbmQgYG1ham9yTGFiZWxzYCBhcmUgYW4gT2JqZWN0IHdpdGggcHJvcGVydGllczpcbiAqICdtaWxsaXNlY29uZCcsICdzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnd2Vla2RheScsICdkYXknLCAnbW9udGgnLCAneWVhcicuXG4gKiBAcGFyYW0ge3ttaW5vckxhYmVsczogT2JqZWN0LCBtYWpvckxhYmVsczogT2JqZWN0fX0gZm9ybWF0XG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zZXRGb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gIHZhciBkZWZhdWx0Rm9ybWF0ID0gdXRpbC5kZWVwRXh0ZW5kKHt9LCBUaW1lU3RlcC5GT1JNQVQpO1xuICB0aGlzLmZvcm1hdCA9IHV0aWwuZGVlcEV4dGVuZChkZWZhdWx0Rm9ybWF0LCBmb3JtYXQpO1xufTtcblxuLyoqXG4gKiBTZXQgYSBuZXcgcmFuZ2VcbiAqIElmIG1pbmltdW1TdGVwIGlzIHByb3ZpZGVkLCB0aGUgc3RlcCBzaXplIGlzIGNob3NlbiBhcyBjbG9zZSBhcyBwb3NzaWJsZVxuICogdG8gdGhlIG1pbmltdW1TdGVwIGJ1dCBsYXJnZXIgdGhhbiBtaW5pbXVtU3RlcC4gSWYgbWluaW11bVN0ZXAgaXMgbm90XG4gKiBwcm92aWRlZCwgdGhlIHNjYWxlIGlzIHNldCB0byAxIERBWS5cbiAqIFRoZSBtaW5pbXVtU3RlcCBzaG91bGQgY29ycmVzcG9uZCB3aXRoIHRoZSBvbnNjcmVlbiBzaXplIG9mIGFib3V0IDYgY2hhcmFjdGVyc1xuICogQHBhcmFtIHtEYXRlfSBbc3RhcnRdICAgICAgVGhlIHN0YXJ0IGRhdGUgYW5kIHRpbWUuXG4gKiBAcGFyYW0ge0RhdGV9IFtlbmRdICAgICAgICBUaGUgZW5kIGRhdGUgYW5kIHRpbWUuXG4gKiBAcGFyYW0ge2ludH0gW21pbmltdW1TdGVwXSBPcHRpb25hbC4gTWluaW11bSBzdGVwIHNpemUgaW4gbWlsbGlzZWNvbmRzXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zZXRSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG1pbmltdW1TdGVwKSB7XG4gIGlmICghKHN0YXJ0IGluc3RhbmNlb2YgRGF0ZSkgfHwgIShlbmQgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHRocm93ICBcIk5vIGxlZ2FsIHN0YXJ0IG9yIGVuZCBkYXRlIGluIG1ldGhvZCBzZXRSYW5nZVwiO1xuICB9XG5cbiAgdGhpcy5fc3RhcnQgPSAoc3RhcnQgIT0gdW5kZWZpbmVkKSA/IHRoaXMubW9tZW50KHN0YXJ0LnZhbHVlT2YoKSkgOiBuZXcgRGF0ZSgpO1xuICB0aGlzLl9lbmQgPSAoZW5kICE9IHVuZGVmaW5lZCkgPyB0aGlzLm1vbWVudChlbmQudmFsdWVPZigpKSA6IG5ldyBEYXRlKCk7XG5cbiAgaWYgKHRoaXMuYXV0b1NjYWxlKSB7XG4gICAgdGhpcy5zZXRNaW5pbXVtU3RlcChtaW5pbXVtU3RlcCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHRoZSByYW5nZSBpdGVyYXRvciB0byB0aGUgc3RhcnQgZGF0ZS5cbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3VycmVudCA9IHRoaXMuX3N0YXJ0LmNsb25lKCk7XG4gIHRoaXMucm91bmRUb01pbm9yKCk7XG59O1xuXG4vKipcbiAqIFJvdW5kIHRoZSBjdXJyZW50IGRhdGUgdG8gdGhlIGZpcnN0IG1pbm9yIGRhdGUgdmFsdWVcbiAqIFRoaXMgbXVzdCBiZSBleGVjdXRlZCBvbmNlIHdoZW4gdGhlIGN1cnJlbnQgZGF0ZSBpcyBzZXQgdG8gc3RhcnQgRGF0ZVxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUucm91bmRUb01pbm9yID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJvdW5kIHRvIGZsb29yXG4gIC8vIElNUE9SVEFOVDogd2UgaGF2ZSBubyBicmVha3MgaW4gdGhpcyBzd2l0Y2ghICh0aGlzIGlzIG5vIGJ1ZylcbiAgLy8gbm9pbnNwZWN0aW9uIEZhbGxUaHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIHRoaXMuY3VycmVudC55ZWFyKHRoaXMuc3RlcCAqIE1hdGguZmxvb3IodGhpcy5jdXJyZW50LnllYXIoKSAvIHRoaXMuc3RlcCkpO1xuICAgICAgdGhpcy5jdXJyZW50Lm1vbnRoKDApO1xuICAgIGNhc2UgJ21vbnRoJzogICAgICAgIHRoaXMuY3VycmVudC5kYXRlKDEpO1xuICAgIGNhc2UgJ2RheSc6ICAgICAgICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgIGNhc2UgJ3dlZWtkYXknOiAgICAgIHRoaXMuY3VycmVudC5ob3VycygwKTtcbiAgICBjYXNlICdob3VyJzogICAgICAgICB0aGlzLmN1cnJlbnQubWludXRlcygwKTtcbiAgICBjYXNlICdtaW51dGUnOiAgICAgICB0aGlzLmN1cnJlbnQuc2Vjb25kcygwKTtcbiAgICBjYXNlICdzZWNvbmQnOiAgICAgICB0aGlzLmN1cnJlbnQubWlsbGlzZWNvbmRzKDApO1xuICAgIC8vY2FzZSAnbWlsbGlzZWNvbmQnOiAvLyBub3RoaW5nIHRvIGRvIGZvciBtaWxsaXNlY29uZHNcbiAgfVxuXG4gIGlmICh0aGlzLnN0ZXAgIT0gMSkge1xuICAgIC8vIHJvdW5kIGRvd24gdG8gdGhlIGZpcnN0IG1pbm9yIHZhbHVlIHRoYXQgaXMgYSBtdWx0aXBsZSBvZiB0aGUgY3VycmVudCBzdGVwIHNpemVcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogIHRoaXMuY3VycmVudC5zdWJ0cmFjdCh0aGlzLmN1cnJlbnQubWlsbGlzZWNvbmRzKCkgJSB0aGlzLnN0ZXAsICdtaWxsaXNlY29uZHMnKTsgIGJyZWFrO1xuICAgICAgY2FzZSAnc2Vjb25kJzogICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5zZWNvbmRzKCkgJSB0aGlzLnN0ZXAsICdzZWNvbmRzJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnbWludXRlJzogICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5taW51dGVzKCkgJSB0aGlzLnN0ZXAsICdtaW51dGVzJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnaG91cic6ICAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5ob3VycygpICUgdGhpcy5zdGVwLCAnaG91cnMnKTsgYnJlYWs7XG4gICAgICBjYXNlICd3ZWVrZGF5JzogICAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgJ2RheSc6ICAgICAgICAgIHRoaXMuY3VycmVudC5zdWJ0cmFjdCgodGhpcy5jdXJyZW50LmRhdGUoKSAtIDEpICUgdGhpcy5zdGVwLCAnZGF5Jyk7IGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGgnOiAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5tb250aCgpICUgdGhpcy5zdGVwLCAnbW9udGgnKTsgIGJyZWFrO1xuICAgICAgY2FzZSAneWVhcic6ICAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC55ZWFyKCkgJSB0aGlzLnN0ZXAsICd5ZWFyJyk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB0aGVyZSBpcyBhIG5leHQgc3RlcFxuICogQHJldHVybiB7Ym9vbGVhbn0gIHRydWUgaWYgdGhlIGN1cnJlbnQgZGF0ZSBoYXMgbm90IHBhc3NlZCB0aGUgZW5kIGRhdGVcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5jdXJyZW50LnZhbHVlT2YoKSA8PSB0aGlzLl9lbmQudmFsdWVPZigpKTtcbn07XG5cbi8qKlxuICogRG8gdGhlIG5leHQgc3RlcFxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHJldiA9IHRoaXMuY3VycmVudC52YWx1ZU9mKCk7XG5cbiAgLy8gVHdvIGNhc2VzLCBuZWVkZWQgdG8gcHJldmVudCBpc3N1ZXMgd2l0aCBzd2l0Y2hpbmcgZGF5bGlnaHQgc2F2aW5nc1xuICAvLyAoZW5kIG9mIE1hcmNoIGFuZCBlbmQgb2YgT2N0b2JlcilcbiAgaWYgKHRoaXMuY3VycmVudC5tb250aCgpIDwgNikgICB7XG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICdtaWxsaXNlY29uZCc6ICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21pbGxpc2Vjb25kJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnc2Vjb25kJzogICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdzZWNvbmQnKTsgYnJlYWs7XG4gICAgICBjYXNlICdtaW51dGUnOiAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21pbnV0ZScpOyBicmVhaztcbiAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ2hvdXInKTtcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBza2lwcGluZyBhbiBob3VyIGZvciBkYXlsaWdodCBzYXZpbmdzLCBhZGp1c3QgdGhlIGhvdXIgYWdhaW4gKGVsc2UgeW91IGdldDogMGggNWggOWggLi4uIGluc3RlYWQgb2YgMGggNGggOGggLi4uKVxuICAgICAgICAgIC8vIFRPRE86IGlzIHRoaXMgc3RpbGwgbmVlZGVkIG5vdyB3ZSB1c2UgdGhlIGZ1bmN0aW9uIG9mIG1vbWVudC5qcz9cbiAgICAgICAgdGhpcy5jdXJyZW50LnN1YnRyYWN0KHRoaXMuY3VycmVudC5ob3VycygpICUgdGhpcy5zdGVwLCAnaG91cicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dlZWtkYXknOiAgICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxuICAgICAgY2FzZSAnZGF5JzogICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdkYXknKTsgYnJlYWs7XG4gICAgICBjYXNlICdtb250aCc6ICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ21vbnRoJyk7IGJyZWFrO1xuICAgICAgY2FzZSAneWVhcic6ICAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICd5ZWFyJyk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaWxsaXNlY29uZCcpOyBicmVhaztcbiAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnc2Vjb25kJyk7IGJyZWFrO1xuICAgICAgY2FzZSAnbWludXRlJzogICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtaW51dGUnKTsgYnJlYWs7XG4gICAgICBjYXNlICdob3VyJzogICAgICAgICB0aGlzLmN1cnJlbnQuYWRkKHRoaXMuc3RlcCwgJ2hvdXInKTsgYnJlYWs7XG4gICAgICBjYXNlICd3ZWVrZGF5JzogICAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgJ2RheSc6ICAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAnZGF5Jyk7IGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGgnOiAgICAgICAgdGhpcy5jdXJyZW50LmFkZCh0aGlzLnN0ZXAsICdtb250aCcpOyBicmVhaztcbiAgICAgIGNhc2UgJ3llYXInOiAgICAgICAgIHRoaXMuY3VycmVudC5hZGQodGhpcy5zdGVwLCAneWVhcicpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnN0ZXAgIT0gMSkge1xuICAgIC8vIHJvdW5kIGRvd24gdG8gdGhlIGNvcnJlY3QgbWFqb3IgdmFsdWVcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogIGlmKHRoaXMuY3VycmVudC5taWxsaXNlY29uZHMoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50Lm1pbGxpc2Vjb25kcygwKTsgIGJyZWFrO1xuICAgICAgY2FzZSAnc2Vjb25kJzogICAgICAgaWYodGhpcy5jdXJyZW50LnNlY29uZHMoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50LnNlY29uZHMoMCk7ICBicmVhaztcbiAgICAgIGNhc2UgJ21pbnV0ZSc6ICAgICAgIGlmKHRoaXMuY3VycmVudC5taW51dGVzKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5taW51dGVzKDApOyAgYnJlYWs7XG4gICAgICBjYXNlICdob3VyJzogICAgICAgICBpZih0aGlzLmN1cnJlbnQuaG91cnMoKSA8IHRoaXMuc3RlcCkgdGhpcy5jdXJyZW50LmhvdXJzKDApOyAgYnJlYWs7XG4gICAgICBjYXNlICd3ZWVrZGF5JzogICAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICAgIGNhc2UgJ2RheSc6ICAgICAgICAgIGlmKHRoaXMuY3VycmVudC5kYXRlKCkgPCB0aGlzLnN0ZXArMSkgdGhpcy5jdXJyZW50LmRhdGUoMSk7IGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGgnOiAgICAgICAgaWYodGhpcy5jdXJyZW50Lm1vbnRoKCkgPCB0aGlzLnN0ZXApIHRoaXMuY3VycmVudC5tb250aCgwKTsgIGJyZWFrO1xuICAgICAgY2FzZSAneWVhcic6ICAgICAgICAgYnJlYWs7IC8vIG5vdGhpbmcgdG8gZG8gZm9yIHllYXJcbiAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNhZmV0eSBtZWNoYW5pc206IGlmIGN1cnJlbnQgdGltZSBpcyBzdGlsbCB1bmNoYW5nZWQsIG1vdmUgdG8gdGhlIGVuZFxuICBpZiAodGhpcy5jdXJyZW50LnZhbHVlT2YoKSA9PSBwcmV2KSB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fZW5kLmNsb25lKCk7XG4gIH1cblxuICBEYXRlVXRpbC5zdGVwT3ZlckhpZGRlbkRhdGVzKHRoaXMubW9tZW50LCB0aGlzLCBwcmV2KTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgZGF0ZXRpbWVcbiAqIEByZXR1cm4ge01vbWVudH0gIGN1cnJlbnQgVGhlIGN1cnJlbnQgZGF0ZVxuICovXG5UaW1lU3RlcC5wcm90b3R5cGUuZ2V0Q3VycmVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jdXJyZW50O1xufTtcblxuLyoqXG4gKiBTZXQgYSBjdXN0b20gc2NhbGUuIEF1dG9zY2FsaW5nIHdpbGwgYmUgZGlzYWJsZWQuXG4gKiBGb3IgZXhhbXBsZSBzZXRTY2FsZSgnbWludXRlJywgNSkgd2lsbCByZXN1bHRcbiAqIGluIG1pbm9yIHN0ZXBzIG9mIDUgbWludXRlcywgYW5kIG1ham9yIHN0ZXBzIG9mIGFuIGhvdXIuXG4gKlxuICogQHBhcmFtIHt7c2NhbGU6IHN0cmluZywgc3RlcDogbnVtYmVyfX0gcGFyYW1zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyB0d28gcHJvcGVydGllczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSBzdHJpbmcgJ3NjYWxlJy4gQ2hvb3NlIGZyb20gJ21pbGxpc2Vjb25kJywgJ3NlY29uZCcsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtaW51dGUnLCAnaG91cicsICd3ZWVrZGF5JywgJ2RheScsICdtb250aCcsICd5ZWFyJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSBudW1iZXIgJ3N0ZXAnLiBBIHN0ZXAgc2l6ZSwgYnkgZGVmYXVsdCAxLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaG9vc2UgZm9yIGV4YW1wbGUgMSwgMiwgNSwgb3IgMTAuXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMuc2NhbGUgPT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnNjYWxlID0gcGFyYW1zLnNjYWxlO1xuICAgIHRoaXMuc3RlcCA9IHBhcmFtcy5zdGVwID4gMCA/IHBhcmFtcy5zdGVwIDogMTtcbiAgICB0aGlzLmF1dG9TY2FsZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIEVuYWJsZSBvciBkaXNhYmxlIGF1dG9zY2FsaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZSAgSWYgdHJ1ZSwgYXV0b2FzY2FsaW5nIGlzIHNldCB0cnVlXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5zZXRBdXRvU2NhbGUgPSBmdW5jdGlvbiAoZW5hYmxlKSB7XG4gIHRoaXMuYXV0b1NjYWxlID0gZW5hYmxlO1xufTtcblxuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIHRoZSBzY2FsZSB0aGF0IGJlc3RzIGZpdHMgdGhlIHByb3ZpZGVkIG1pbmltdW0gc3RlcFxuICogQHBhcmFtIHtOdW1iZXJ9IFttaW5pbXVtU3RlcF0gIFRoZSBtaW5pbXVtIHN0ZXAgc2l6ZSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuVGltZVN0ZXAucHJvdG90eXBlLnNldE1pbmltdW1TdGVwID0gZnVuY3Rpb24obWluaW11bVN0ZXApIHtcbiAgaWYgKG1pbmltdW1TdGVwID09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vdmFyIGIgPSBhc2MgKyBkcztcblxuICB2YXIgc3RlcFllYXIgICAgICAgPSAoMTAwMCAqIDYwICogNjAgKiAyNCAqIDMwICogMTIpO1xuICB2YXIgc3RlcE1vbnRoICAgICAgPSAoMTAwMCAqIDYwICogNjAgKiAyNCAqIDMwKTtcbiAgdmFyIHN0ZXBEYXkgICAgICAgID0gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xuICB2YXIgc3RlcEhvdXIgICAgICAgPSAoMTAwMCAqIDYwICogNjApO1xuICB2YXIgc3RlcE1pbnV0ZSAgICAgPSAoMTAwMCAqIDYwKTtcbiAgdmFyIHN0ZXBTZWNvbmQgICAgID0gKDEwMDApO1xuICB2YXIgc3RlcE1pbGxpc2Vjb25kPSAoMSk7XG5cbiAgLy8gZmluZCB0aGUgc21hbGxlc3Qgc3RlcCB0aGF0IGlzIGxhcmdlciB0aGFuIHRoZSBwcm92aWRlZCBtaW5pbXVtU3RlcFxuICBpZiAoc3RlcFllYXIqMTAwMCA+IG1pbmltdW1TdGVwKSAgICAgICAge3RoaXMuc2NhbGUgPSAneWVhcic7ICAgICAgICB0aGlzLnN0ZXAgPSAxMDAwO31cbiAgaWYgKHN0ZXBZZWFyKjUwMCA+IG1pbmltdW1TdGVwKSAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3llYXInOyAgICAgICAgdGhpcy5zdGVwID0gNTAwO31cbiAgaWYgKHN0ZXBZZWFyKjEwMCA+IG1pbmltdW1TdGVwKSAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3llYXInOyAgICAgICAgdGhpcy5zdGVwID0gMTAwO31cbiAgaWYgKHN0ZXBZZWFyKjUwID4gbWluaW11bVN0ZXApICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3llYXInOyAgICAgICAgdGhpcy5zdGVwID0gNTA7fVxuICBpZiAoc3RlcFllYXIqMTAgPiBtaW5pbXVtU3RlcCkgICAgICAgICAge3RoaXMuc2NhbGUgPSAneWVhcic7ICAgICAgICB0aGlzLnN0ZXAgPSAxMDt9XG4gIGlmIChzdGVwWWVhcio1ID4gbWluaW11bVN0ZXApICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICd5ZWFyJzsgICAgICAgIHRoaXMuc3RlcCA9IDU7fVxuICBpZiAoc3RlcFllYXIgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICAge3RoaXMuc2NhbGUgPSAneWVhcic7ICAgICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBNb250aCozID4gbWluaW11bVN0ZXApICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ21vbnRoJzsgICAgICAgdGhpcy5zdGVwID0gMzt9XG4gIGlmIChzdGVwTW9udGggPiBtaW5pbXVtU3RlcCkgICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdtb250aCc7ICAgICAgIHRoaXMuc3RlcCA9IDE7fVxuICBpZiAoc3RlcERheSo1ID4gbWluaW11bVN0ZXApICAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnZGF5JzsgICAgICAgICB0aGlzLnN0ZXAgPSA1O31cbiAgaWYgKHN0ZXBEYXkqMiA+IG1pbmltdW1TdGVwKSAgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ2RheSc7ICAgICAgICAgdGhpcy5zdGVwID0gMjt9XG4gIGlmIChzdGVwRGF5ID4gbWluaW11bVN0ZXApICAgICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdkYXknOyAgICAgICAgIHRoaXMuc3RlcCA9IDE7fVxuICBpZiAoc3RlcERheS8yID4gbWluaW11bVN0ZXApICAgICAgICAgICAge3RoaXMuc2NhbGUgPSAnd2Vla2RheSc7ICAgICB0aGlzLnN0ZXAgPSAxO31cbiAgaWYgKHN0ZXBIb3VyKjQgPiBtaW5pbXVtU3RlcCkgICAgICAgICAgIHt0aGlzLnNjYWxlID0gJ2hvdXInOyAgICAgICAgdGhpcy5zdGVwID0gNDt9XG4gIGlmIChzdGVwSG91ciA+IG1pbmltdW1TdGVwKSAgICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdob3VyJzsgICAgICAgIHRoaXMuc3RlcCA9IDE7fVxuICBpZiAoc3RlcE1pbnV0ZSoxNSA+IG1pbmltdW1TdGVwKSAgICAgICAge3RoaXMuc2NhbGUgPSAnbWludXRlJzsgICAgICB0aGlzLnN0ZXAgPSAxNTt9XG4gIGlmIChzdGVwTWludXRlKjEwID4gbWluaW11bVN0ZXApICAgICAgICB7dGhpcy5zY2FsZSA9ICdtaW51dGUnOyAgICAgIHRoaXMuc3RlcCA9IDEwO31cbiAgaWYgKHN0ZXBNaW51dGUqNSA+IG1pbmltdW1TdGVwKSAgICAgICAgIHt0aGlzLnNjYWxlID0gJ21pbnV0ZSc7ICAgICAgdGhpcy5zdGVwID0gNTt9XG4gIGlmIChzdGVwTWludXRlID4gbWluaW11bVN0ZXApICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdtaW51dGUnOyAgICAgIHRoaXMuc3RlcCA9IDE7fVxuICBpZiAoc3RlcFNlY29uZCoxNSA+IG1pbmltdW1TdGVwKSAgICAgICAge3RoaXMuc2NhbGUgPSAnc2Vjb25kJzsgICAgICB0aGlzLnN0ZXAgPSAxNTt9XG4gIGlmIChzdGVwU2Vjb25kKjEwID4gbWluaW11bVN0ZXApICAgICAgICB7dGhpcy5zY2FsZSA9ICdzZWNvbmQnOyAgICAgIHRoaXMuc3RlcCA9IDEwO31cbiAgaWYgKHN0ZXBTZWNvbmQqNSA+IG1pbmltdW1TdGVwKSAgICAgICAgIHt0aGlzLnNjYWxlID0gJ3NlY29uZCc7ICAgICAgdGhpcy5zdGVwID0gNTt9XG4gIGlmIChzdGVwU2Vjb25kID4gbWluaW11bVN0ZXApICAgICAgICAgICB7dGhpcy5zY2FsZSA9ICdzZWNvbmQnOyAgICAgIHRoaXMuc3RlcCA9IDE7fVxuICBpZiAoc3RlcE1pbGxpc2Vjb25kKjIwMCA+IG1pbmltdW1TdGVwKSAge3RoaXMuc2NhbGUgPSAnbWlsbGlzZWNvbmQnOyB0aGlzLnN0ZXAgPSAyMDA7fVxuICBpZiAoc3RlcE1pbGxpc2Vjb25kKjEwMCA+IG1pbmltdW1TdGVwKSAge3RoaXMuc2NhbGUgPSAnbWlsbGlzZWNvbmQnOyB0aGlzLnN0ZXAgPSAxMDA7fVxuICBpZiAoc3RlcE1pbGxpc2Vjb25kKjUwID4gbWluaW11bVN0ZXApICAge3RoaXMuc2NhbGUgPSAnbWlsbGlzZWNvbmQnOyB0aGlzLnN0ZXAgPSA1MDt9XG4gIGlmIChzdGVwTWlsbGlzZWNvbmQqMTAgPiBtaW5pbXVtU3RlcCkgICB7dGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7IHRoaXMuc3RlcCA9IDEwO31cbiAgaWYgKHN0ZXBNaWxsaXNlY29uZCo1ID4gbWluaW11bVN0ZXApICAgIHt0aGlzLnNjYWxlID0gJ21pbGxpc2Vjb25kJzsgdGhpcy5zdGVwID0gNTt9XG4gIGlmIChzdGVwTWlsbGlzZWNvbmQgPiBtaW5pbXVtU3RlcCkgICAgICB7dGhpcy5zY2FsZSA9ICdtaWxsaXNlY29uZCc7IHRoaXMuc3RlcCA9IDE7fVxufTtcblxuLyoqXG4gKiBTbmFwIGEgZGF0ZSB0byBhIHJvdW5kZWQgdmFsdWUuXG4gKiBUaGUgc25hcCBpbnRlcnZhbHMgYXJlIGRlcGVuZGVudCBvbiB0aGUgY3VycmVudCBzY2FsZSBhbmQgc3RlcC5cbiAqIFN0YXRpYyBmdW5jdGlvblxuICogQHBhcmFtIHtEYXRlfSBkYXRlICAgIHRoZSBkYXRlIHRvIGJlIHNuYXBwZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NhbGUgQ3VycmVudCBzY2FsZSwgY2FuIGJlICdtaWxsaXNlY29uZCcsICdzZWNvbmQnLFxuICogICAgICAgICAgICAgICAgICAgICAgICdtaW51dGUnLCAnaG91cicsICd3ZWVrZGF5LCAnZGF5JywgJ21vbnRoJywgJ3llYXInLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgIEN1cnJlbnQgc3RlcCAoMSwgMiwgNCwgNSwgLi4uXG4gKiBAcmV0dXJuIHtEYXRlfSBzbmFwcGVkRGF0ZVxuICovXG5UaW1lU3RlcC5zbmFwID0gZnVuY3Rpb24oZGF0ZSwgc2NhbGUsIHN0ZXApIHtcbiAgdmFyIGNsb25lID0gbW9tZW50KGRhdGUpO1xuXG4gIGlmIChzY2FsZSA9PSAneWVhcicpIHtcbiAgICB2YXIgeWVhciA9IGNsb25lLnllYXIoKSArIE1hdGgucm91bmQoY2xvbmUubW9udGgoKSAvIDEyKTtcbiAgICBjbG9uZS55ZWFyKE1hdGgucm91bmQoeWVhciAvIHN0ZXApICogc3RlcCk7XG4gICAgY2xvbmUubW9udGgoMCk7XG4gICAgY2xvbmUuZGF0ZSgwKTtcbiAgICBjbG9uZS5ob3VycygwKTtcbiAgICBjbG9uZS5taW51dGVzKDApO1xuICAgIGNsb25lLnNlY29uZHMoMCk7XG4gICAgY2xvbmUubWlsbGlzZWNvbmRzKDApO1xuICB9XG4gIGVsc2UgaWYgKHNjYWxlID09ICdtb250aCcpIHtcbiAgICBpZiAoY2xvbmUuZGF0ZSgpID4gMTUpIHtcbiAgICAgIGNsb25lLmRhdGUoMSk7XG4gICAgICBjbG9uZS5hZGQoMSwgJ21vbnRoJyk7XG4gICAgICAvLyBpbXBvcnRhbnQ6IGZpcnN0IHNldCBEYXRlIHRvIDEsIGFmdGVyIHRoYXQgY2hhbmdlIHRoZSBtb250aC5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjbG9uZS5kYXRlKDEpO1xuICAgIH1cblxuICAgIGNsb25lLmhvdXJzKDApO1xuICAgIGNsb25lLm1pbnV0ZXMoMCk7XG4gICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gIH1cbiAgZWxzZSBpZiAoc2NhbGUgPT0gJ2RheScpIHtcbiAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgIGNhc2UgNTpcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgY2xvbmUuaG91cnMoTWF0aC5yb3VuZChjbG9uZS5ob3VycygpIC8gMjQpICogMjQpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNsb25lLmhvdXJzKE1hdGgucm91bmQoY2xvbmUuaG91cnMoKSAvIDEyKSAqIDEyKTsgYnJlYWs7XG4gICAgfVxuICAgIGNsb25lLm1pbnV0ZXMoMCk7XG4gICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gIH1cbiAgZWxzZSBpZiAoc2NhbGUgPT0gJ3dlZWtkYXknKSB7XG4gICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgc3dpdGNoIChzdGVwKSB7XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGNsb25lLmhvdXJzKE1hdGgucm91bmQoY2xvbmUuaG91cnMoKSAvIDEyKSAqIDEyKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjbG9uZS5ob3VycyhNYXRoLnJvdW5kKGNsb25lLmhvdXJzKCkgLyA2KSAqIDYpOyBicmVhaztcbiAgICB9XG4gICAgY2xvbmUubWludXRlcygwKTtcbiAgICBjbG9uZS5zZWNvbmRzKDApO1xuICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgfVxuICBlbHNlIGlmIChzY2FsZSA9PSAnaG91cicpIHtcbiAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgY2xvbmUubWludXRlcyhNYXRoLnJvdW5kKGNsb25lLm1pbnV0ZXMoKSAvIDYwKSAqIDYwKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjbG9uZS5taW51dGVzKE1hdGgucm91bmQoY2xvbmUubWludXRlcygpIC8gMzApICogMzApOyBicmVhaztcbiAgICB9XG4gICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gIH0gZWxzZSBpZiAoc2NhbGUgPT0gJ21pbnV0ZScpIHtcbiAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICBzd2l0Y2ggKHN0ZXApIHtcbiAgICAgIGNhc2UgMTU6XG4gICAgICBjYXNlIDEwOlxuICAgICAgICBjbG9uZS5taW51dGVzKE1hdGgucm91bmQoY2xvbmUubWludXRlcygpIC8gNSkgKiA1KTtcbiAgICAgICAgY2xvbmUuc2Vjb25kcygwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIGNsb25lLnNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5zZWNvbmRzKCkgLyA2MCkgKiA2MCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2xvbmUuc2Vjb25kcyhNYXRoLnJvdW5kKGNsb25lLnNlY29uZHMoKSAvIDMwKSAqIDMwKTsgYnJlYWs7XG4gICAgfVxuICAgIGNsb25lLm1pbGxpc2Vjb25kcygwKTtcbiAgfVxuICBlbHNlIGlmIChzY2FsZSA9PSAnc2Vjb25kJykge1xuICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaCAoc3RlcCkge1xuICAgICAgY2FzZSAxNTpcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIGNsb25lLnNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5zZWNvbmRzKCkgLyA1KSAqIDUpO1xuICAgICAgICBjbG9uZS5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBjbG9uZS5taWxsaXNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5taWxsaXNlY29uZHMoKSAvIDEwMDApICogMTAwMCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2xvbmUubWlsbGlzZWNvbmRzKE1hdGgucm91bmQoY2xvbmUubWlsbGlzZWNvbmRzKCkgLyA1MDApICogNTAwKTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHNjYWxlID09ICdtaWxsaXNlY29uZCcpIHtcbiAgICB2YXIgX3N0ZXAgPSBzdGVwID4gNSA/IHN0ZXAgLyAyIDogMTtcbiAgICBjbG9uZS5taWxsaXNlY29uZHMoTWF0aC5yb3VuZChjbG9uZS5taWxsaXNlY29uZHMoKSAvIF9zdGVwKSAqIF9zdGVwKTtcbiAgfVxuICBcbiAgcmV0dXJuIGNsb25lO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIG1ham9yIHZhbHVlIChmb3IgZXhhbXBsZSB3aGVuIHRoZSBzdGVwXG4gKiBpcyBEQVksIGEgbWFqb3IgdmFsdWUgaXMgZWFjaCBmaXJzdCBkYXkgb2YgdGhlIE1PTlRIKVxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBjdXJyZW50IGRhdGUgaXMgbWFqb3IsIGVsc2UgZmFsc2UuXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5pc01ham9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN3aXRjaGVkWWVhciA9PSB0cnVlKSB7XG4gICAgdGhpcy5zd2l0Y2hlZFllYXIgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgY2FzZSAnd2Vla2RheSc6XG4gICAgICBjYXNlICdkYXknOlxuICAgICAgY2FzZSAnaG91cic6XG4gICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKHRoaXMuc3dpdGNoZWRNb250aCA9PSB0cnVlKSB7XG4gICAgdGhpcy5zd2l0Y2hlZE1vbnRoID0gZmFsc2U7XG4gICAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgICBjYXNlICd3ZWVrZGF5JzpcbiAgICAgIGNhc2UgJ2RheSc6XG4gICAgICBjYXNlICdob3VyJzpcbiAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodGhpcy5zd2l0Y2hlZERheSA9PSB0cnVlKSB7XG4gICAgdGhpcy5zd2l0Y2hlZERheSA9IGZhbHNlO1xuICAgIHN3aXRjaCAodGhpcy5zY2FsZSkge1xuICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRhdGUgPSB0aGlzLm1vbWVudCh0aGlzLmN1cnJlbnQpO1xuICBzd2l0Y2ggKHRoaXMuc2NhbGUpIHtcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICByZXR1cm4gKGRhdGUubWlsbGlzZWNvbmRzKCkgPT0gMCk7XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgIHJldHVybiAoZGF0ZS5zZWNvbmRzKCkgPT0gMCk7XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICAgIHJldHVybiAoZGF0ZS5ob3VycygpID09IDApICYmIChkYXRlLm1pbnV0ZXMoKSA9PSAwKTtcbiAgICBjYXNlICdob3VyJzpcbiAgICAgIHJldHVybiAoZGF0ZS5ob3VycygpID09IDApO1xuICAgIGNhc2UgJ3dlZWtkYXknOiAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcbiAgICBjYXNlICdkYXknOlxuICAgICAgcmV0dXJuIChkYXRlLmRhdGUoKSA9PSAxKTtcbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gKGRhdGUubW9udGgoKSA9PSAwKTtcbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBmb3JtYXR0ZWQgdGV4dCBmb3IgdGhlIG1pbm9yIGF4aXNsYWJlbCwgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50XG4gKiBkYXRlIGFuZCB0aGUgc2NhbGUuIEZvciBleGFtcGxlIHdoZW4gc2NhbGUgaXMgTUlOVVRFLCB0aGUgY3VycmVudCB0aW1lIGlzXG4gKiBmb3JtYXR0ZWQgYXMgXCJoaDptbVwiLlxuICogQHBhcmFtIHtEYXRlfSBbZGF0ZV0gY3VzdG9tIGRhdGUuIGlmIG5vdCBwcm92aWRlZCwgY3VycmVudCBkYXRlIGlzIHRha2VuXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5nZXRMYWJlbE1pbm9yID0gZnVuY3Rpb24oZGF0ZSkge1xuICBpZiAoZGF0ZSA9PSB1bmRlZmluZWQpIHtcbiAgICBkYXRlID0gdGhpcy5jdXJyZW50O1xuICB9XG5cbiAgdmFyIGZvcm1hdCA9IHRoaXMuZm9ybWF0Lm1pbm9yTGFiZWxzW3RoaXMuc2NhbGVdO1xuICByZXR1cm4gKGZvcm1hdCAmJiBmb3JtYXQubGVuZ3RoID4gMCkgPyB0aGlzLm1vbWVudChkYXRlKS5mb3JtYXQoZm9ybWF0KSA6ICcnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGZvcm1hdHRlZCB0ZXh0IGZvciB0aGUgbWFqb3IgYXhpcyBsYWJlbCwgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50XG4gKiBkYXRlIGFuZCB0aGUgc2NhbGUuIEZvciBleGFtcGxlIHdoZW4gc2NhbGUgaXMgTUlOVVRFLCB0aGUgbWFqb3Igc2NhbGUgaXNcbiAqIGhvdXJzLCBhbmQgdGhlIGhvdXIgd2lsbCBiZSBmb3JtYXR0ZWQgYXMgXCJoaFwiLlxuICogQHBhcmFtIHtEYXRlfSBbZGF0ZV0gY3VzdG9tIGRhdGUuIGlmIG5vdCBwcm92aWRlZCwgY3VycmVudCBkYXRlIGlzIHRha2VuXG4gKi9cblRpbWVTdGVwLnByb3RvdHlwZS5nZXRMYWJlbE1ham9yID0gZnVuY3Rpb24oZGF0ZSkge1xuICBpZiAoZGF0ZSA9PSB1bmRlZmluZWQpIHtcbiAgICBkYXRlID0gdGhpcy5jdXJyZW50O1xuICB9XG5cbiAgdmFyIGZvcm1hdCA9IHRoaXMuZm9ybWF0Lm1ham9yTGFiZWxzW3RoaXMuc2NhbGVdO1xuICByZXR1cm4gKGZvcm1hdCAmJiBmb3JtYXQubGVuZ3RoID4gMCkgPyB0aGlzLm1vbWVudChkYXRlKS5mb3JtYXQoZm9ybWF0KSA6ICcnO1xufTtcblxuVGltZVN0ZXAucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX21vbWVudCA9IHRoaXMubW9tZW50O1xuICB2YXIgbSA9IHRoaXMubW9tZW50KHRoaXMuY3VycmVudCk7XG4gIHZhciBjdXJyZW50ID0gbS5sb2NhbGUgPyBtLmxvY2FsZSgnZW4nKSA6IG0ubGFuZygnZW4nKTsgLy8gb2xkIHZlcnNpb25zIG9mIG1vbWVudCBoYXZlIC5sYW5nKCkgZnVuY3Rpb25cbiAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXA7XG5cbiAgZnVuY3Rpb24gZXZlbih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgLyBzdGVwICUgMiA9PSAwKSA/ICcgdmlzLWV2ZW4nIDogJyB2aXMtb2RkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZGF5KGRhdGUpIHtcbiAgICBpZiAoZGF0ZS5pc1NhbWUobmV3IERhdGUoKSwgJ2RheScpKSB7XG4gICAgICByZXR1cm4gJyB2aXMtdG9kYXknO1xuICAgIH1cbiAgICBpZiAoZGF0ZS5pc1NhbWUoX21vbWVudCgpLmFkZCgxLCAnZGF5JyksICdkYXknKSkge1xuICAgICAgcmV0dXJuICcgdmlzLXRvbW9ycm93JztcbiAgICB9XG4gICAgaWYgKGRhdGUuaXNTYW1lKF9tb21lbnQoKS5hZGQoLTEsICdkYXknKSwgJ2RheScpKSB7XG4gICAgICByZXR1cm4gJyB2aXMteWVzdGVyZGF5JztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gY3VycmVudFdlZWsoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmlzU2FtZShuZXcgRGF0ZSgpLCAnd2VlaycpID8gJyB2aXMtY3VycmVudC13ZWVrJyA6ICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gY3VycmVudE1vbnRoKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5pc1NhbWUobmV3IERhdGUoKSwgJ21vbnRoJykgPyAnIHZpcy1jdXJyZW50LW1vbnRoJyA6ICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gY3VycmVudFllYXIoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmlzU2FtZShuZXcgRGF0ZSgpLCAneWVhcicpID8gJyB2aXMtY3VycmVudC15ZWFyJyA6ICcnO1xuICB9XG5cbiAgc3dpdGNoICh0aGlzLnNjYWxlKSB7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgcmV0dXJuIGV2ZW4oY3VycmVudC5taWxsaXNlY29uZHMoKSkudHJpbSgpO1xuXG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgIHJldHVybiBldmVuKGN1cnJlbnQuc2Vjb25kcygpKS50cmltKCk7XG5cbiAgICBjYXNlICdtaW51dGUnOlxuICAgICAgcmV0dXJuIGV2ZW4oY3VycmVudC5taW51dGVzKCkpLnRyaW0oKTtcblxuICAgIGNhc2UgJ2hvdXInOlxuICAgICAgdmFyIGhvdXJzID0gY3VycmVudC5ob3VycygpO1xuICAgICAgaWYgKHRoaXMuc3RlcCA9PSA0KSB7XG4gICAgICAgIGhvdXJzID0gaG91cnMgKyAnLWgnICsgKGhvdXJzICsgNCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3Zpcy1oJyArIGhvdXJzICsgdG9kYXkoY3VycmVudCkgKyBldmVuKGN1cnJlbnQuaG91cnMoKSk7XG5cbiAgICBjYXNlICd3ZWVrZGF5JzpcbiAgICAgIHJldHVybiAndmlzLScgKyBjdXJyZW50LmZvcm1hdCgnZGRkZCcpLnRvTG93ZXJDYXNlKCkgK1xuICAgICAgICAgIHRvZGF5KGN1cnJlbnQpICsgY3VycmVudFdlZWsoY3VycmVudCkgKyBldmVuKGN1cnJlbnQuZGF0ZSgpKTtcblxuICAgIGNhc2UgJ2RheSc6XG4gICAgICB2YXIgZGF5ID0gY3VycmVudC5kYXRlKCk7XG4gICAgICB2YXIgbW9udGggPSBjdXJyZW50LmZvcm1hdCgnTU1NTScpLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gJ3Zpcy1kYXknICsgZGF5ICsgJyB2aXMtJyArIG1vbnRoICsgY3VycmVudE1vbnRoKGN1cnJlbnQpICsgZXZlbihkYXkgLSAxKTtcblxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHJldHVybiAndmlzLScgKyBjdXJyZW50LmZvcm1hdCgnTU1NTScpLnRvTG93ZXJDYXNlKCkgK1xuICAgICAgICAgIGN1cnJlbnRNb250aChjdXJyZW50KSArIGV2ZW4oY3VycmVudC5tb250aCgpKTtcblxuICAgIGNhc2UgJ3llYXInOlxuICAgICAgdmFyIHllYXIgPSBjdXJyZW50LnllYXIoKTtcbiAgICAgIHJldHVybiAndmlzLXllYXInICsgeWVhciArIGN1cnJlbnRZZWFyKGN1cnJlbnQpKyBldmVuKHllYXIpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lU3RlcDtcbiJdfQ==
},{"../module/moment":20,"../util":46,"./DateUtil":27}],31:[function(require,module,exports){
'use strict';

var Emitter = require('emitter-component');
var Hammer = require('../module/hammer');
var moment = require('../module/moment');
var util = require('../util');
var DataSet = require('../DataSet');
var DataView = require('../DataView');
var Range = require('./Range');
var Core = require('./Core');
var TimeAxis = require('./component/TimeAxis');
var CurrentTime = require('./component/CurrentTime');
var CustomTime = require('./component/CustomTime');
var ItemSet = require('./component/ItemSet');

var Configurator = require('../shared/Configurator');
var Validator = require('../shared/Validator')['default'];
var printStyle = require('../shared/Validator').printStyle;
var allOptions = require('./optionsTimeline').allOptions;
var configureOptions = require('./optionsTimeline').configureOptions;

/**
 * Create a timeline visualization
 * @param {HTMLElement} container
 * @param {vis.DataSet | vis.DataView | Array} [items]
 * @param {vis.DataSet | vis.DataView | Array} [groups]
 * @param {Object} [options]  See Timeline.setOptions for the available options.
 * @constructor
 * @extends Core
 */
function Timeline(container, items, groups, options) {
  if (!(this instanceof Timeline)) {
    throw new SyntaxError('Constructor must be called with the new operator');
  }

  // if the third element is options, the forth is groups (optionally);
  if (!(Array.isArray(groups) || groups instanceof DataSet || groups instanceof DataView) && groups instanceof Object) {
    var forthArgument = options;
    options = groups;
    groups = forthArgument;
  }

  var me = this;
  this.defaultOptions = {
    start: null,
    end: null,

    autoResize: true,
    throttleRedraw: 0, // ms

    orientation: {
      axis: 'bottom', // axis orientation: 'bottom', 'top', or 'both'
      item: 'bottom' // not relevant
    },

    moment: moment,

    width: null,
    height: null,
    maxHeight: null,
    minHeight: null
  };
  this.options = util.deepExtend({}, this.defaultOptions);

  // Create the DOM, props, and emitter
  this._create(container);

  // all components listed here will be repainted automatically
  this.components = [];

  this.body = {
    dom: this.dom,
    domProps: this.props,
    emitter: {
      on: this.on.bind(this),
      off: this.off.bind(this),
      emit: this.emit.bind(this)
    },
    hiddenDates: [],
    util: {
      getScale: function getScale() {
        return me.timeAxis.step.scale;
      },
      getStep: function getStep() {
        return me.timeAxis.step.step;
      },

      toScreen: me._toScreen.bind(me),
      toGlobalScreen: me._toGlobalScreen.bind(me), // this refers to the root.width
      toTime: me._toTime.bind(me),
      toGlobalTime: me._toGlobalTime.bind(me)
    }
  };

  // range
  this.range = new Range(this.body);
  this.components.push(this.range);
  this.body.range = this.range;

  // time axis
  this.timeAxis = new TimeAxis(this.body);
  this.timeAxis2 = null; // used in case of orientation option 'both'
  this.components.push(this.timeAxis);

  // current time bar
  this.currentTime = new CurrentTime(this.body);
  this.components.push(this.currentTime);

  // item set
  this.itemSet = new ItemSet(this.body);
  this.components.push(this.itemSet);

  this.itemsData = null; // DataSet
  this.groupsData = null; // DataSet

  this.on('tap', function (event) {
    me.emit('click', me.getEventProperties(event));
  });
  this.on('doubletap', function (event) {
    me.emit('doubleClick', me.getEventProperties(event));
  });
  this.dom.root.oncontextmenu = function (event) {
    me.emit('contextmenu', me.getEventProperties(event));
  };

  // apply options
  if (options) {
    this.setOptions(options);
  }

  // IMPORTANT: THIS HAPPENS BEFORE SET ITEMS!
  if (groups) {
    this.setGroups(groups);
  }

  // create itemset
  if (items) {
    this.setItems(items);
  } else {
    this._redraw();
  }
}

// Extend the functionality from Core
Timeline.prototype = new Core();

/**
 * Load a configurator
 * @return {Object}
 * @private
 */
Timeline.prototype._createConfigurator = function () {
  return new Configurator(this, this.dom.container, configureOptions);
};

/**
 * Force a redraw. The size of all items will be recalculated.
 * Can be useful to manually redraw when option autoResize=false and the window
 * has been resized, or when the items CSS has been changed.
 *
 * Note: this function will be overridden on construction with a trottled version
 */
Timeline.prototype.redraw = function () {
  this.itemSet && this.itemSet.markDirty({ refreshItems: true });
  this._redraw();
};

Timeline.prototype.setOptions = function (options) {
  // validate options
  var errorFound = Validator.validate(options, allOptions);
  if (errorFound === true) {
    console.log('%cErrors have been found in the supplied options object.', printStyle);
  }

  Core.prototype.setOptions.call(this, options);

  if ('type' in options) {
    if (options.type !== this.options.type) {
      this.options.type = options.type;

      // force recreation of all items
      var itemsData = this.itemsData;
      if (itemsData) {
        var selection = this.getSelection();
        this.setItems(null); // remove all
        this.setItems(itemsData); // add all
        this.setSelection(selection); // restore selection
      }
    }
  }
};

/**
 * Set items
 * @param {vis.DataSet | Array | null} items
 */
Timeline.prototype.setItems = function (items) {
  var initialLoad = this.itemsData == null;

  // convert to type DataSet when needed
  var newDataSet;
  if (!items) {
    newDataSet = null;
  } else if (items instanceof DataSet || items instanceof DataView) {
    newDataSet = items;
  } else {
    // turn an array into a dataset
    newDataSet = new DataSet(items, {
      type: {
        start: 'Date',
        end: 'Date'
      }
    });
  }

  // set items
  this.itemsData = newDataSet;
  this.itemSet && this.itemSet.setItems(newDataSet);

  if (initialLoad) {
    if (this.options.start != undefined || this.options.end != undefined) {
      if (this.options.start == undefined || this.options.end == undefined) {
        var range = this.getItemRange();
      }

      var start = this.options.start != undefined ? this.options.start : range.min;
      var end = this.options.end != undefined ? this.options.end : range.max;

      this.setWindow(start, end, { animation: false });
    } else {
      this.fit({ animation: false });
    }
  }
};

/**
 * Set groups
 * @param {vis.DataSet | Array} groups
 */
Timeline.prototype.setGroups = function (groups) {
  // convert to type DataSet when needed
  var newDataSet;
  if (!groups) {
    newDataSet = null;
  } else if (groups instanceof DataSet || groups instanceof DataView) {
    newDataSet = groups;
  } else {
    // turn an array into a dataset
    newDataSet = new DataSet(groups);
  }

  this.groupsData = newDataSet;
  this.itemSet.setGroups(newDataSet);
};

/**
 * Set both items and groups in one go
 * @param {{items: Array | vis.DataSet, groups: Array | vis.DataSet}} data
 */
Timeline.prototype.setData = function (data) {
  if (data && data.groups) {
    this.setGroups(data.groups);
  }

  if (data && data.items) {
    this.setItems(data.items);
  }
};

/**
 * Set selected items by their id. Replaces the current selection
 * Unknown id's are silently ignored.
 * @param {string[] | string} [ids]  An array with zero or more id's of the items to be
 *                                selected. If ids is an empty array, all items will be
 *                                unselected.
 * @param {Object} [options]      Available options:
 *                                `focus: boolean`
 *                                    If true, focus will be set to the selected item(s)
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 *                                    Only applicable when option focus is true.
 */
Timeline.prototype.setSelection = function (ids, options) {
  this.itemSet && this.itemSet.setSelection(ids);

  if (options && options.focus) {
    this.focus(ids, options);
  }
};

/**
 * Get the selected items by their id
 * @return {Array} ids  The ids of the selected items
 */
Timeline.prototype.getSelection = function () {
  return this.itemSet && this.itemSet.getSelection() || [];
};

/**
 * Adjust the visible window such that the selected item (or multiple items)
 * are centered on screen.
 * @param {String | String[]} id     An item id or array with item ids
 * @param {Object} [options]      Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Timeline.prototype.focus = function (id, options) {
  if (!this.itemsData || id == undefined) return;

  var ids = Array.isArray(id) ? id : [id];

  // get the specified item(s)
  var itemsData = this.itemsData.getDataSet().get(ids, {
    type: {
      start: 'Date',
      end: 'Date'
    }
  });

  // calculate minimum start and maximum end of specified items
  var start = null;
  var end = null;
  itemsData.forEach(function (itemData) {
    var s = itemData.start.valueOf();
    var e = 'end' in itemData ? itemData.end.valueOf() : itemData.start.valueOf();

    if (start === null || s < start) {
      start = s;
    }

    if (end === null || e > end) {
      end = e;
    }
  });

  if (start !== null && end !== null) {
    // calculate the new middle and interval for the window
    var middle = (start + end) / 2;
    var interval = Math.max(this.range.end - this.range.start, (end - start) * 1.1);

    var animation = options && options.animation !== undefined ? options.animation : true;
    this.range.setRange(middle - interval / 2, middle + interval / 2, animation);
  }
};

/**
 * Set Timeline window such that it fits all items
 * @param {Object} [options]  Available options:
 *                                `animation: boolean | {duration: number, easingFunction: string}`
 *                                    If true (default), the range is animated
 *                                    smoothly to the new window. An object can be
 *                                    provided to specify duration and easing function.
 *                                    Default duration is 500 ms, and default easing
 *                                    function is 'easeInOutQuad'.
 */
Timeline.prototype.fit = function (options) {
  var animation = options && options.animation !== undefined ? options.animation : true;
  var range = this.getItemRange();
  this.range.setRange(range.min, range.max, animation);
};

/**
 * Determine the range of the items, taking into account their actual width
 * and a margin of 10 pixels on both sides.
 * @return {{min: Date | null, max: Date | null}}
 */
Timeline.prototype.getItemRange = function () {
  var _this = this;

  // get a rough approximation for the range based on the items start and end dates
  var range = this.getDataRange();
  var min = range.min;
  var max = range.max;
  var minItem = null;
  var maxItem = null;

  if (min != null && max != null) {
    var interval;
    var factor;
    var lhs;
    var rhs;
    var delta;

    (function () {
      var getStart = function getStart(item) {
        return util.convert(item.data.start, 'Date').valueOf();
      };

      var getEnd = function getEnd(item) {
        var end = item.data.end != undefined ? item.data.end : item.data.start;
        return util.convert(end, 'Date').valueOf();
      }

      // calculate the date of the left side and right side of the items given
      ;

      interval = max - min;
      // ms
      if (interval <= 0) {
        interval = 10;
      }
      factor = interval / _this.props.center.width;
      util.forEach(_this.itemSet.items, (function (item) {
        item.show();

        var start = getStart(item);
        var end = getEnd(item);

        var left = new Date(start - (item.getWidthLeft() + 10) * factor);
        var right = new Date(end + (item.getWidthRight() + 10) * factor);

        if (left < min) {
          min = left;
          minItem = item;
        }
        if (right > max) {
          max = right;
          maxItem = item;
        }
      }).bind(_this));

      if (minItem && maxItem) {
        lhs = minItem.getWidthLeft() + 10;
        rhs = maxItem.getWidthRight() + 10;
        delta = _this.props.center.width - lhs - rhs;
        // px

        if (delta > 0) {
          min = getStart(minItem) - lhs * interval / delta; // ms
          max = getEnd(maxItem) + rhs * interval / delta; // ms
        }
      }
    })();
  }

  return {
    min: min != null ? new Date(min) : null,
    max: max != null ? new Date(max) : null
  };
};

/**
 * Calculate the data range of the items start and end dates
 * @returns {{min: Date | null, max: Date | null}}
 */
Timeline.prototype.getDataRange = function () {
  var min = null;
  var max = null;

  var dataset = this.itemsData && this.itemsData.getDataSet();
  if (dataset) {
    dataset.forEach(function (item) {
      var start = util.convert(item.start, 'Date').valueOf();
      var end = util.convert(item.end != undefined ? item.end : item.start, 'Date').valueOf();
      if (min === null || start < min) {
        min = start;
      }
      if (max === null || end > max) {
        max = start;
      }
    });
  }

  return {
    min: min != null ? new Date(min) : null,
    max: max != null ? new Date(max) : null
  };
};

/**
 * Generate Timeline related information from an event
 * @param {Event} event
 * @return {Object} An object with related information, like on which area
 *                  The event happened, whether clicked on an item, etc.
 */
Timeline.prototype.getEventProperties = function (event) {
  var clientX = event.center ? event.center.x : event.clientX;
  var clientY = event.center ? event.center.y : event.clientY;
  var x = clientX - util.getAbsoluteLeft(this.dom.centerContainer);
  var y = clientY - util.getAbsoluteTop(this.dom.centerContainer);

  var item = this.itemSet.itemFromTarget(event);
  var group = this.itemSet.groupFromTarget(event);
  var customTime = CustomTime.customTimeFromTarget(event);

  var snap = this.itemSet.options.snap || null;
  var scale = this.body.util.getScale();
  var step = this.body.util.getStep();
  var time = this._toTime(x);
  var snappedTime = snap ? snap(time, scale, step) : time;

  var element = util.getTarget(event);
  var what = null;
  if (item != null) {
    what = 'item';
  } else if (customTime != null) {
    what = 'custom-time';
  } else if (util.hasParent(element, this.timeAxis.dom.foreground)) {
    what = 'axis';
  } else if (this.timeAxis2 && util.hasParent(element, this.timeAxis2.dom.foreground)) {
    what = 'axis';
  } else if (util.hasParent(element, this.itemSet.dom.labelSet)) {
    what = 'group-label';
  } else if (util.hasParent(element, this.currentTime.bar)) {
    what = 'current-time';
  } else if (util.hasParent(element, this.dom.center)) {
    what = 'background';
  }

  return {
    event: event,
    item: item ? item.id : null,
    group: group ? group.groupId : null,
    what: what,
    pageX: event.srcEvent ? event.srcEvent.pageX : event.pageX,
    pageY: event.srcEvent ? event.srcEvent.pageY : event.pageY,
    x: x,
    y: y,
    time: time,
    snappedTime: snappedTime
  };
};

module.exports = Timeline;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9UaW1lbGluZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQzNDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3pDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3pDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUM5QixJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDcEMsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3RDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUMvQixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDN0IsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFDL0MsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLHlCQUF5QixDQUFDLENBQUM7QUFDckQsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUM7QUFDbkQsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7O0FBRTdDLElBQUksWUFBWSxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQ3JELElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxXQUFRLENBQUM7QUFDdkQsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUMsVUFBVSxDQUFDO0FBQzNELElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLFVBQVUsQ0FBQztBQUN6RCxJQUFJ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QUksRUFBRSxJQUFJO0FBQ1YsU0FBSyxFQUFFLEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUs7QUFDMUQsU0FBSyxFQUFFLEtBQUssQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUs7QUFDMUQsS0FBQyxFQUFFLENBQUM7QUFDSixLQUFDLEVBQUUsQ0FBQztBQUNKLFFBQUksRUFBRSxJQUFJO0FBQ1YsZUFBVyxFQUFFLFdBQVc7R0FDekIsQ0FBQTtDQUNGLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL1RpbWVsaW5lLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdlbWl0dGVyLWNvbXBvbmVudCcpO1xudmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCcuLi9tb2R1bGUvbW9tZW50Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBEYXRhU2V0ID0gcmVxdWlyZSgnLi4vRGF0YVNldCcpO1xudmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi4vRGF0YVZpZXcnKTtcbnZhciBSYW5nZSA9IHJlcXVpcmUoJy4vUmFuZ2UnKTtcbnZhciBDb3JlID0gcmVxdWlyZSgnLi9Db3JlJyk7XG52YXIgVGltZUF4aXMgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9UaW1lQXhpcycpO1xudmFyIEN1cnJlbnRUaW1lID0gcmVxdWlyZSgnLi9jb21wb25lbnQvQ3VycmVudFRpbWUnKTtcbnZhciBDdXN0b21UaW1lID0gcmVxdWlyZSgnLi9jb21wb25lbnQvQ3VzdG9tVGltZScpO1xudmFyIEl0ZW1TZXQgPSByZXF1aXJlKCcuL2NvbXBvbmVudC9JdGVtU2V0Jyk7XG5cbnZhciBDb25maWd1cmF0b3IgPSByZXF1aXJlKCcuLi9zaGFyZWQvQ29uZmlndXJhdG9yJyk7XG52YXIgVmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vc2hhcmVkL1ZhbGlkYXRvcicpLmRlZmF1bHQ7XG52YXIgcHJpbnRTdHlsZSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9WYWxpZGF0b3InKS5wcmludFN0eWxlO1xudmFyIGFsbE9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnNUaW1lbGluZScpLmFsbE9wdGlvbnM7XG52YXIgY29uZmlndXJlT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9uc1RpbWVsaW5lJykuY29uZmlndXJlT3B0aW9ucztcblxuLyoqXG4gKiBDcmVhdGUgYSB0aW1lbGluZSB2aXN1YWxpemF0aW9uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7dmlzLkRhdGFTZXQgfCB2aXMuRGF0YVZpZXcgfCBBcnJheX0gW2l0ZW1zXVxuICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IHZpcy5EYXRhVmlldyB8IEFycmF5fSBbZ3JvdXBzXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgU2VlIFRpbWVsaW5lLnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ29yZVxuICovXG5mdW5jdGlvbiBUaW1lbGluZSAoY29udGFpbmVyLCBpdGVtcywgZ3JvdXBzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUaW1lbGluZSkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0NvbnN0cnVjdG9yIG11c3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBvcGVyYXRvcicpO1xuICB9XG5cbiAgLy8gaWYgdGhlIHRoaXJkIGVsZW1lbnQgaXMgb3B0aW9ucywgdGhlIGZvcnRoIGlzIGdyb3VwcyAob3B0aW9uYWxseSk7XG4gIGlmICghKEFycmF5LmlzQXJyYXkoZ3JvdXBzKSB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFWaWV3KSAmJiBncm91cHMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgZm9ydGhBcmd1bWVudCA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IGdyb3VwcztcbiAgICBncm91cHMgPSBmb3J0aEFyZ3VtZW50O1xuICB9XG5cbiAgdmFyIG1lID0gdGhpcztcbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBzdGFydDogbnVsbCxcbiAgICBlbmQ6ICAgbnVsbCxcblxuICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgdGhyb3R0bGVSZWRyYXc6IDAsIC8vIG1zXG5cbiAgICBvcmllbnRhdGlvbjoge1xuICAgICAgYXhpczogJ2JvdHRvbScsICAgLy8gYXhpcyBvcmllbnRhdGlvbjogJ2JvdHRvbScsICd0b3AnLCBvciAnYm90aCdcbiAgICAgIGl0ZW06ICdib3R0b20nICAgIC8vIG5vdCByZWxldmFudFxuICAgIH0sXG5cbiAgICBtb21lbnQ6IG1vbWVudCxcblxuICAgIHdpZHRoOiBudWxsLFxuICAgIGhlaWdodDogbnVsbCxcbiAgICBtYXhIZWlnaHQ6IG51bGwsXG4gICAgbWluSGVpZ2h0OiBudWxsXG4gIH07XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZGVlcEV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBET00sIHByb3BzLCBhbmQgZW1pdHRlclxuICB0aGlzLl9jcmVhdGUoY29udGFpbmVyKTtcblxuICAvLyBhbGwgY29tcG9uZW50cyBsaXN0ZWQgaGVyZSB3aWxsIGJlIHJlcGFpbnRlZCBhdXRvbWF0aWNhbGx5XG4gIHRoaXMuY29tcG9uZW50cyA9IFtdO1xuXG4gIHRoaXMuYm9keSA9IHtcbiAgICBkb206IHRoaXMuZG9tLFxuICAgIGRvbVByb3BzOiB0aGlzLnByb3BzLFxuICAgIGVtaXR0ZXI6IHtcbiAgICAgIG9uOiB0aGlzLm9uLmJpbmQodGhpcyksXG4gICAgICBvZmY6IHRoaXMub2ZmLmJpbmQodGhpcyksXG4gICAgICBlbWl0OiB0aGlzLmVtaXQuYmluZCh0aGlzKVxuICAgIH0sXG4gICAgaGlkZGVuRGF0ZXM6IFtdLFxuICAgIHV0aWw6IHtcbiAgICAgIGdldFNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZS50aW1lQXhpcy5zdGVwLnNjYWxlO1xuICAgICAgfSxcbiAgICAgIGdldFN0ZXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1lLnRpbWVBeGlzLnN0ZXAuc3RlcDtcbiAgICAgIH0sXG5cbiAgICAgIHRvU2NyZWVuOiBtZS5fdG9TY3JlZW4uYmluZChtZSksXG4gICAgICB0b0dsb2JhbFNjcmVlbjogbWUuX3RvR2xvYmFsU2NyZWVuLmJpbmQobWUpLCAvLyB0aGlzIHJlZmVycyB0byB0aGUgcm9vdC53aWR0aFxuICAgICAgdG9UaW1lOiBtZS5fdG9UaW1lLmJpbmQobWUpLFxuICAgICAgdG9HbG9iYWxUaW1lIDogbWUuX3RvR2xvYmFsVGltZS5iaW5kKG1lKVxuICAgIH1cbiAgfTtcblxuICAvLyByYW5nZVxuICB0aGlzLnJhbmdlID0gbmV3IFJhbmdlKHRoaXMuYm9keSk7XG4gIHRoaXMuY29tcG9uZW50cy5wdXNoKHRoaXMucmFuZ2UpO1xuICB0aGlzLmJvZHkucmFuZ2UgPSB0aGlzLnJhbmdlO1xuXG4gIC8vIHRpbWUgYXhpc1xuICB0aGlzLnRpbWVBeGlzID0gbmV3IFRpbWVBeGlzKHRoaXMuYm9keSk7XG4gIHRoaXMudGltZUF4aXMyID0gbnVsbDsgLy8gdXNlZCBpbiBjYXNlIG9mIG9yaWVudGF0aW9uIG9wdGlvbiAnYm90aCdcbiAgdGhpcy5jb21wb25lbnRzLnB1c2godGhpcy50aW1lQXhpcyk7XG5cbiAgLy8gY3VycmVudCB0aW1lIGJhclxuICB0aGlzLmN1cnJlbnRUaW1lID0gbmV3IEN1cnJlbnRUaW1lKHRoaXMuYm9keSk7XG4gIHRoaXMuY29tcG9uZW50cy5wdXNoKHRoaXMuY3VycmVudFRpbWUpO1xuXG4gIC8vIGl0ZW0gc2V0XG4gIHRoaXMuaXRlbVNldCA9IG5ldyBJdGVtU2V0KHRoaXMuYm9keSk7XG4gIHRoaXMuY29tcG9uZW50cy5wdXNoKHRoaXMuaXRlbVNldCk7XG5cbiAgdGhpcy5pdGVtc0RhdGEgPSBudWxsOyAgICAgIC8vIERhdGFTZXRcbiAgdGhpcy5ncm91cHNEYXRhID0gbnVsbDsgICAgIC8vIERhdGFTZXRcblxuICB0aGlzLm9uKCd0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBtZS5lbWl0KCdjbGljaycsIG1lLmdldEV2ZW50UHJvcGVydGllcyhldmVudCkpXG4gIH0pO1xuICB0aGlzLm9uKCdkb3VibGV0YXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBtZS5lbWl0KCdkb3VibGVDbGljaycsIG1lLmdldEV2ZW50UHJvcGVydGllcyhldmVudCkpXG4gIH0pO1xuICB0aGlzLmRvbS5yb290Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBtZS5lbWl0KCdjb250ZXh0bWVudScsIG1lLmdldEV2ZW50UHJvcGVydGllcyhldmVudCkpXG4gIH07XG5cbiAgLy8gYXBwbHkgb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8vIElNUE9SVEFOVDogVEhJUyBIQVBQRU5TIEJFRk9SRSBTRVQgSVRFTVMhXG4gIGlmIChncm91cHMpIHtcbiAgICB0aGlzLnNldEdyb3Vwcyhncm91cHMpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGl0ZW1zZXRcbiAgaWYgKGl0ZW1zKSB7XG4gICAgdGhpcy5zZXRJdGVtcyhpdGVtcyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5fcmVkcmF3KCk7XG4gIH1cbn1cblxuLy8gRXh0ZW5kIHRoZSBmdW5jdGlvbmFsaXR5IGZyb20gQ29yZVxuVGltZWxpbmUucHJvdG90eXBlID0gbmV3IENvcmUoKTtcblxuLyoqXG4gKiBMb2FkIGEgY29uZmlndXJhdG9yXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuX2NyZWF0ZUNvbmZpZ3VyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBDb25maWd1cmF0b3IodGhpcywgdGhpcy5kb20uY29udGFpbmVyLCBjb25maWd1cmVPcHRpb25zKTtcbn07XG5cbi8qKlxuICogRm9yY2UgYSByZWRyYXcuIFRoZSBzaXplIG9mIGFsbCBpdGVtcyB3aWxsIGJlIHJlY2FsY3VsYXRlZC5cbiAqIENhbiBiZSB1c2VmdWwgdG8gbWFudWFsbHkgcmVkcmF3IHdoZW4gb3B0aW9uIGF1dG9SZXNpemU9ZmFsc2UgYW5kIHRoZSB3aW5kb3dcbiAqIGhhcyBiZWVuIHJlc2l6ZWQsIG9yIHdoZW4gdGhlIGl0ZW1zIENTUyBoYXMgYmVlbiBjaGFuZ2VkLlxuICpcbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBvdmVycmlkZGVuIG9uIGNvbnN0cnVjdGlvbiB3aXRoIGEgdHJvdHRsZWQgdmVyc2lvblxuICovXG5UaW1lbGluZS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaXRlbVNldCAmJiB0aGlzLml0ZW1TZXQubWFya0RpcnR5KHtyZWZyZXNoSXRlbXM6IHRydWV9KTtcbiAgdGhpcy5fcmVkcmF3KCk7XG59O1xuXG5UaW1lbGluZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgbGV0IGVycm9yRm91bmQgPSBWYWxpZGF0b3IudmFsaWRhdGUob3B0aW9ucywgYWxsT3B0aW9ucyk7XG4gIGlmIChlcnJvckZvdW5kID09PSB0cnVlKSB7XG4gICAgY29uc29sZS5sb2coJyVjRXJyb3JzIGhhdmUgYmVlbiBmb3VuZCBpbiB0aGUgc3VwcGxpZWQgb3B0aW9ucyBvYmplY3QuJywgcHJpbnRTdHlsZSk7XG4gIH1cblxuICBDb3JlLnByb3RvdHlwZS5zZXRPcHRpb25zLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKCd0eXBlJyBpbiBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMudHlwZSAhPT0gdGhpcy5vcHRpb25zLnR5cGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50eXBlID0gb3B0aW9ucy50eXBlO1xuXG4gICAgICAvLyBmb3JjZSByZWNyZWF0aW9uIG9mIGFsbCBpdGVtc1xuICAgICAgdmFyIGl0ZW1zRGF0YSA9IHRoaXMuaXRlbXNEYXRhO1xuICAgICAgaWYgKGl0ZW1zRGF0YSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zZXRJdGVtcyhudWxsKTsgICAgICAgICAgLy8gcmVtb3ZlIGFsbFxuICAgICAgICB0aGlzLnNldEl0ZW1zKGl0ZW1zRGF0YSk7ICAgICAvLyBhZGQgYWxsXG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7IC8vIHJlc3RvcmUgc2VsZWN0aW9uXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNldCBpdGVtc1xuICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IEFycmF5IHwgbnVsbH0gaXRlbXNcbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLnNldEl0ZW1zID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgdmFyIGluaXRpYWxMb2FkID0gKHRoaXMuaXRlbXNEYXRhID09IG51bGwpO1xuXG4gIC8vIGNvbnZlcnQgdG8gdHlwZSBEYXRhU2V0IHdoZW4gbmVlZGVkXG4gIHZhciBuZXdEYXRhU2V0O1xuICBpZiAoIWl0ZW1zKSB7XG4gICAgbmV3RGF0YVNldCA9IG51bGw7XG4gIH1cbiAgZWxzZSBpZiAoaXRlbXMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGl0ZW1zIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICBuZXdEYXRhU2V0ID0gaXRlbXM7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gdHVybiBhbiBhcnJheSBpbnRvIGEgZGF0YXNldFxuICAgIG5ld0RhdGFTZXQgPSBuZXcgRGF0YVNldChpdGVtcywge1xuICAgICAgdHlwZToge1xuICAgICAgICBzdGFydDogJ0RhdGUnLFxuICAgICAgICBlbmQ6ICdEYXRlJ1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gc2V0IGl0ZW1zXG4gIHRoaXMuaXRlbXNEYXRhID0gbmV3RGF0YVNldDtcbiAgdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5zZXRJdGVtcyhuZXdEYXRhU2V0KTtcblxuICBpZiAoaW5pdGlhbExvYWQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnN0YXJ0ICE9IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFydCA9PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmVuZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRJdGVtUmFuZ2UoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5vcHRpb25zLnN0YXJ0ICE9IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zdGFydCA6IHJhbmdlLm1pbjtcbiAgICAgIHZhciBlbmQgICA9IHRoaXMub3B0aW9ucy5lbmQgIT0gdW5kZWZpbmVkICAgPyB0aGlzLm9wdGlvbnMuZW5kICAgOiByYW5nZS5tYXg7XG5cbiAgICAgIHRoaXMuc2V0V2luZG93KHN0YXJ0LCBlbmQsIHthbmltYXRpb246IGZhbHNlfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5maXQoe2FuaW1hdGlvbjogZmFsc2V9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGdyb3Vwc1xuICogQHBhcmFtIHt2aXMuRGF0YVNldCB8IEFycmF5fSBncm91cHNcbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLnNldEdyb3VwcyA9IGZ1bmN0aW9uKGdyb3Vwcykge1xuICAvLyBjb252ZXJ0IHRvIHR5cGUgRGF0YVNldCB3aGVuIG5lZWRlZFxuICB2YXIgbmV3RGF0YVNldDtcbiAgaWYgKCFncm91cHMpIHtcbiAgICBuZXdEYXRhU2V0ID0gbnVsbDtcbiAgfVxuICBlbHNlIGlmIChncm91cHMgaW5zdGFuY2VvZiBEYXRhU2V0IHx8IGdyb3VwcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgbmV3RGF0YVNldCA9IGdyb3VwcztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyB0dXJuIGFuIGFycmF5IGludG8gYSBkYXRhc2V0XG4gICAgbmV3RGF0YVNldCA9IG5ldyBEYXRhU2V0KGdyb3Vwcyk7XG4gIH1cblxuICB0aGlzLmdyb3Vwc0RhdGEgPSBuZXdEYXRhU2V0O1xuICB0aGlzLml0ZW1TZXQuc2V0R3JvdXBzKG5ld0RhdGFTZXQpO1xufTtcblxuLyoqXG4gKiBTZXQgYm90aCBpdGVtcyBhbmQgZ3JvdXBzIGluIG9uZSBnb1xuICogQHBhcmFtIHt7aXRlbXM6IEFycmF5IHwgdmlzLkRhdGFTZXQsIGdyb3VwczogQXJyYXkgfCB2aXMuRGF0YVNldH19IGRhdGFcbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICBpZiAoZGF0YSAmJiBkYXRhLmdyb3Vwcykge1xuICAgIHRoaXMuc2V0R3JvdXBzKGRhdGEuZ3JvdXBzKTtcbiAgfVxuXG4gIGlmIChkYXRhICYmIGRhdGEuaXRlbXMpIHtcbiAgICB0aGlzLnNldEl0ZW1zKGRhdGEuaXRlbXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBzZWxlY3RlZCBpdGVtcyBieSB0aGVpciBpZC4gUmVwbGFjZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gKiBVbmtub3duIGlkJ3MgYXJlIHNpbGVudGx5IGlnbm9yZWQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdIHwgc3RyaW5nfSBbaWRzXSAgQW4gYXJyYXkgd2l0aCB6ZXJvIG9yIG1vcmUgaWQncyBvZiB0aGUgaXRlbXMgdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC4gSWYgaWRzIGlzIGFuIGVtcHR5IGFycmF5LCBhbGwgaXRlbXMgd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGZvY3VzOiBib29sZWFuYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlLCBmb2N1cyB3aWxsIGJlIHNldCB0byB0aGUgc2VsZWN0ZWQgaXRlbShzKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSBhcHBsaWNhYmxlIHdoZW4gb3B0aW9uIGZvY3VzIGlzIHRydWUuXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbihpZHMsIG9wdGlvbnMpIHtcbiAgdGhpcy5pdGVtU2V0ICYmIHRoaXMuaXRlbVNldC5zZXRTZWxlY3Rpb24oaWRzKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZvY3VzKSB7XG4gICAgdGhpcy5mb2N1cyhpZHMsIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2VsZWN0ZWQgaXRlbXMgYnkgdGhlaXIgaWRcbiAqIEByZXR1cm4ge0FycmF5fSBpZHMgIFRoZSBpZHMgb2YgdGhlIHNlbGVjdGVkIGl0ZW1zXG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXRlbVNldCAmJiB0aGlzLml0ZW1TZXQuZ2V0U2VsZWN0aW9uKCkgfHwgW107XG59O1xuXG4vKipcbiAqIEFkanVzdCB0aGUgdmlzaWJsZSB3aW5kb3cgc3VjaCB0aGF0IHRoZSBzZWxlY3RlZCBpdGVtIChvciBtdWx0aXBsZSBpdGVtcylcbiAqIGFyZSBjZW50ZXJlZCBvbiBzY3JlZW4uXG4gKiBAcGFyYW0ge1N0cmluZyB8IFN0cmluZ1tdfSBpZCAgICAgQW4gaXRlbSBpZCBvciBhcnJheSB3aXRoIGl0ZW0gaWRzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGFuaW1hdGlvbjogYm9vbGVhbiB8IHtkdXJhdGlvbjogbnVtYmVyLCBlYXNpbmdGdW5jdGlvbjogc3RyaW5nfWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIHRoZSByYW5nZSBpcyBhbmltYXRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbW9vdGhseSB0byB0aGUgbmV3IHdpbmRvdy4gQW4gb2JqZWN0IGNhbiBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCB0byBzcGVjaWZ5IGR1cmF0aW9uIGFuZCBlYXNpbmcgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgZHVyYXRpb24gaXMgNTAwIG1zLCBhbmQgZGVmYXVsdCBlYXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXMgJ2Vhc2VJbk91dFF1YWQnLlxuICovXG5UaW1lbGluZS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbihpZCwgb3B0aW9ucykge1xuICBpZiAoIXRoaXMuaXRlbXNEYXRhIHx8IGlkID09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gIHZhciBpZHMgPSBBcnJheS5pc0FycmF5KGlkKSA/IGlkIDogW2lkXTtcblxuICAvLyBnZXQgdGhlIHNwZWNpZmllZCBpdGVtKHMpXG4gIHZhciBpdGVtc0RhdGEgPSB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkuZ2V0KGlkcywge1xuICAgIHR5cGU6IHtcbiAgICAgIHN0YXJ0OiAnRGF0ZScsXG4gICAgICBlbmQ6ICdEYXRlJ1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gY2FsY3VsYXRlIG1pbmltdW0gc3RhcnQgYW5kIG1heGltdW0gZW5kIG9mIHNwZWNpZmllZCBpdGVtc1xuICB2YXIgc3RhcnQgPSBudWxsO1xuICB2YXIgZW5kID0gbnVsbDtcbiAgaXRlbXNEYXRhLmZvckVhY2goZnVuY3Rpb24gKGl0ZW1EYXRhKSB7XG4gICAgdmFyIHMgPSBpdGVtRGF0YS5zdGFydC52YWx1ZU9mKCk7XG4gICAgdmFyIGUgPSAnZW5kJyBpbiBpdGVtRGF0YSA/IGl0ZW1EYXRhLmVuZC52YWx1ZU9mKCkgOiBpdGVtRGF0YS5zdGFydC52YWx1ZU9mKCk7XG5cbiAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgcyA8IHN0YXJ0KSB7XG4gICAgICBzdGFydCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKGVuZCA9PT0gbnVsbCB8fCBlID4gZW5kKSB7XG4gICAgICBlbmQgPSBlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHN0YXJ0ICE9PSBudWxsICYmIGVuZCAhPT0gbnVsbCkge1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbmV3IG1pZGRsZSBhbmQgaW50ZXJ2YWwgZm9yIHRoZSB3aW5kb3dcbiAgICB2YXIgbWlkZGxlID0gKHN0YXJ0ICsgZW5kKSAvIDI7XG4gICAgdmFyIGludGVydmFsID0gTWF0aC5tYXgoKHRoaXMucmFuZ2UuZW5kIC0gdGhpcy5yYW5nZS5zdGFydCksIChlbmQgLSBzdGFydCkgKiAxLjEpO1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5hbmltYXRpb24gOiB0cnVlO1xuICAgIHRoaXMucmFuZ2Uuc2V0UmFuZ2UobWlkZGxlIC0gaW50ZXJ2YWwgLyAyLCBtaWRkbGUgKyBpbnRlcnZhbCAvIDIsIGFuaW1hdGlvbik7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IFRpbWVsaW5lIHdpbmRvdyBzdWNoIHRoYXQgaXQgZml0cyBhbGwgaXRlbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gIEF2YWlsYWJsZSBvcHRpb25zOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBhbmltYXRpb246IGJvb2xlYW4gfCB7ZHVyYXRpb246IG51bWJlciwgZWFzaW5nRnVuY3Rpb246IHN0cmluZ31gXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgcmFuZ2UgaXMgYW5pbWF0ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RobHkgdG8gdGhlIG5ldyB3aW5kb3cuIEFuIG9iamVjdCBjYW4gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQgdG8gc3BlY2lmeSBkdXJhdGlvbiBhbmQgZWFzaW5nIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGR1cmF0aW9uIGlzIDUwMCBtcywgYW5kIGRlZmF1bHQgZWFzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzICdlYXNlSW5PdXRRdWFkJy5cbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBhbmltYXRpb24gPSAob3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuYW5pbWF0aW9uIDogdHJ1ZTtcbiAgdmFyIHJhbmdlID0gdGhpcy5nZXRJdGVtUmFuZ2UoKTtcbiAgdGhpcy5yYW5nZS5zZXRSYW5nZShyYW5nZS5taW4sIHJhbmdlLm1heCwgYW5pbWF0aW9uKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSByYW5nZSBvZiB0aGUgaXRlbXMsIHRha2luZyBpbnRvIGFjY291bnQgdGhlaXIgYWN0dWFsIHdpZHRoXG4gKiBhbmQgYSBtYXJnaW4gb2YgMTAgcGl4ZWxzIG9uIGJvdGggc2lkZXMuXG4gKiBAcmV0dXJuIHt7bWluOiBEYXRlIHwgbnVsbCwgbWF4OiBEYXRlIHwgbnVsbH19XG4gKi9cblRpbWVsaW5lLnByb3RvdHlwZS5nZXRJdGVtUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGdldCBhIHJvdWdoIGFwcHJveGltYXRpb24gZm9yIHRoZSByYW5nZSBiYXNlZCBvbiB0aGUgaXRlbXMgc3RhcnQgYW5kIGVuZCBkYXRlc1xuICB2YXIgcmFuZ2UgPSB0aGlzLmdldERhdGFSYW5nZSgpO1xuICB2YXIgbWluID0gcmFuZ2UubWluO1xuICB2YXIgbWF4ID0gcmFuZ2UubWF4O1xuICB2YXIgbWluSXRlbSA9IG51bGw7XG4gIHZhciBtYXhJdGVtID0gbnVsbDtcblxuICBpZiAobWluICE9IG51bGwgJiYgbWF4ICE9IG51bGwpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSAobWF4IC0gbWluKTsgLy8gbXNcbiAgICBpZiAoaW50ZXJ2YWwgPD0gMCkge1xuICAgICAgaW50ZXJ2YWwgPSAxMDtcbiAgICB9XG4gICAgdmFyIGZhY3RvciA9IGludGVydmFsIC8gdGhpcy5wcm9wcy5jZW50ZXIud2lkdGg7XG5cbiAgICBmdW5jdGlvbiBnZXRTdGFydChpdGVtKSB7XG4gICAgICByZXR1cm4gdXRpbC5jb252ZXJ0KGl0ZW0uZGF0YS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFbmQoaXRlbSkge1xuICAgICAgdmFyIGVuZCA9IGl0ZW0uZGF0YS5lbmQgIT0gdW5kZWZpbmVkID8gaXRlbS5kYXRhLmVuZCA6IGl0ZW0uZGF0YS5zdGFydDtcbiAgICAgIHJldHVybiB1dGlsLmNvbnZlcnQoZW5kLCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGRhdGUgb2YgdGhlIGxlZnQgc2lkZSBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgaXRlbXMgZ2l2ZW5cbiAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtU2V0Lml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaXRlbS5zaG93KCk7XG5cbiAgICAgIHZhciBzdGFydCA9IGdldFN0YXJ0KGl0ZW0pO1xuICAgICAgdmFyIGVuZCA9IGdldEVuZChpdGVtKTtcblxuICAgICAgdmFyIGxlZnQgID0gbmV3IERhdGUoc3RhcnQgLSAoaXRlbS5nZXRXaWR0aExlZnQoKSArIDEwKSAqIGZhY3Rvcik7XG4gICAgICB2YXIgcmlnaHQgPSBuZXcgRGF0ZShlbmQgICArIChpdGVtLmdldFdpZHRoUmlnaHQoKSArIDEwKSAqIGZhY3Rvcik7XG5cbiAgICAgIGlmIChsZWZ0IDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGxlZnQ7XG4gICAgICAgIG1pbkl0ZW0gPSBpdGVtO1xuICAgICAgfVxuICAgICAgaWYgKHJpZ2h0ID4gbWF4KSB7XG4gICAgICAgIG1heCA9IHJpZ2h0O1xuICAgICAgICBtYXhJdGVtID0gaXRlbTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgaWYgKG1pbkl0ZW0gJiYgbWF4SXRlbSkge1xuICAgICAgdmFyIGxocyA9IG1pbkl0ZW0uZ2V0V2lkdGhMZWZ0KCkgKyAxMDtcbiAgICAgIHZhciByaHMgPSBtYXhJdGVtLmdldFdpZHRoUmlnaHQoKSArIDEwO1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5wcm9wcy5jZW50ZXIud2lkdGggLSBsaHMgLSByaHM7ICAvLyBweFxuXG4gICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgIG1pbiA9IGdldFN0YXJ0KG1pbkl0ZW0pIC0gbGhzICogaW50ZXJ2YWwgLyBkZWx0YTsgLy8gbXNcbiAgICAgICAgbWF4ID0gZ2V0RW5kKG1heEl0ZW0pICAgKyByaHMgKiBpbnRlcnZhbCAvIGRlbHRhOyAvLyBtc1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsLFxuICAgIG1heDogbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbFxuICB9XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgZGF0YSByYW5nZSBvZiB0aGUgaXRlbXMgc3RhcnQgYW5kIGVuZCBkYXRlc1xuICogQHJldHVybnMge3ttaW46IERhdGUgfCBudWxsLCBtYXg6IERhdGUgfCBudWxsfX1cbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLmdldERhdGFSYW5nZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWluID0gbnVsbDtcbiAgdmFyIG1heCA9IG51bGw7XG5cbiAgdmFyIGRhdGFzZXQgPSB0aGlzLml0ZW1zRGF0YSAmJiB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCk7XG4gIGlmIChkYXRhc2V0KSB7XG4gICAgZGF0YXNldC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgc3RhcnQgPSB1dGlsLmNvbnZlcnQoaXRlbS5zdGFydCwgJ0RhdGUnKS52YWx1ZU9mKCk7XG4gICAgICB2YXIgZW5kICAgPSB1dGlsLmNvbnZlcnQoaXRlbS5lbmQgIT0gdW5kZWZpbmVkID8gaXRlbS5lbmQgOiBpdGVtLnN0YXJ0LCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgc3RhcnQgPCBtaW4pIHtcbiAgICAgICAgbWluID0gc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAobWF4ID09PSBudWxsIHx8IGVuZCA+IG1heCkge1xuICAgICAgICBtYXggPSBzdGFydDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsLFxuICAgIG1heDogbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbFxuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIFRpbWVsaW5lIHJlbGF0ZWQgaW5mb3JtYXRpb24gZnJvbSBhbiBldmVudFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggcmVsYXRlZCBpbmZvcm1hdGlvbiwgbGlrZSBvbiB3aGljaCBhcmVhXG4gKiAgICAgICAgICAgICAgICAgIFRoZSBldmVudCBoYXBwZW5lZCwgd2hldGhlciBjbGlja2VkIG9uIGFuIGl0ZW0sIGV0Yy5cbiAqL1xuVGltZWxpbmUucHJvdG90eXBlLmdldEV2ZW50UHJvcGVydGllcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgY2xpZW50WCA9IGV2ZW50LmNlbnRlciA/IGV2ZW50LmNlbnRlci54IDogZXZlbnQuY2xpZW50WDtcbiAgdmFyIGNsaWVudFkgPSBldmVudC5jZW50ZXIgPyBldmVudC5jZW50ZXIueSA6IGV2ZW50LmNsaWVudFk7XG4gIHZhciB4ID0gY2xpZW50WCAtIHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KHRoaXMuZG9tLmNlbnRlckNvbnRhaW5lcik7XG4gIHZhciB5ID0gY2xpZW50WSAtIHV0aWwuZ2V0QWJzb2x1dGVUb3AodGhpcy5kb20uY2VudGVyQ29udGFpbmVyKTtcblxuICB2YXIgaXRlbSAgPSB0aGlzLml0ZW1TZXQuaXRlbUZyb21UYXJnZXQoZXZlbnQpO1xuICB2YXIgZ3JvdXAgPSB0aGlzLml0ZW1TZXQuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcbiAgdmFyIGN1c3RvbVRpbWUgPSBDdXN0b21UaW1lLmN1c3RvbVRpbWVGcm9tVGFyZ2V0KGV2ZW50KTtcblxuICB2YXIgc25hcCA9IHRoaXMuaXRlbVNldC5vcHRpb25zLnNuYXAgfHwgbnVsbDtcbiAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnV0aWwuZ2V0U2NhbGUoKTtcbiAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG4gIHZhciB0aW1lID0gdGhpcy5fdG9UaW1lKHgpO1xuICB2YXIgc25hcHBlZFRpbWUgPSBzbmFwID8gc25hcCh0aW1lLCBzY2FsZSwgc3RlcCkgOiB0aW1lO1xuXG4gIHZhciBlbGVtZW50ID0gdXRpbC5nZXRUYXJnZXQoZXZlbnQpO1xuICB2YXIgd2hhdCA9IG51bGw7XG4gIGlmIChpdGVtICE9IG51bGwpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt3aGF0ID0gJ2l0ZW0nO31cbiAgZWxzZSBpZiAoY3VzdG9tVGltZSAhPSBudWxsKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3doYXQgPSAnY3VzdG9tLXRpbWUnO31cbiAgZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy50aW1lQXhpcy5kb20uZm9yZWdyb3VuZCkpICAgICAge3doYXQgPSAnYXhpcyc7fVxuICBlbHNlIGlmICh0aGlzLnRpbWVBeGlzMiAmJiB1dGlsLmhhc1BhcmVudChlbGVtZW50LCB0aGlzLnRpbWVBeGlzMi5kb20uZm9yZWdyb3VuZCkpIHt3aGF0ID0gJ2F4aXMnO31cbiAgZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5pdGVtU2V0LmRvbS5sYWJlbFNldCkpICAgICAgICAge3doYXQgPSAnZ3JvdXAtbGFiZWwnO31cbiAgZWxzZSBpZiAodXRpbC5oYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5jdXJyZW50VGltZS5iYXIpKSAgICAgICAgICAgICAge3doYXQgPSAnY3VycmVudC10aW1lJzt9XG4gIGVsc2UgaWYgKHV0aWwuaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMuZG9tLmNlbnRlcikpICAgICAgICAgICAgICAgICAgIHt3aGF0ID0gJ2JhY2tncm91bmQnO31cblxuICByZXR1cm4ge1xuICAgIGV2ZW50OiBldmVudCxcbiAgICBpdGVtOiBpdGVtID8gaXRlbS5pZCA6IG51bGwsXG4gICAgZ3JvdXA6IGdyb3VwID8gZ3JvdXAuZ3JvdXBJZCA6IG51bGwsXG4gICAgd2hhdDogd2hhdCxcbiAgICBwYWdlWDogZXZlbnQuc3JjRXZlbnQgPyBldmVudC5zcmNFdmVudC5wYWdlWCA6IGV2ZW50LnBhZ2VYLFxuICAgIHBhZ2VZOiBldmVudC5zcmNFdmVudCA/IGV2ZW50LnNyY0V2ZW50LnBhZ2VZIDogZXZlbnQucGFnZVksXG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHRpbWU6IHRpbWUsXG4gICAgc25hcHBlZFRpbWU6IHNuYXBwZWRUaW1lXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZWxpbmU7XG4iXX0=
},{"../DataSet":15,"../DataView":16,"../module/hammer":19,"../module/moment":20,"../shared/Configurator":24,"../shared/Validator":25,"../util":46,"./Core":26,"./Range":28,"./component/CurrentTime":34,"./component/CustomTime":35,"./component/ItemSet":37,"./component/TimeAxis":38,"./optionsTimeline":45,"emitter-component":10}],32:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Group = require('./Group');

/**
 * @constructor BackgroundGroup
 * @param {Number | String} groupId
 * @param {Object} data
 * @param {ItemSet} itemSet
 */
function BackgroundGroup(groupId, data, itemSet) {
  Group.call(this, groupId, data, itemSet);

  this.width = 0;
  this.height = 0;
  this.top = 0;
  this.left = 0;
}

BackgroundGroup.prototype = Object.create(Group.prototype);

/**
 * Repaint this group
 * @param {{start: number, end: number}} range
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @param {boolean} [restack=false]  Force restacking of all items
 * @return {boolean} Returns true if the group is resized
 */
BackgroundGroup.prototype.redraw = function (range, margin, restack) {
  var resized = false;

  this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

  // calculate actual size
  this.width = this.dom.background.offsetWidth;

  // apply new height (just always zero for BackgroundGroup
  this.dom.background.style.height = '0';

  // update vertical position of items after they are re-stacked and the height of the group is calculated
  for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
    var item = this.visibleItems[i];
    item.repositionY(margin);
  }

  return resized;
};

/**
 * Show this group: attach to the DOM
 */
BackgroundGroup.prototype.show = function () {
  if (!this.dom.background.parentNode) {
    this.itemSet.dom.background.appendChild(this.dom.background);
  }
};

module.exports = BackgroundGroup;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQmFja2dyb3VuZEdyb3VwLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2pDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQzs7Ozs7Ozs7QUFRL0IsU0FBUyxlQUFlLENBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDaEQsT0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFekMsTUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDZixNQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUNoQixNQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUNiLE1BQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0NBQ2Y7O0FBRUQsZUFBZSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQzs7Ozs7Ozs7O0FBUzNELGVBQWUsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFVBQVMsS0FBSyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUU7QUFDbEUsTUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDOztBQUVwQixNQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDLENBQUM7OztBQUcxRixNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQzs7O0FBRzdDLE1BQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUksR0FBRyxDQUFDOzs7QUFHeEMsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDMUQsUUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoQyxRQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0dBQzFCOztBQUVELFNBQU8sT0FBTyxDQUFDO0NBQ2hCLENBQUM7Ozs7O0FBS0YsZUFBZSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsWUFBVztBQUMxQyxNQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFO0FBQ25DLFFBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztHQUM5RDtDQUNGLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxlQUFlLENBQUMiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9CYWNrZ3JvdW5kR3JvdXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBHcm91cCA9IHJlcXVpcmUoJy4vR3JvdXAnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgQmFja2dyb3VuZEdyb3VwXG4gKiBAcGFyYW0ge051bWJlciB8IFN0cmluZ30gZ3JvdXBJZFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7SXRlbVNldH0gaXRlbVNldFxuICovXG5mdW5jdGlvbiBCYWNrZ3JvdW5kR3JvdXAgKGdyb3VwSWQsIGRhdGEsIGl0ZW1TZXQpIHtcbiAgR3JvdXAuY2FsbCh0aGlzLCBncm91cElkLCBkYXRhLCBpdGVtU2V0KTtcblxuICB0aGlzLndpZHRoID0gMDtcbiAgdGhpcy5oZWlnaHQgPSAwO1xuICB0aGlzLnRvcCA9IDA7XG4gIHRoaXMubGVmdCA9IDA7XG59XG5cbkJhY2tncm91bmRHcm91cC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdyb3VwLnByb3RvdHlwZSk7XG5cbi8qKlxuICogUmVwYWludCB0aGlzIGdyb3VwXG4gKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlXG4gKiBAcGFyYW0ge3tpdGVtOiB7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfSwgYXhpczogbnVtYmVyfX0gbWFyZ2luXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXN0YWNrPWZhbHNlXSAgRm9yY2UgcmVzdGFja2luZyBvZiBhbGwgaXRlbXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ3JvdXAgaXMgcmVzaXplZFxuICovXG5CYWNrZ3JvdW5kR3JvdXAucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKHJhbmdlLCBtYXJnaW4sIHJlc3RhY2spIHtcbiAgdmFyIHJlc2l6ZWQgPSBmYWxzZTtcblxuICB0aGlzLnZpc2libGVJdGVtcyA9IHRoaXMuX3VwZGF0ZVZpc2libGVJdGVtcyh0aGlzLm9yZGVyZWRJdGVtcywgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcblxuICAvLyBjYWxjdWxhdGUgYWN0dWFsIHNpemVcbiAgdGhpcy53aWR0aCA9IHRoaXMuZG9tLmJhY2tncm91bmQub2Zmc2V0V2lkdGg7XG5cbiAgLy8gYXBwbHkgbmV3IGhlaWdodCAoanVzdCBhbHdheXMgemVybyBmb3IgQmFja2dyb3VuZEdyb3VwXG4gIHRoaXMuZG9tLmJhY2tncm91bmQuc3R5bGUuaGVpZ2h0ICA9ICcwJztcblxuICAvLyB1cGRhdGUgdmVydGljYWwgcG9zaXRpb24gb2YgaXRlbXMgYWZ0ZXIgdGhleSBhcmUgcmUtc3RhY2tlZCBhbmQgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdXAgaXMgY2FsY3VsYXRlZFxuICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLnZpc2libGVJdGVtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLnZpc2libGVJdGVtc1tpXTtcbiAgICBpdGVtLnJlcG9zaXRpb25ZKG1hcmdpbik7XG4gIH1cblxuICByZXR1cm4gcmVzaXplZDtcbn07XG5cbi8qKlxuICogU2hvdyB0aGlzIGdyb3VwOiBhdHRhY2ggdG8gdGhlIERPTVxuICovXG5CYWNrZ3JvdW5kR3JvdXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRvbS5iYWNrZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLml0ZW1TZXQuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20uYmFja2dyb3VuZCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2dyb3VuZEdyb3VwO1xuIl19
},{"../../util":46,"./Group":36}],33:[function(require,module,exports){
/**
 * Prototype for visual components
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} [body]
 * @param {Object} [options]
 */
"use strict";

function Component(body, options) {
  this.options = null;
  this.props = null;
}

/**
 * Set options for the component. The new options will be merged into the
 * current options.
 * @param {Object} options
 */
Component.prototype.setOptions = function (options) {
  if (options) {
    util.extend(this.options, options);
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
Component.prototype.redraw = function () {
  // should be implemented by the component
  return false;
};

/**
 * Destroy the component. Cleanup DOM and event listeners
 */
Component.prototype.destroy = function () {
  // should be implemented by the component
};

/**
 * Test whether the component is resized since the last time _isResized() was
 * called.
 * @return {Boolean} Returns true if the component is resized
 * @protected
 */
Component.prototype._isResized = function () {
  var resized = this.props._previousWidth !== this.props.width || this.props._previousHeight !== this.props.height;

  this.props._previousWidth = this.props.width;
  this.props._previousHeight = this.props.height;

  return resized;
};

module.exports = Component;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQ29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFLQSxTQUFTLFNBQVMsQ0FBRSxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ2pDLE1BQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLE1BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0NBQ25COzs7Ozs7O0FBT0QsU0FBUyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsVUFBUyxPQUFPLEVBQUU7QUFDakQsTUFBSSxPQUFPLEVBQUU7QUFDWCxRQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7R0FDcEM7Q0FDRixDQUFDOzs7Ozs7QUFNRixTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxZQUFXOztBQUV0QyxTQUFPLEtBQUssQ0FBQztDQUNkLENBQUM7Ozs7O0FBS0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsWUFBVzs7Q0FFeEMsQ0FBQzs7Ozs7Ozs7QUFRRixTQUFTLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBRyxZQUFXO0FBQzFDLE1BQUksT0FBTyxHQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxJQUN6RCxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQUFBQyxDQUFDOztBQUV0RCxNQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztBQUM3QyxNQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQzs7QUFFL0MsU0FBTyxPQUFPLENBQUM7Q0FDaEIsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyIsImZpbGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0NvbXBvbmVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHJvdG90eXBlIGZvciB2aXN1YWwgY29tcG9uZW50c1xuICogQHBhcmFtIHt7ZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3QsIGVtaXR0ZXI6IEVtaXR0ZXIsIHJhbmdlOiBSYW5nZX19IFtib2R5XVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICovXG5mdW5jdGlvbiBDb21wb25lbnQgKGJvZHksIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgdGhpcy5wcm9wcyA9IG51bGw7XG59XG5cbi8qKlxuICogU2V0IG9wdGlvbnMgZm9yIHRoZSBjb21wb25lbnQuIFRoZSBuZXcgb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoZVxuICogY3VycmVudCBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgY29tcG9uZW50XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgY29tcG9uZW50LiBDbGVhbnVwIERPTSBhbmQgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIGNvbXBvbmVudFxufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgX2lzUmVzaXplZCgpIHdhc1xuICogY2FsbGVkLlxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLl9pc1Jlc2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc2l6ZWQgPSAodGhpcy5wcm9wcy5fcHJldmlvdXNXaWR0aCAhPT0gdGhpcy5wcm9wcy53aWR0aCB8fFxuICAgICAgdGhpcy5wcm9wcy5fcHJldmlvdXNIZWlnaHQgIT09IHRoaXMucHJvcHMuaGVpZ2h0KTtcblxuICB0aGlzLnByb3BzLl9wcmV2aW91c1dpZHRoID0gdGhpcy5wcm9wcy53aWR0aDtcbiAgdGhpcy5wcm9wcy5fcHJldmlvdXNIZWlnaHQgPSB0aGlzLnByb3BzLmhlaWdodDtcblxuICByZXR1cm4gcmVzaXplZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50O1xuIl19
},{}],34:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Component = require('./Component');
var moment = require('../../module/moment');
var locales = require('../locales');

/**
 * A current time bar
 * @param {{range: Range, dom: Object, domProps: Object}} body
 * @param {Object} [options]        Available parameters:
 *                                  {Boolean} [showCurrentTime]
 * @constructor CurrentTime
 * @extends Component
 */
function CurrentTime(body, options) {
  this.body = body;

  // default options
  this.defaultOptions = {
    showCurrentTime: true,

    moment: moment,
    locales: locales,
    locale: 'en'
  };
  this.options = util.extend({}, this.defaultOptions);
  this.offset = 0;

  this._create();

  this.setOptions(options);
}

CurrentTime.prototype = new Component();

/**
 * Create the HTML DOM for the current time bar
 * @private
 */
CurrentTime.prototype._create = function () {
  var bar = document.createElement('div');
  bar.className = 'vis-current-time';
  bar.style.position = 'absolute';
  bar.style.top = '0px';
  bar.style.height = '100%';

  this.bar = bar;
};

/**
 * Destroy the CurrentTime bar
 */
CurrentTime.prototype.destroy = function () {
  this.options.showCurrentTime = false;
  this.redraw(); // will remove the bar from the DOM and stop refreshing

  this.body = null;
};

/**
 * Set options for the component. Options will be merged in current options.
 * @param {Object} options  Available parameters:
 *                          {boolean} [showCurrentTime]
 */
CurrentTime.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['showCurrentTime', 'moment', 'locale', 'locales'], this.options, options);
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
CurrentTime.prototype.redraw = function () {
  if (this.options.showCurrentTime) {
    var parent = this.body.dom.backgroundVertical;
    if (this.bar.parentNode != parent) {
      // attach to the dom
      if (this.bar.parentNode) {
        this.bar.parentNode.removeChild(this.bar);
      }
      parent.appendChild(this.bar);

      this.start();
    }

    var now = this.options.moment(new Date().valueOf() + this.offset);
    var x = this.body.util.toScreen(now);

    var locale = this.options.locales[this.options.locale];
    if (!locale) {
      if (!this.warned) {
        console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline.html#Localization');
        this.warned = true;
      }
      locale = this.options.locales['en']; // fall back on english when not available
    }
    var title = locale.current + ' ' + locale.time + ': ' + now.format('dddd, MMMM Do YYYY, H:mm:ss');
    title = title.charAt(0).toUpperCase() + title.substring(1);

    this.bar.style.left = x + 'px';
    this.bar.title = title;
  } else {
    // remove the line from the DOM
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
    this.stop();
  }

  return false;
};

/**
 * Start auto refreshing the current time bar
 */
CurrentTime.prototype.start = function () {
  var me = this;

  function update() {
    me.stop();

    // determine interval to refresh
    var scale = me.body.range.conversion(me.body.domProps.center.width).scale;
    var interval = 1 / scale / 10;
    if (interval < 30) interval = 30;
    if (interval > 1000) interval = 1000;

    me.redraw();

    // start a renderTimer to adjust for the new time
    me.currentTimeTimer = setTimeout(update, interval);
  }

  update();
};

/**
 * Stop auto refreshing the current time bar
 */
CurrentTime.prototype.stop = function () {
  if (this.currentTimeTimer !== undefined) {
    clearTimeout(this.currentTimeTimer);
    delete this.currentTimeTimer;
  }
};

/**
 * Set a current time. This can be used for example to ensure that a client's
 * time is synchronized with a shared server time.
 * @param {Date | String | Number} time     A Date, unix timestamp, or
 *                                          ISO date string.
 */
CurrentTime.prototype.setCurrentTime = function (time) {
  var t = util.convert(time, 'Date').valueOf();
  var now = new Date().valueOf();
  this.offset = t - now;
  this.redraw();
};

/**
 * Get the current time.
 * @return {Date} Returns the current time.
 */
CurrentTime.prototype.getCurrentTime = function () {
  return new Date(new Date().valueOf() + this.offset);
};

module.exports = CurrentTime;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQ3VycmVudFRpbWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDakMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3ZDLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQzVDLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQzs7Ozs7Ozs7OztBQVVwQyxTQUFTLFdBQVcsQ0FBRSxJQUFJLEVBQUUsT0FBTyxFQUFFO0FBQ25DLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOzs7QUFHakIsTUFBSSxDQUFDLGNBQWMsR0FBRztBQUNwQixtQkFBZSxFQUFFLElBQUk7O0FBRXJCLFVBQU0sRUFBRSxNQUFNO0FBQ2QsV0FBTyxFQUFFLE9BQU87QUFDaEIsVUFBTSxFQUFFLElBQUk7R0FDYixDQUFDO0FBQ0YsTUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDcEQsTUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7O0FBRWhCLE1BQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQzs7QUFFZixNQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQzFCOztBQUVELFdBQVcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxTQUFTLEVBQUUsQ0FBQzs7Ozs7O0FBTXhDLFdBQVcsQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFlBQVc7QUFDekMsTUFBSSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN4QyxLQUFHLENBQUMsU0FBUyxHQUFHLGtCQUFrQixDQUFDO0FBQ25D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SSxDQUFDLGdCQUFnQixDQUFDO0dBQzlCO0NBQ0YsQ0FBQzs7Ozs7Ozs7QUFRRixXQUFXLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxVQUFTLElBQUksRUFBRTtBQUNwRCxNQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUM3QyxNQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQy9CLE1BQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUN0QixNQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Q0FDZixDQUFDOzs7Ozs7QUFNRixXQUFXLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxZQUFXO0FBQ2hELFNBQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDckQsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFdBQVcsQ0FBQyIsImZpbGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0N1cnJlbnRUaW1lLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGUvbW9tZW50Jyk7XG52YXIgbG9jYWxlcyA9IHJlcXVpcmUoJy4uL2xvY2FsZXMnKTtcblxuLyoqXG4gKiBBIGN1cnJlbnQgdGltZSBiYXJcbiAqIEBwYXJhbSB7e3JhbmdlOiBSYW5nZSwgZG9tOiBPYmplY3QsIGRvbVByb3BzOiBPYmplY3R9fSBib2R5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBbc2hvd0N1cnJlbnRUaW1lXVxuICogQGNvbnN0cnVjdG9yIEN1cnJlbnRUaW1lXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gQ3VycmVudFRpbWUgKGJvZHksIG9wdGlvbnMpIHtcbiAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBzaG93Q3VycmVudFRpbWU6IHRydWUsXG5cbiAgICBtb21lbnQ6IG1vbWVudCxcbiAgICBsb2NhbGVzOiBsb2NhbGVzLFxuICAgIGxvY2FsZTogJ2VuJ1xuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gIHRoaXMub2Zmc2V0ID0gMDtcblxuICB0aGlzLl9jcmVhdGUoKTtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cbkN1cnJlbnRUaW1lLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIEhUTUwgRE9NIGZvciB0aGUgY3VycmVudCB0aW1lIGJhclxuICogQHByaXZhdGVcbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBiYXIuY2xhc3NOYW1lID0gJ3Zpcy1jdXJyZW50LXRpbWUnO1xuICBiYXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBiYXIuc3R5bGUudG9wID0gJzBweCc7XG4gIGJhci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cbiAgdGhpcy5iYXIgPSBiYXI7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIEN1cnJlbnRUaW1lIGJhclxuICovXG5DdXJyZW50VGltZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5vcHRpb25zLnNob3dDdXJyZW50VGltZSA9IGZhbHNlO1xuICB0aGlzLnJlZHJhdygpOyAvLyB3aWxsIHJlbW92ZSB0aGUgYmFyIGZyb20gdGhlIERPTSBhbmQgc3RvcCByZWZyZXNoaW5nXG5cbiAgdGhpcy5ib2R5ID0gbnVsbDtcbn07XG5cbi8qKlxuICogU2V0IG9wdGlvbnMgZm9yIHRoZSBjb21wb25lbnQuIE9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgaW4gY3VycmVudCBvcHRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHtib29sZWFufSBbc2hvd0N1cnJlbnRUaW1lXVxuICovXG5DdXJyZW50VGltZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBjb3B5IGFsbCBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnc2hvd0N1cnJlbnRUaW1lJywgJ21vbWVudCcsICdsb2NhbGUnLCAnbG9jYWxlcyddLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICovXG5DdXJyZW50VGltZS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuc2hvd0N1cnJlbnRUaW1lKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuYm9keS5kb20uYmFja2dyb3VuZFZlcnRpY2FsO1xuICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlICE9IHBhcmVudCkge1xuICAgICAgLy8gYXR0YWNoIHRvIHRoZSBkb21cbiAgICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuYmFyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5iYXIpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuYmFyKTtcblxuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSB0aGlzLm9wdGlvbnMubW9tZW50KG5ldyBEYXRlKCkudmFsdWVPZigpICsgdGhpcy5vZmZzZXQpO1xuICAgIHZhciB4ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4obm93KTtcblxuICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICBpZiAoIWxvY2FsZSkge1xuICAgICAgaWYgKCF0aGlzLndhcm5lZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogb3B0aW9ucy5sb2NhbGVzW1xcJycgKyB0aGlzLm9wdGlvbnMubG9jYWxlICsgJ1xcJ10gbm90IGZvdW5kLiBTZWUgaHR0cDovL3Zpc2pzLm9yZy9kb2NzL3RpbWVsaW5lLmh0bWwjTG9jYWxpemF0aW9uJyk7XG4gICAgICAgIHRoaXMud2FybmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzWydlbiddOyAvLyBmYWxsIGJhY2sgb24gZW5nbGlzaCB3aGVuIG5vdCBhdmFpbGFibGVcbiAgICB9XG4gICAgdmFyIHRpdGxlID0gbG9jYWxlLmN1cnJlbnQgKyAnICcgKyBsb2NhbGUudGltZSArICc6ICcgKyBub3cuZm9ybWF0KCdkZGRkLCBNTU1NIERvIFlZWVksIEg6bW06c3MnKTtcbiAgICB0aXRsZSA9IHRpdGxlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGl0bGUuc3Vic3RyaW5nKDEpO1xuXG4gICAgdGhpcy5iYXIuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICAgIHRoaXMuYmFyLnRpdGxlID0gdGl0bGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBsaW5lIGZyb20gdGhlIERPTVxuICAgIGlmICh0aGlzLmJhci5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmJhci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuYmFyKTtcbiAgICB9XG4gICAgdGhpcy5zdG9wKCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFN0YXJ0IGF1dG8gcmVmcmVzaGluZyB0aGUgY3VycmVudCB0aW1lIGJhclxuICovXG5DdXJyZW50VGltZS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAgIG1lLnN0b3AoKTtcblxuICAgIC8vIGRldGVybWluZSBpbnRlcnZhbCB0byByZWZyZXNoXG4gICAgdmFyIHNjYWxlID0gbWUuYm9keS5yYW5nZS5jb252ZXJzaW9uKG1lLmJvZHkuZG9tUHJvcHMuY2VudGVyLndpZHRoKS5zY2FsZTtcbiAgICB2YXIgaW50ZXJ2YWwgPSAxIC8gc2NhbGUgLyAxMDtcbiAgICBpZiAoaW50ZXJ2YWwgPCAzMCkgICBpbnRlcnZhbCA9IDMwO1xuICAgIGlmIChpbnRlcnZhbCA+IDEwMDApIGludGVydmFsID0gMTAwMDtcblxuICAgIG1lLnJlZHJhdygpO1xuXG4gICAgLy8gc3RhcnQgYSByZW5kZXJUaW1lciB0byBhZGp1c3QgZm9yIHRoZSBuZXcgdGltZVxuICAgIG1lLmN1cnJlbnRUaW1lVGltZXIgPSBzZXRUaW1lb3V0KHVwZGF0ZSwgaW50ZXJ2YWwpO1xuICB9XG5cbiAgdXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIFN0b3AgYXV0byByZWZyZXNoaW5nIHRoZSBjdXJyZW50IHRpbWUgYmFyXG4gKi9cbkN1cnJlbnRUaW1lLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmN1cnJlbnRUaW1lVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmN1cnJlbnRUaW1lVGltZXIpO1xuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRUaW1lVGltZXI7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGEgY3VycmVudCB0aW1lLiBUaGlzIGNhbiBiZSB1c2VkIGZvciBleGFtcGxlIHRvIGVuc3VyZSB0aGF0IGEgY2xpZW50J3NcbiAqIHRpbWUgaXMgc3luY2hyb25pemVkIHdpdGggYSBzaGFyZWQgc2VydmVyIHRpbWUuXG4gKiBAcGFyYW0ge0RhdGUgfCBTdHJpbmcgfCBOdW1iZXJ9IHRpbWUgICAgIEEgRGF0ZSwgdW5peCB0aW1lc3RhbXAsIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElTTyBkYXRlIHN0cmluZy5cbiAqL1xuQ3VycmVudFRpbWUucHJvdG90eXBlLnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24odGltZSkge1xuICB2YXIgdCA9IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpLnZhbHVlT2YoKTtcbiAgdmFyIG5vdyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICB0aGlzLm9mZnNldCA9IHQgLSBub3c7XG4gIHRoaXMucmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB0aW1lLlxuICogQHJldHVybiB7RGF0ZX0gUmV0dXJucyB0aGUgY3VycmVudCB0aW1lLlxuICovXG5DdXJyZW50VGltZS5wcm90b3R5cGUuZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKG5ldyBEYXRlKCkudmFsdWVPZigpICsgdGhpcy5vZmZzZXQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDdXJyZW50VGltZTtcbiJdfQ==
},{"../../module/moment":20,"../../util":46,"../locales":44,"./Component":33}],35:[function(require,module,exports){
'use strict';

var Hammer = require('../../module/hammer');
var util = require('../../util');
var Component = require('./Component');
var moment = require('../../module/moment');
var locales = require('../locales');

/**
 * A custom time bar
 * @param {{range: Range, dom: Object}} body
 * @param {Object} [options]        Available parameters:
 *                                  {number | string} id
 *                                  {string} locales
 *                                  {string} locale
 * @constructor CustomTime
 * @extends Component
 */

function CustomTime(body, options) {
  this.body = body;

  // default options
  this.defaultOptions = {
    moment: moment,
    locales: locales,
    locale: 'en',
    id: undefined,
    title: undefined
  };
  this.options = util.extend({}, this.defaultOptions);

  if (options && options.time) {
    this.customTime = options.time;
  } else {
    this.customTime = new Date();
  }

  this.eventParams = {}; // stores state parameters while dragging the bar

  this.setOptions(options);

  // create the DOM
  this._create();
}

CustomTime.prototype = new Component();

/**
 * Set options for the component. Options will be merged in current options.
 * @param {Object} options  Available parameters:
 *                                  {number | string} id
 *                                  {string} locales
 *                                  {string} locale
 */
CustomTime.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['moment', 'locale', 'locales', 'id'], this.options, options);
  }
};

/**
 * Create the DOM for the custom time
 * @private
 */
CustomTime.prototype._create = function () {
  var bar = document.createElement('div');
  bar['custom-time'] = this;
  bar.className = 'vis-custom-time ' + (this.options.id || '');
  bar.style.position = 'absolute';
  bar.style.top = '0px';
  bar.style.height = '100%';
  this.bar = bar;

  var drag = document.createElement('div');
  drag.style.position = 'relative';
  drag.style.top = '0px';
  drag.style.left = '-10px';
  drag.style.height = '100%';
  drag.style.width = '20px';
  bar.appendChild(drag);

  // attach event listeners
  this.hammer = new Hammer(drag);
  this.hammer.on('panstart', this._onDragStart.bind(this));
  this.hammer.on('panmove', this._onDrag.bind(this));
  this.hammer.on('panend', this._onDragEnd.bind(this));
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.
};

/**
 * Destroy the CustomTime bar
 */
CustomTime.prototype.destroy = function () {
  this.hide();

  this.hammer.destroy();
  this.hammer = null;

  this.body = null;
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
CustomTime.prototype.redraw = function () {
  var parent = this.body.dom.backgroundVertical;
  if (this.bar.parentNode != parent) {
    // attach to the dom
    if (this.bar.parentNode) {
      this.bar.parentNode.removeChild(this.bar);
    }
    parent.appendChild(this.bar);
  }

  var x = this.body.util.toScreen(this.customTime);

  var locale = this.options.locales[this.options.locale];
  if (!locale) {
    if (!this.warned) {
      console.log('WARNING: options.locales[\'' + this.options.locale + '\'] not found. See http://visjs.org/docs/timeline.html#Localization');
      this.warned = true;
    }
    locale = this.options.locales['en']; // fall back on english when not available
  }

  var title = this.options.title;
  // To hide the title completely use empty string ''.
  if (title === undefined) {
    title = locale.time + ': ' + this.options.moment(this.customTime).format('dddd, MMMM Do YYYY, H:mm:ss');
    title = title.charAt(0).toUpperCase() + title.substring(1);
  }

  this.bar.style.left = x + 'px';
  this.bar.title = title;

  return false;
};

/**
 * Remove the CustomTime from the DOM
 */
CustomTime.prototype.hide = function () {
  // remove the line from the DOM
  if (this.bar.parentNode) {
    this.bar.parentNode.removeChild(this.bar);
  }
};

/**
 * Set custom time.
 * @param {Date | number | string} time
 */
CustomTime.prototype.setCustomTime = function (time) {
  this.customTime = util.convert(time, 'Date');
  this.redraw();
};

/**
 * Retrieve the current custom time.
 * @return {Date} customTime
 */
CustomTime.prototype.getCustomTime = function () {
  return new Date(this.customTime.valueOf());
};

/**
  * Set custom title.
  * @param {Date | number | string} title
  */
CustomTime.prototype.setCustomTitle = function (title) {
  this.options.title = title;
};

/**
 * Start moving horizontally
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDragStart = function (event) {
  this.eventParams.dragging = true;
  this.eventParams.customTime = this.customTime;

  event.stopPropagation();
};

/**
 * Perform moving operating.
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDrag = function (event) {
  if (!this.eventParams.dragging) return;

  var x = this.body.util.toScreen(this.eventParams.customTime) + event.deltaX;
  var time = this.body.util.toTime(x);

  this.setCustomTime(time);

  // fire a timechange event
  this.body.emitter.emit('timechange', {
    id: this.options.id,
    time: new Date(this.customTime.valueOf())
  });

  event.stopPropagation();
};

/**
 * Stop moving operating.
 * @param {Event} event
 * @private
 */
CustomTime.prototype._onDragEnd = function (event) {
  if (!this.eventParams.dragging) return;

  // fire a timechanged event
  this.body.emitter.emit('timechanged', {
    id: this.options.id,
    time: new Date(this.customTime.valueOf())
  });

  event.stopPropagation();
};

/**
 * Find a custom time from an event target:
 * searches for the attribute 'custom-time' in the event target's element tree
 * @param {Event} event
 * @return {CustomTime | null} customTime
 */
CustomTime.customTimeFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('custom-time')) {
      return target['custom-time'];
    }
    target = target.parentNode;
  }

  return null;
};

module.exports = CustomTime;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQ3VzdG9tVGltZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQzVDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNqQyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdkMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7QUFDNUMsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7O0FBYXBDLFNBQVMsVUFBVSxDQUFFLElBQUksRUFBRSxPQUFPLEVBQUU7QUFDbEMsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7OztBQUdqQixNQUFJLENBQUMsY0FBYyxHQUFHO0FBQ3BCLFVBQU0sRUFBRSxNQUFNO0FBQ2QsV0FBTyxFQUFFLE9BQU87QUFDaEIsVUFBTSxFQUFFLElBQUk7QUFDWixNQUFFLEVBQUUsU0FBUztBQUNiLFNBQUssRUFBRSxTQUFTO0dBQ2pCLENBQUM7QUFDRixNQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQzs7QUFFcEQsTUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLElBQUksRUFBRTtBQUMzQixRQUFJLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7R0FDaEMsTUFBTTtBQUNMLFFBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztHQUM5Qjs7QUFFRCxNQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQzs7QUFFdEIsTUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7O0FBR3pCLE1B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LENBQUMsT0FBTyxFQUFFLENBQUM7R0FDMUMsQ0FBQyxDQUFDOztBQUVILE9BQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztDQUN6QixDQUFDOzs7Ozs7OztBQVFGLFVBQVUsQ0FBQyxvQkFBb0IsR0FBRyxVQUFTLEtBQUssRUFBRTtBQUNoRCxNQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO0FBQzFCLFNBQU8sTUFBTSxFQUFFO0FBQ2IsUUFBSSxNQUFNLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxFQUFFO0FBQ3hDLGFBQU8sTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0tBQzlCO0FBQ0QsVUFBTSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7R0FDNUI7O0FBRUQsU0FBTyxJQUFJLENBQUM7Q0FDYixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDIiwiZmlsZSI6Ii91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvQ3VzdG9tVGltZS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZS9tb21lbnQnKTtcbnZhciBsb2NhbGVzID0gcmVxdWlyZSgnLi4vbG9jYWxlcycpO1xuXG4vKipcbiAqIEEgY3VzdG9tIHRpbWUgYmFyXG4gKiBAcGFyYW0ge3tyYW5nZTogUmFuZ2UsIGRvbTogT2JqZWN0fX0gYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQXZhaWxhYmxlIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyIHwgc3RyaW5nfSBpZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbG9jYWxlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbG9jYWxlXG4gKiBAY29uc3RydWN0b3IgQ3VzdG9tVGltZVxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxuZnVuY3Rpb24gQ3VzdG9tVGltZSAoYm9keSwgb3B0aW9ucykge1xuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vbWVudDogbW9tZW50LFxuICAgIGxvY2FsZXM6IGxvY2FsZXMsXG4gICAgbG9jYWxlOiAnZW4nLFxuICAgIGlkOiB1bmRlZmluZWQsXG4gICAgdGl0bGU6IHVuZGVmaW5lZFxuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aW1lKSB7XG4gICAgdGhpcy5jdXN0b21UaW1lID0gb3B0aW9ucy50aW1lO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY3VzdG9tVGltZSA9IG5ldyBEYXRlKCk7XG4gIH1cblxuICB0aGlzLmV2ZW50UGFyYW1zID0ge307IC8vIHN0b3JlcyBzdGF0ZSBwYXJhbWV0ZXJzIHdoaWxlIGRyYWdnaW5nIHRoZSBiYXJcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgLy8gY3JlYXRlIHRoZSBET01cbiAgdGhpcy5fY3JlYXRlKCk7XG59XG5cbkN1c3RvbVRpbWUucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIFNldCBvcHRpb25zIGZvciB0aGUgY29tcG9uZW50LiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIGluIGN1cnJlbnQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBBdmFpbGFibGUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtudW1iZXIgfCBzdHJpbmd9IGlkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBsb2NhbGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBsb2NhbGVcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICAvLyBjb3B5IGFsbCBvcHRpb25zIHRoYXQgd2Uga25vd1xuICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnbW9tZW50JywgJ2xvY2FsZScsICdsb2NhbGVzJywgJ2lkJ10sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBET00gZm9yIHRoZSBjdXN0b20gdGltZVxuICogQHByaXZhdGVcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGJhclsnY3VzdG9tLXRpbWUnXSA9IHRoaXM7XG4gIGJhci5jbGFzc05hbWUgPSAndmlzLWN1c3RvbS10aW1lICcgKyAodGhpcy5vcHRpb25zLmlkIHx8ICcnKTtcbiAgYmFyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgYmFyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICBiYXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICB0aGlzLmJhciA9IGJhcjtcblxuICB2YXIgZHJhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkcmFnLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgZHJhZy5zdHlsZS50b3AgPSAnMHB4JztcbiAgZHJhZy5zdHlsZS5sZWZ0ID0gJy0xMHB4JztcbiAgZHJhZy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gIGRyYWcuc3R5bGUud2lkdGggPSAnMjBweCc7XG4gIGJhci5hcHBlbmRDaGlsZChkcmFnKTtcblxuICAvLyBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lcihkcmFnKTtcbiAgdGhpcy5oYW1tZXIub24oJ3BhbnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gIHRoaXMuaGFtbWVyLm9uKCdwYW5tb3ZlJywgIHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpKTtcbiAgdGhpcy5oYW1tZXIub24oJ3BhbmVuZCcsICAgdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5nZXQoJ3BhbicpLnNldCh7dGhyZXNob2xkOjUsIGRpcmVjdGlvbjozMH0pOyAvLyAzMCBpcyBBTExfRElSRUNUSU9OUyBpbiBoYW1tZXIuXG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIEN1c3RvbVRpbWUgYmFyXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGlkZSgpO1xuXG4gIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgdGhpcy5oYW1tZXIgPSBudWxsO1xuXG4gIHRoaXMuYm9keSA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmJvZHkuZG9tLmJhY2tncm91bmRWZXJ0aWNhbDtcbiAgaWYgKHRoaXMuYmFyLnBhcmVudE5vZGUgIT0gcGFyZW50KSB7XG4gICAgLy8gYXR0YWNoIHRvIHRoZSBkb21cbiAgICBpZiAodGhpcy5iYXIucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5iYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhcik7XG4gICAgfVxuICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmJhcik7XG4gIH1cblxuICB2YXIgeCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHRoaXMuY3VzdG9tVGltZSk7XG5cbiAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICBpZiAoIWxvY2FsZSkge1xuICAgIGlmICghdGhpcy53YXJuZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBvcHRpb25zLmxvY2FsZXNbXFwnJyArIHRoaXMub3B0aW9ucy5sb2NhbGUgKyAnXFwnXSBub3QgZm91bmQuIFNlZSBodHRwOi8vdmlzanMub3JnL2RvY3MvdGltZWxpbmUuaHRtbCNMb2NhbGl6YXRpb24nKTtcbiAgICAgIHRoaXMud2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbG9jYWxlID0gdGhpcy5vcHRpb25zLmxvY2FsZXNbJ2VuJ107IC8vIGZhbGwgYmFjayBvbiBlbmdsaXNoIHdoZW4gbm90IGF2YWlsYWJsZVxuICB9XG5cbiAgdmFyIHRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAvLyBUbyBoaWRlIHRoZSB0aXRsZSBjb21wbGV0ZWx5IHVzZSBlbXB0eSBzdHJpbmcgJycuXG4gIGlmICh0aXRsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGl0bGUgPSBsb2NhbGUudGltZSArICc6ICcgKyB0aGlzLm9wdGlvbnMubW9tZW50KHRoaXMuY3VzdG9tVGltZSkuZm9ybWF0KCdkZGRkLCBNTU1NIERvIFlZWVksIEg6bW06c3MnKTtcbiAgICB0aXRsZSA9IHRpdGxlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGl0bGUuc3Vic3RyaW5nKDEpO1xuICB9XG5cbiAgdGhpcy5iYXIuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICB0aGlzLmJhci50aXRsZSA9IHRpdGxlO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBDdXN0b21UaW1lIGZyb20gdGhlIERPTVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAvLyByZW1vdmUgdGhlIGxpbmUgZnJvbSB0aGUgRE9NXG4gIGlmICh0aGlzLmJhci5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5iYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmJhcik7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGN1c3RvbSB0aW1lLlxuICogQHBhcmFtIHtEYXRlIHwgbnVtYmVyIHwgc3RyaW5nfSB0aW1lXG4gKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLnNldEN1c3RvbVRpbWUgPSBmdW5jdGlvbih0aW1lKSB7XG4gIHRoaXMuY3VzdG9tVGltZSA9IHV0aWwuY29udmVydCh0aW1lLCAnRGF0ZScpO1xuICB0aGlzLnJlZHJhdygpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBjdXN0b20gdGltZS5cbiAqIEByZXR1cm4ge0RhdGV9IGN1c3RvbVRpbWVcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuZ2V0Q3VzdG9tVGltZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IERhdGUodGhpcy5jdXN0b21UaW1lLnZhbHVlT2YoKSk7XG59O1xuXG4vKipcbiAgKiBTZXQgY3VzdG9tIHRpdGxlLlxuICAqIEBwYXJhbSB7RGF0ZSB8IG51bWJlciB8IHN0cmluZ30gdGl0bGVcbiAgKi9cbkN1c3RvbVRpbWUucHJvdG90eXBlLnNldEN1c3RvbVRpdGxlID0gZnVuY3Rpb24odGl0bGUpIHtcbiAgdGhpcy5vcHRpb25zLnRpdGxlID0gdGl0bGU7XG59O1xuXG4vKipcbiAqIFN0YXJ0IG1vdmluZyBob3Jpem9udGFsbHlcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuICB0aGlzLmV2ZW50UGFyYW1zLmRyYWdnaW5nID0gdHJ1ZTtcbiAgdGhpcy5ldmVudFBhcmFtcy5jdXN0b21UaW1lID0gdGhpcy5jdXN0b21UaW1lO1xuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIG1vdmluZyBvcGVyYXRpbmcuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQ3VzdG9tVGltZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIXRoaXMuZXZlbnRQYXJhbXMuZHJhZ2dpbmcpIHJldHVybjtcblxuICB2YXIgeCA9IHRoaXMuYm9keS51dGlsLnRvU2NyZWVuKHRoaXMuZXZlbnRQYXJhbXMuY3VzdG9tVGltZSkgKyBldmVudC5kZWx0YVg7XG4gIHZhciB0aW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKHgpO1xuXG4gIHRoaXMuc2V0Q3VzdG9tVGltZSh0aW1lKTtcblxuICAvLyBmaXJlIGEgdGltZWNoYW5nZSBldmVudFxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCd0aW1lY2hhbmdlJywge1xuICAgIGlkOiB0aGlzLm9wdGlvbnMuaWQsXG4gICAgdGltZTogbmV3IERhdGUodGhpcy5jdXN0b21UaW1lLnZhbHVlT2YoKSlcbiAgfSk7XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuXG4vKipcbiAqIFN0b3AgbW92aW5nIG9wZXJhdGluZy5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5DdXN0b21UaW1lLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghdGhpcy5ldmVudFBhcmFtcy5kcmFnZ2luZykgcmV0dXJuO1xuXG4gIC8vIGZpcmUgYSB0aW1lY2hhbmdlZCBldmVudFxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCd0aW1lY2hhbmdlZCcsIHtcbiAgICBpZDogdGhpcy5vcHRpb25zLmlkLFxuICAgIHRpbWU6IG5ldyBEYXRlKHRoaXMuY3VzdG9tVGltZS52YWx1ZU9mKCkpXG4gIH0pO1xuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuLyoqXG4gKiBGaW5kIGEgY3VzdG9tIHRpbWUgZnJvbSBhbiBldmVudCB0YXJnZXQ6XG4gKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAnY3VzdG9tLXRpbWUnIGluIHRoZSBldmVudCB0YXJnZXQncyBlbGVtZW50IHRyZWVcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtDdXN0b21UaW1lIHwgbnVsbH0gY3VzdG9tVGltZVxuICovXG5DdXN0b21UaW1lLmN1c3RvbVRpbWVGcm9tVGFyZ2V0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgd2hpbGUgKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ2N1c3RvbS10aW1lJykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRbJ2N1c3RvbS10aW1lJ107XG4gICAgfVxuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1c3RvbVRpbWU7XG4iXX0=
},{"../../module/hammer":19,"../../module/moment":20,"../../util":46,"../locales":44,"./Component":33}],36:[function(require,module,exports){
'use strict';

var util = require('../../util');
var stack = require('../Stack');
var RangeItem = require('./item/RangeItem');

/**
 * @constructor Group
 * @param {Number | String} groupId
 * @param {Object} data
 * @param {ItemSet} itemSet
 */
function Group(groupId, data, itemSet) {
  this.groupId = groupId;
  this.subgroups = {};
  this.subgroupIndex = 0;
  this.subgroupOrderer = data && data.subgroupOrder;
  this.itemSet = itemSet;

  this.dom = {};
  this.props = {
    label: {
      width: 0,
      height: 0
    }
  };
  this.className = null;

  this.items = {}; // items filtered by groupId of this group
  this.visibleItems = []; // items currently visible in window
  this.orderedItems = {
    byStart: [],
    byEnd: []
  };
  this.checkRangedItems = false; // needed to refresh the ranged items if the window is programatically changed with NO overlap.
  var me = this;
  this.itemSet.body.emitter.on("checkRangedItems", function () {
    me.checkRangedItems = true;
  });

  this._create();

  this.setData(data);
}

/**
 * Create DOM elements for the group
 * @private
 */
Group.prototype._create = function () {
  var label = document.createElement('div');
  if (this.itemSet.options.groupEditable.order) {
    label.className = 'vis-label draggable';
  } else {
    label.className = 'vis-label';
  }
  this.dom.label = label;

  var inner = document.createElement('div');
  inner.className = 'vis-inner';
  label.appendChild(inner);
  this.dom.inner = inner;

  var foreground = document.createElement('div');
  foreground.className = 'vis-group';
  foreground['timeline-group'] = this;
  this.dom.foreground = foreground;

  this.dom.background = document.createElement('div');
  this.dom.background.className = 'vis-group';

  this.dom.axis = document.createElement('div');
  this.dom.axis.className = 'vis-group';

  // create a hidden marker to detect when the Timelines container is attached
  // to the DOM, or the style of a parent of the Timeline is changed from
  // display:none is changed to visible.
  this.dom.marker = document.createElement('div');
  this.dom.marker.style.visibility = 'hidden';
  this.dom.marker.innerHTML = '?';
  this.dom.background.appendChild(this.dom.marker);
};

/**
 * Set the group data for this group
 * @param {Object} data   Group data, can contain properties content and className
 */
Group.prototype.setData = function (data) {
  // update contents
  var content;
  if (this.itemSet.options && this.itemSet.options.groupTemplate) {
    content = this.itemSet.options.groupTemplate(data);
  } else {
    content = data && data.content;
  }

  if (content instanceof Element) {
    this.dom.inner.appendChild(content);
    while (this.dom.inner.firstChild) {
      this.dom.inner.removeChild(this.dom.inner.firstChild);
    }
    this.dom.inner.appendChild(content);
  } else if (content !== undefined && content !== null) {
    this.dom.inner.innerHTML = content;
  } else {
    this.dom.inner.innerHTML = this.groupId || ''; // groupId can be null
  }

  // update title
  this.dom.label.title = data && data.title || '';

  if (!this.dom.inner.firstChild) {
    util.addClassName(this.dom.inner, 'vis-hidden');
  } else {
    util.removeClassName(this.dom.inner, 'vis-hidden');
  }

  // update className
  var className = data && data.className || null;
  if (className != this.className) {
    if (this.className) {
      util.removeClassName(this.dom.label, this.className);
      util.removeClassName(this.dom.foreground, this.className);
      util.removeClassName(this.dom.background, this.className);
      util.removeClassName(this.dom.axis, this.className);
    }
    util.addClassName(this.dom.label, className);
    util.addClassName(this.dom.foreground, className);
    util.addClassName(this.dom.background, className);
    util.addClassName(this.dom.axis, className);
    this.className = className;
  }

  // update style
  if (this.style) {
    util.removeCssText(this.dom.label, this.style);
    this.style = null;
  }
  if (data && data.style) {
    util.addCssText(this.dom.label, data.style);
    this.style = data.style;
  }
};

/**
 * Get the width of the group label
 * @return {number} width
 */
Group.prototype.getLabelWidth = function () {
  return this.props.label.width;
};

/**
 * Repaint this group
 * @param {{start: number, end: number}} range
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @param {boolean} [restack=false]  Force restacking of all items
 * @return {boolean} Returns true if the group is resized
 */
Group.prototype.redraw = function (range, margin, restack) {
  var resized = false;

  // force recalculation of the height of the items when the marker height changed
  // (due to the Timeline being attached to the DOM or changed from display:none to visible)
  var markerHeight = this.dom.marker.clientHeight;
  if (markerHeight != this.lastMarkerHeight) {
    this.lastMarkerHeight = markerHeight;

    util.forEach(this.items, function (item) {
      item.dirty = true;
      if (item.displayed) item.redraw();
    });

    restack = true;
  }

  // reposition visible items vertically
  if (typeof this.itemSet.options.order === 'function') {
    // a custom order function

    if (restack) {
      // brute force restack of all items

      // show all items
      var me = this;
      var limitSize = false;
      util.forEach(this.items, function (item) {
        if (!item.displayed) {
          item.redraw();
          me.visibleItems.push(item);
        }
        item.repositionX(limitSize);
      });

      // order all items and force a restacking
      var customOrderedItems = this.orderedItems.byStart.slice().sort(function (a, b) {
        return me.itemSet.options.order(a.data, b.data);
      });
      stack.stack(customOrderedItems, margin, true /* restack=true */);
    }

    this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);
  } else {
    // no custom order function, lazy stacking
    this.visibleItems = this._updateVisibleItems(this.orderedItems, this.visibleItems, range);

    if (this.itemSet.options.stack) {
      // TODO: ugly way to access options...
      stack.stack(this.visibleItems, margin, restack);
    } else {
      // no stacking
      stack.nostack(this.visibleItems, margin, this.subgroups);
    }
  }

  // recalculate the height of the group
  var height = this._calculateHeight(margin);

  // calculate actual size and position
  var foreground = this.dom.foreground;
  this.top = foreground.offsetTop;
  this.left = foreground.offsetLeft;
  this.width = foreground.offsetWidth;
  resized = util.updateProperty(this, 'height', height) || resized;

  // recalculate size of label
  resized = util.updateProperty(this.props.label, 'width', this.dom.inner.clientWidth) || resized;
  resized = util.updateProperty(this.props.label, 'height', this.dom.inner.clientHeight) || resized;

  // apply new height
  this.dom.background.style.height = height + 'px';
  this.dom.foreground.style.height = height + 'px';
  this.dom.label.style.height = height + 'px';

  // update vertical position of items after they are re-stacked and the height of the group is calculated
  for (var i = 0, ii = this.visibleItems.length; i < ii; i++) {
    var item = this.visibleItems[i];
    item.repositionY(margin);
  }

  return resized;
};

/**
 * recalculate the height of the group
 * @param {{item: {horizontal: number, vertical: number}, axis: number}} margin
 * @returns {number} Returns the height
 * @private
 */
Group.prototype._calculateHeight = function (margin) {
  // recalculate the height of the group
  var height;
  var visibleItems = this.visibleItems;
  //var visibleSubgroups = [];
  //this.visibleSubgroups = 0;
  this.resetSubgroups();
  var me = this;
  if (visibleItems.length > 0) {
    var min = visibleItems[0].top;
    var max = visibleItems[0].top + visibleItems[0].height;
    util.forEach(visibleItems, function (item) {
      min = Math.min(min, item.top);
      max = Math.max(max, item.top + item.height);
      if (item.data.subgroup !== undefined) {
        me.subgroups[item.data.subgroup].height = Math.max(me.subgroups[item.data.subgroup].height, item.height);
        me.subgroups[item.data.subgroup].visible = true;
      }
    });
    if (min > margin.axis) {
      // there is an empty gap between the lowest item and the axis
      var offset = min - margin.axis;
      max -= offset;
      util.forEach(visibleItems, function (item) {
        item.top -= offset;
      });
    }
    height = max + margin.item.vertical / 2;
  } else {
    height = 0;
  }
  height = Math.max(height, this.props.label.height);

  return height;
};

/**
 * Show this group: attach to the DOM
 */
Group.prototype.show = function () {
  if (!this.dom.label.parentNode) {
    this.itemSet.dom.labelSet.appendChild(this.dom.label);
  }

  if (!this.dom.foreground.parentNode) {
    this.itemSet.dom.foreground.appendChild(this.dom.foreground);
  }

  if (!this.dom.background.parentNode) {
    this.itemSet.dom.background.appendChild(this.dom.background);
  }

  if (!this.dom.axis.parentNode) {
    this.itemSet.dom.axis.appendChild(this.dom.axis);
  }
};

/**
 * Hide this group: remove from the DOM
 */
Group.prototype.hide = function () {
  var label = this.dom.label;
  if (label.parentNode) {
    label.parentNode.removeChild(label);
  }

  var foreground = this.dom.foreground;
  if (foreground.parentNode) {
    foreground.parentNode.removeChild(foreground);
  }

  var background = this.dom.background;
  if (background.parentNode) {
    background.parentNode.removeChild(background);
  }

  var axis = this.dom.axis;
  if (axis.parentNode) {
    axis.parentNode.removeChild(axis);
  }
};

/**
 * Add an item to the group
 * @param {Item} item
 */
Group.prototype.add = function (item) {
  this.items[item.id] = item;
  item.setParent(this);

  // add to
  if (item.data.subgroup !== undefined) {
    if (this.subgroups[item.data.subgroup] === undefined) {
      this.subgroups[item.data.subgroup] = { height: 0, visible: false, index: this.subgroupIndex, items: [] };
      this.subgroupIndex++;
    }
    this.subgroups[item.data.subgroup].items.push(item);
  }
  this.orderSubgroups();

  if (this.visibleItems.indexOf(item) == -1) {
    var range = this.itemSet.body.range; // TODO: not nice accessing the range like this
    this._checkIfVisible(item, this.visibleItems, range);
  }
};

Group.prototype.orderSubgroups = function () {
  if (this.subgroupOrderer !== undefined) {
    var sortArray = [];
    if (typeof this.subgroupOrderer == 'string') {
      for (var subgroup in this.subgroups) {
        sortArray.push({ subgroup: subgroup, sortField: this.subgroups[subgroup].items[0].data[this.subgroupOrderer] });
      }
      sortArray.sort(function (a, b) {
        return a.sortField - b.sortField;
      });
    } else if (typeof this.subgroupOrderer == 'function') {
      for (var subgroup in this.subgroups) {
        sortArray.push(this.subgroups[subgroup].items[0].data);
      }
      sortArray.sort(this.subgroupOrderer);
    }

    if (sortArray.length > 0) {
      for (var i = 0; i < sortArray.length; i++) {
        this.subgroups[sortArray[i].subgroup].index = i;
      }
    }
  }
};

Group.prototype.resetSubgroups = function () {
  for (var subgroup in this.subgroups) {
    if (this.subgroups.hasOwnProperty(subgroup)) {
      this.subgroups[subgroup].visible = false;
    }
  }
};

/**
 * Remove an item from the group
 * @param {Item} item
 */
Group.prototype.remove = function (item) {
  delete this.items[item.id];
  item.setParent(null);

  // remove from visible items
  var index = this.visibleItems.indexOf(item);
  if (index != -1) this.visibleItems.splice(index, 1);

  if (item.data.subgroup !== undefined) {
    var subgroup = this.subgroups[item.data.subgroup];
    if (subgroup) {
      var itemIndex = subgroup.items.indexOf(item);
      subgroup.items.splice(itemIndex, 1);
      if (!subgroup.items.length) {
        delete this.subgroups[item.data.subgroup];
        this.subgroupIndex--;
      }
      this.orderSubgroups();
    }
  }
};

/**
 * Remove an item from the corresponding DataSet
 * @param {Item} item
 */
Group.prototype.removeFromDataSet = function (item) {
  this.itemSet.removeItem(item.id);
};

/**
 * Reorder the items
 */
Group.prototype.order = function () {
  var array = util.toArray(this.items);
  var startArray = [];
  var endArray = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i].data.end !== undefined) {
      endArray.push(array[i]);
    }
    startArray.push(array[i]);
  }
  this.orderedItems = {
    byStart: startArray,
    byEnd: endArray
  };

  stack.orderByStart(this.orderedItems.byStart);
  stack.orderByEnd(this.orderedItems.byEnd);
};

/**
 * Update the visible items
 * @param {{byStart: Item[], byEnd: Item[]}} orderedItems   All items ordered by start date and by end date
 * @param {Item[]} visibleItems                             The previously visible items.
 * @param {{start: number, end: number}} range              Visible range
 * @return {Item[]} visibleItems                            The new visible items.
 * @private
 */
Group.prototype._updateVisibleItems = function (orderedItems, oldVisibleItems, range) {
  var visibleItems = [];
  var visibleItemsLookup = {}; // we keep this to quickly look up if an item already exists in the list without using indexOf on visibleItems
  var interval = (range.end - range.start) / 4;
  var lowerBound = range.start - interval;
  var upperBound = range.end + interval;
  var item, i;

  // this function is used to do the binary search.
  var searchFunction = function searchFunction(value) {
    if (value < lowerBound) {
      return -1;
    } else if (value <= upperBound) {
      return 0;
    } else {
      return 1;
    }
  };

  // first check if the items that were in view previously are still in view.
  // IMPORTANT: this handles the case for the items with startdate before the window and enddate after the window!
  // also cleans up invisible items.
  if (oldVisibleItems.length > 0) {
    for (i = 0; i < oldVisibleItems.length; i++) {
      this._checkIfVisibleWithReference(oldVisibleItems[i], visibleItems, visibleItemsLookup, range);
    }
  }

  // we do a binary search for the items that have only start values.
  var initialPosByStart = util.binarySearchCustom(orderedItems.byStart, searchFunction, 'data', 'start');

  // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the start values.
  this._traceVisible(initialPosByStart, orderedItems.byStart, visibleItems, visibleItemsLookup, function (item) {
    return item.data.start < lowerBound || item.data.start > upperBound;
  });

  // if the window has changed programmatically without overlapping the old window, the ranged items with start < lowerBound and end > upperbound are not shown.
  // We therefore have to brute force check all items in the byEnd list
  if (this.checkRangedItems == true) {
    this.checkRangedItems = false;
    for (i = 0; i < orderedItems.byEnd.length; i++) {
      this._checkIfVisibleWithReference(orderedItems.byEnd[i], visibleItems, visibleItemsLookup, range);
    }
  } else {
    // we do a binary search for the items that have defined end times.
    var initialPosByEnd = util.binarySearchCustom(orderedItems.byEnd, searchFunction, 'data', 'end');

    // trace the visible items from the inital start pos both ways until an invisible item is found, we only look at the end values.
    this._traceVisible(initialPosByEnd, orderedItems.byEnd, visibleItems, visibleItemsLookup, function (item) {
      return item.data.end < lowerBound || item.data.end > upperBound;
    });
  }

  // finally, we reposition all the visible items.
  for (i = 0; i < visibleItems.length; i++) {
    item = visibleItems[i];
    if (!item.displayed) item.show();
    // reposition item horizontally
    item.repositionX();
  }

  // debug
  //console.log("new line")
  //if (this.groupId == null) {
  //  for (i = 0; i < orderedItems.byStart.length; i++) {
  //    item = orderedItems.byStart[i].data;
  //    console.log('start',i,initialPosByStart, item.start.valueOf(), item.content, item.start >= lowerBound && item.start <= upperBound,i == initialPosByStart ? "<------------------- HEREEEE" : "")
  //  }
  //  for (i = 0; i < orderedItems.byEnd.length; i++) {
  //    item = orderedItems.byEnd[i].data;
  //    console.log('rangeEnd',i,initialPosByEnd, item.end.valueOf(), item.content, item.end >= range.start && item.end <= range.end,i == initialPosByEnd ? "<------------------- HEREEEE" : "")
  //  }
  //}

  return visibleItems;
};

Group.prototype._traceVisible = function (initialPos, items, visibleItems, visibleItemsLookup, breakCondition) {
  var item;
  var i;

  if (initialPos != -1) {
    for (i = initialPos; i >= 0; i--) {
      item = items[i];
      if (breakCondition(item)) {
        break;
      } else {
        if (visibleItemsLookup[item.id] === undefined) {
          visibleItemsLookup[item.id] = true;
          visibleItems.push(item);
        }
      }
    }

    for (i = initialPos + 1; i < items.length; i++) {
      item = items[i];
      if (breakCondition(item)) {
        break;
      } else {
        if (visibleItemsLookup[item.id] === undefined) {
          visibleItemsLookup[item.id] = true;
          visibleItems.push(item);
        }
      }
    }
  }
};

/**
 * this function is very similar to the _checkIfInvisible() but it does not
 * return booleans, hides the item if it should not be seen and always adds to
 * the visibleItems.
 * this one is for brute forcing and hiding.
 *
 * @param {Item} item
 * @param {Array} visibleItems
 * @param {{start:number, end:number}} range
 * @private
 */
Group.prototype._checkIfVisible = function (item, visibleItems, range) {
  if (item.isVisible(range)) {
    if (!item.displayed) item.show();
    // reposition item horizontally
    item.repositionX();
    visibleItems.push(item);
  } else {
    if (item.displayed) item.hide();
  }
};

/**
 * this function is very similar to the _checkIfInvisible() but it does not
 * return booleans, hides the item if it should not be seen and always adds to
 * the visibleItems.
 * this one is for brute forcing and hiding.
 *
 * @param {Item} item
 * @param {Array} visibleItems
 * @param {{start:number, end:number}} range
 * @private
 */
Group.prototype._checkIfVisibleWithReference = function (item, visibleItems, visibleItemsLookup, range) {
  if (item.isVisible(range)) {
    if (visibleItemsLookup[item.id] === undefined) {
      visibleItemsLookup[item.id] = true;
      visibleItems.push(item);
    }
  } else {
    if (item.displayed) item.hide();
  }
};

module.exports = Group;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvR3JvdXAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDakMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2hDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDOzs7Ozs7OztBQVE1QyxTQUFTLEtBQUssQ0FBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUN0QyxNQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUN2QixNQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztBQUNwQixNQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN2QixNQUFJLENBQUMsZUFBZSxHQUFHLElBQUksSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDO0FBQ2xELE1BQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDOztBQUV2QixNQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNkLE1BQUksQ0FBQyxLQUFLLEdBQUc7QUFDWCxTQUFLLEVBQUU7QUFDTCxXQUFLLEVBQUUsQ0FBQztBQUNSLFlBQU0sRUFBRSxDQUFDO0tBQ1Y7R0FDRixDQUFDO0FBQ0YsTUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7O0FBRXRCLE1BQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2hCLE1BQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLE1BQUksQ0FBQyxZQUFZLEdBQUc7QUFDbEIsV0FBTyxFQUFFLEVBQUU7QUFDWCxTQUFLLEVBQUUsRUFBRTtHQUNWLENBQUM7QUFDRixNQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO0FBQzlCLE1BQUksRUFBRSxHQUFHLElBQUksQ0FBQztBQUNk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U0FBUyxDQUFDLENBQUM7QUFDckQsVUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDMUQsVUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDMUQsVUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDckQ7QUFDRCxRQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQzdDLFFBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDbEQsUUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUNsRCxRQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQzVDLFFBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0dBQzVCOzs7QUFHRCxNQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7QUFDZCxRQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMvQyxRQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztHQUNuQjtBQUNELE1BQUksSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7QUFDdEIsUUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDNUMsUUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMs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LENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyIsImZpbGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L0dyb3VwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgc3RhY2sgPSByZXF1aXJlKCcuLi9TdGFjaycpO1xudmFyIFJhbmdlSXRlbSA9IHJlcXVpcmUoJy4vaXRlbS9SYW5nZUl0ZW0nKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgR3JvdXBcbiAqIEBwYXJhbSB7TnVtYmVyIHwgU3RyaW5nfSBncm91cElkXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtJdGVtU2V0fSBpdGVtU2V0XG4gKi9cbmZ1bmN0aW9uIEdyb3VwIChncm91cElkLCBkYXRhLCBpdGVtU2V0KSB7XG4gIHRoaXMuZ3JvdXBJZCA9IGdyb3VwSWQ7XG4gIHRoaXMuc3ViZ3JvdXBzID0ge307XG4gIHRoaXMuc3ViZ3JvdXBJbmRleCA9IDA7XG4gIHRoaXMuc3ViZ3JvdXBPcmRlcmVyID0gZGF0YSAmJiBkYXRhLnN1Ymdyb3VwT3JkZXI7XG4gIHRoaXMuaXRlbVNldCA9IGl0ZW1TZXQ7XG5cbiAgdGhpcy5kb20gPSB7fTtcbiAgdGhpcy5wcm9wcyA9IHtcbiAgICBsYWJlbDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9XG4gIH07XG4gIHRoaXMuY2xhc3NOYW1lID0gbnVsbDtcblxuICB0aGlzLml0ZW1zID0ge307ICAgICAgICAvLyBpdGVtcyBmaWx0ZXJlZCBieSBncm91cElkIG9mIHRoaXMgZ3JvdXBcbiAgdGhpcy52aXNpYmxlSXRlbXMgPSBbXTsgLy8gaXRlbXMgY3VycmVudGx5IHZpc2libGUgaW4gd2luZG93XG4gIHRoaXMub3JkZXJlZEl0ZW1zID0ge1xuICAgIGJ5U3RhcnQ6IFtdLFxuICAgIGJ5RW5kOiBbXVxuICB9O1xuICB0aGlzLmNoZWNrUmFuZ2VkSXRlbXMgPSBmYWxzZTsgLy8gbmVlZGVkIHRvIHJlZnJlc2ggdGhlIHJhbmdlZCBpdGVtcyBpZiB0aGUgd2luZG93IGlzIHByb2dyYW1hdGljYWxseSBjaGFuZ2VkIHdpdGggTk8gb3ZlcmxhcC5cbiAgdmFyIG1lID0gdGhpcztcbiAgdGhpcy5pdGVtU2V0LmJvZHkuZW1pdHRlci5vbihcImNoZWNrUmFuZ2VkSXRlbXNcIiwgZnVuY3Rpb24gKCkge1xuICAgIG1lLmNoZWNrUmFuZ2VkSXRlbXMgPSB0cnVlO1xuICB9KVxuXG4gIHRoaXMuX2NyZWF0ZSgpO1xuXG4gIHRoaXMuc2V0RGF0YShkYXRhKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgRE9NIGVsZW1lbnRzIGZvciB0aGUgZ3JvdXBcbiAqIEBwcml2YXRlXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBpZiAodGhpcy5pdGVtU2V0Lm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5vcmRlcikge1xuXHQgIGxhYmVsLmNsYXNzTmFtZSA9ICd2aXMtbGFiZWwgZHJhZ2dhYmxlJztcbiAgfSBlbHNlIHtcblx0ICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLWxhYmVsJztcbiAgfVxuICB0aGlzLmRvbS5sYWJlbCA9IGxhYmVsO1xuXG4gIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBpbm5lci5jbGFzc05hbWUgPSAndmlzLWlubmVyJztcbiAgbGFiZWwuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICB0aGlzLmRvbS5pbm5lciA9IGlubmVyO1xuXG4gIHZhciBmb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGZvcmVncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1ncm91cCc7XG4gIGZvcmVncm91bmRbJ3RpbWVsaW5lLWdyb3VwJ10gPSB0aGlzO1xuICB0aGlzLmRvbS5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcblxuICB0aGlzLmRvbS5iYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy1ncm91cCc7XG5cbiAgdGhpcy5kb20uYXhpcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmRvbS5heGlzLmNsYXNzTmFtZSA9ICd2aXMtZ3JvdXAnO1xuXG4gIC8vIGNyZWF0ZSBhIGhpZGRlbiBtYXJrZXIgdG8gZGV0ZWN0IHdoZW4gdGhlIFRpbWVsaW5lcyBjb250YWluZXIgaXMgYXR0YWNoZWRcbiAgLy8gdG8gdGhlIERPTSwgb3IgdGhlIHN0eWxlIG9mIGEgcGFyZW50IG9mIHRoZSBUaW1lbGluZSBpcyBjaGFuZ2VkIGZyb21cbiAgLy8gZGlzcGxheTpub25lIGlzIGNoYW5nZWQgdG8gdmlzaWJsZS5cbiAgdGhpcy5kb20ubWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuZG9tLm1hcmtlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIHRoaXMuZG9tLm1hcmtlci5pbm5lckhUTUwgPSAnPyc7XG4gIHRoaXMuZG9tLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubWFya2VyKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBncm91cCBkYXRhIGZvciB0aGlzIGdyb3VwXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgIEdyb3VwIGRhdGEsIGNhbiBjb250YWluIHByb3BlcnRpZXMgY29udGVudCBhbmQgY2xhc3NOYW1lXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAvLyB1cGRhdGUgY29udGVudHNcbiAgdmFyIGNvbnRlbnQ7XG4gIGlmICh0aGlzLml0ZW1TZXQub3B0aW9ucyAmJiB0aGlzLml0ZW1TZXQub3B0aW9ucy5ncm91cFRlbXBsYXRlKSB7XG4gICAgY29udGVudCA9IHRoaXMuaXRlbVNldC5vcHRpb25zLmdyb3VwVGVtcGxhdGUoZGF0YSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgY29udGVudCA9IGRhdGEgJiYgZGF0YS5jb250ZW50O1xuICB9XG5cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgdGhpcy5kb20uaW5uZXIuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgd2hpbGUgKHRoaXMuZG9tLmlubmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMuZG9tLmlubmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmlubmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB0aGlzLmRvbS5pbm5lci5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgfVxuICBlbHNlIGlmIChjb250ZW50ICE9PSB1bmRlZmluZWQgJiYgY29udGVudCAhPT0gbnVsbCkge1xuICAgIHRoaXMuZG9tLmlubmVyLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5kb20uaW5uZXIuaW5uZXJIVE1MID0gdGhpcy5ncm91cElkIHx8ICcnOyAvLyBncm91cElkIGNhbiBiZSBudWxsXG4gIH1cblxuICAvLyB1cGRhdGUgdGl0bGVcbiAgdGhpcy5kb20ubGFiZWwudGl0bGUgPSBkYXRhICYmIGRhdGEudGl0bGUgfHwgJyc7XG5cbiAgaWYgKCF0aGlzLmRvbS5pbm5lci5maXJzdENoaWxkKSB7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uaW5uZXIsICd2aXMtaGlkZGVuJyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdXRpbC5yZW1vdmVDbGFzc05hbWUodGhpcy5kb20uaW5uZXIsICd2aXMtaGlkZGVuJyk7XG4gIH1cblxuICAvLyB1cGRhdGUgY2xhc3NOYW1lXG4gIHZhciBjbGFzc05hbWUgPSBkYXRhICYmIGRhdGEuY2xhc3NOYW1lIHx8IG51bGw7XG4gIGlmIChjbGFzc05hbWUgIT0gdGhpcy5jbGFzc05hbWUpIHtcbiAgICBpZiAodGhpcy5jbGFzc05hbWUpIHtcbiAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKHRoaXMuZG9tLmxhYmVsLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5mb3JlZ3JvdW5kLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5iYWNrZ3JvdW5kLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZSh0aGlzLmRvbS5heGlzLCB0aGlzLmNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmxhYmVsLCBjbGFzc05hbWUpO1xuICAgIHV0aWwuYWRkQ2xhc3NOYW1lKHRoaXMuZG9tLmZvcmVncm91bmQsIGNsYXNzTmFtZSk7XG4gICAgdXRpbC5hZGRDbGFzc05hbWUodGhpcy5kb20uYmFja2dyb3VuZCwgY2xhc3NOYW1lKTtcbiAgICB1dGlsLmFkZENsYXNzTmFtZSh0aGlzLmRvbS5heGlzLCBjbGFzc05hbWUpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICB9XG5cbiAgLy8gdXBkYXRlIHN0eWxlXG4gIGlmICh0aGlzLnN0eWxlKSB7XG4gICAgdXRpbC5yZW1vdmVDc3NUZXh0KHRoaXMuZG9tLmxhYmVsLCB0aGlzLnN0eWxlKTtcbiAgICB0aGlzLnN0eWxlID0gbnVsbDtcbiAgfVxuICBpZiAoZGF0YSAmJiBkYXRhLnN0eWxlKSB7XG4gICAgdXRpbC5hZGRDc3NUZXh0KHRoaXMuZG9tLmxhYmVsLCBkYXRhLnN0eWxlKTtcbiAgICB0aGlzLnN0eWxlID0gZGF0YS5zdHlsZTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBncm91cCBsYWJlbFxuICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICovXG5Hcm91cC5wcm90b3R5cGUuZ2V0TGFiZWxXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wcm9wcy5sYWJlbC53aWR0aDtcbn07XG5cblxuLyoqXG4gKiBSZXBhaW50IHRoaXMgZ3JvdXBcbiAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2VcbiAqIEBwYXJhbSB7e2l0ZW06IHtob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXJ9LCBheGlzOiBudW1iZXJ9fSBtYXJnaW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3RhY2s9ZmFsc2VdICBGb3JjZSByZXN0YWNraW5nIG9mIGFsbCBpdGVtc1xuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBncm91cCBpcyByZXNpemVkXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbihyYW5nZSwgbWFyZ2luLCByZXN0YWNrKSB7XG4gIHZhciByZXNpemVkID0gZmFsc2U7XG5cbiAgLy8gZm9yY2UgcmVjYWxjdWxhdGlvbiBvZiB0aGUgaGVpZ2h0IG9mIHRoZSBpdGVtcyB3aGVuIHRoZSBtYXJrZXIgaGVpZ2h0IGNoYW5nZWRcbiAgLy8gKGR1ZSB0byB0aGUgVGltZWxpbmUgYmVpbmcgYXR0YWNoZWQgdG8gdGhlIERPTSBvciBjaGFuZ2VkIGZyb20gZGlzcGxheTpub25lIHRvIHZpc2libGUpXG4gIHZhciBtYXJrZXJIZWlnaHQgPSB0aGlzLmRvbS5tYXJrZXIuY2xpZW50SGVpZ2h0O1xuICBpZiAobWFya2VySGVpZ2h0ICE9IHRoaXMubGFzdE1hcmtlckhlaWdodCkge1xuICAgIHRoaXMubGFzdE1hcmtlckhlaWdodCA9IG1hcmtlckhlaWdodDtcblxuICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaXRlbS5kaXJ0eSA9IHRydWU7XG4gICAgICBpZiAoaXRlbS5kaXNwbGF5ZWQpIGl0ZW0ucmVkcmF3KCk7XG4gICAgfSk7XG5cbiAgICByZXN0YWNrID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHJlcG9zaXRpb24gdmlzaWJsZSBpdGVtcyB2ZXJ0aWNhbGx5XG4gIGlmICh0eXBlb2YgdGhpcy5pdGVtU2V0Lm9wdGlvbnMub3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBhIGN1c3RvbSBvcmRlciBmdW5jdGlvblxuXG4gICAgaWYgKHJlc3RhY2spIHtcbiAgICAgIC8vIGJydXRlIGZvcmNlIHJlc3RhY2sgb2YgYWxsIGl0ZW1zXG5cbiAgICAgIC8vIHNob3cgYWxsIGl0ZW1zXG4gICAgICB2YXIgbWUgPSB0aGlzO1xuICAgICAgdmFyIGxpbWl0U2l6ZSA9IGZhbHNlO1xuICAgICAgdXRpbC5mb3JFYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5kaXNwbGF5ZWQpIHtcbiAgICAgICAgICBpdGVtLnJlZHJhdygpO1xuICAgICAgICAgIG1lLnZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ucmVwb3NpdGlvblgobGltaXRTaXplKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBvcmRlciBhbGwgaXRlbXMgYW5kIGZvcmNlIGEgcmVzdGFja2luZ1xuICAgICAgdmFyIGN1c3RvbU9yZGVyZWRJdGVtcyA9IHRoaXMub3JkZXJlZEl0ZW1zLmJ5U3RhcnQuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBtZS5pdGVtU2V0Lm9wdGlvbnMub3JkZXIoYS5kYXRhLCBiLmRhdGEpO1xuICAgICAgfSk7XG4gICAgICBzdGFjay5zdGFjayhjdXN0b21PcmRlcmVkSXRlbXMsIG1hcmdpbiwgdHJ1ZSAvKiByZXN0YWNrPXRydWUgKi8pO1xuICAgIH1cblxuICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gdGhpcy5fdXBkYXRlVmlzaWJsZUl0ZW1zKHRoaXMub3JkZXJlZEl0ZW1zLCB0aGlzLnZpc2libGVJdGVtcywgcmFuZ2UpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vIGN1c3RvbSBvcmRlciBmdW5jdGlvbiwgbGF6eSBzdGFja2luZ1xuICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gdGhpcy5fdXBkYXRlVmlzaWJsZUl0ZW1zKHRoaXMub3JkZXJlZEl0ZW1zLCB0aGlzLnZpc2libGVJdGVtcywgcmFuZ2UpO1xuXG4gICAgaWYgKHRoaXMuaXRlbVNldC5vcHRpb25zLnN0YWNrKSB7IC8vIFRPRE86IHVnbHkgd2F5IHRvIGFjY2VzcyBvcHRpb25zLi4uXG4gICAgICBzdGFjay5zdGFjayh0aGlzLnZpc2libGVJdGVtcywgbWFyZ2luLCByZXN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIG5vIHN0YWNraW5nXG4gICAgICBzdGFjay5ub3N0YWNrKHRoaXMudmlzaWJsZUl0ZW1zLCBtYXJnaW4sIHRoaXMuc3ViZ3JvdXBzKTtcbiAgICB9XG4gIH1cblxuICAvLyByZWNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cFxuICB2YXIgaGVpZ2h0ID0gdGhpcy5fY2FsY3VsYXRlSGVpZ2h0KG1hcmdpbik7XG5cbiAgLy8gY2FsY3VsYXRlIGFjdHVhbCBzaXplIGFuZCBwb3NpdGlvblxuICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMuZG9tLmZvcmVncm91bmQ7XG4gIHRoaXMudG9wID0gZm9yZWdyb3VuZC5vZmZzZXRUb3A7XG4gIHRoaXMubGVmdCA9IGZvcmVncm91bmQub2Zmc2V0TGVmdDtcbiAgdGhpcy53aWR0aCA9IGZvcmVncm91bmQub2Zmc2V0V2lkdGg7XG4gIHJlc2l6ZWQgPSB1dGlsLnVwZGF0ZVByb3BlcnR5KHRoaXMsICdoZWlnaHQnLCBoZWlnaHQpIHx8IHJlc2l6ZWQ7XG5cbiAgLy8gcmVjYWxjdWxhdGUgc2l6ZSBvZiBsYWJlbFxuICByZXNpemVkID0gdXRpbC51cGRhdGVQcm9wZXJ0eSh0aGlzLnByb3BzLmxhYmVsLCAnd2lkdGgnLCB0aGlzLmRvbS5pbm5lci5jbGllbnRXaWR0aCkgfHwgcmVzaXplZDtcbiAgcmVzaXplZCA9IHV0aWwudXBkYXRlUHJvcGVydHkodGhpcy5wcm9wcy5sYWJlbCwgJ2hlaWdodCcsIHRoaXMuZG9tLmlubmVyLmNsaWVudEhlaWdodCkgfHwgcmVzaXplZDtcblxuICAvLyBhcHBseSBuZXcgaGVpZ2h0XG4gIHRoaXMuZG9tLmJhY2tncm91bmQuc3R5bGUuaGVpZ2h0ICA9IGhlaWdodCArICdweCc7XG4gIHRoaXMuZG9tLmZvcmVncm91bmQuc3R5bGUuaGVpZ2h0ICA9IGhlaWdodCArICdweCc7XG4gIHRoaXMuZG9tLmxhYmVsLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgLy8gdXBkYXRlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIGl0ZW1zIGFmdGVyIHRoZXkgYXJlIHJlLXN0YWNrZWQgYW5kIHRoZSBoZWlnaHQgb2YgdGhlIGdyb3VwIGlzIGNhbGN1bGF0ZWRcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy52aXNpYmxlSXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIHZhciBpdGVtID0gdGhpcy52aXNpYmxlSXRlbXNbaV07XG4gICAgaXRlbS5yZXBvc2l0aW9uWShtYXJnaW4pO1xuICB9XG5cbiAgcmV0dXJuIHJlc2l6ZWQ7XG59O1xuXG4vKipcbiAqIHJlY2FsY3VsYXRlIHRoZSBoZWlnaHQgb2YgdGhlIGdyb3VwXG4gKiBAcGFyYW0ge3tpdGVtOiB7aG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyfSwgYXhpczogbnVtYmVyfX0gbWFyZ2luXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBoZWlnaHRcbiAqIEBwcml2YXRlXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5fY2FsY3VsYXRlSGVpZ2h0ID0gZnVuY3Rpb24gKG1hcmdpbikge1xuICAvLyByZWNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBncm91cFxuICB2YXIgaGVpZ2h0O1xuICB2YXIgdmlzaWJsZUl0ZW1zID0gdGhpcy52aXNpYmxlSXRlbXM7XG4gIC8vdmFyIHZpc2libGVTdWJncm91cHMgPSBbXTtcbiAgLy90aGlzLnZpc2libGVTdWJncm91cHMgPSAwO1xuICB0aGlzLnJlc2V0U3ViZ3JvdXBzKCk7XG4gIHZhciBtZSA9IHRoaXM7XG4gIGlmICh2aXNpYmxlSXRlbXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBtaW4gPSB2aXNpYmxlSXRlbXNbMF0udG9wO1xuICAgIHZhciBtYXggPSB2aXNpYmxlSXRlbXNbMF0udG9wICsgdmlzaWJsZUl0ZW1zWzBdLmhlaWdodDtcbiAgICB1dGlsLmZvckVhY2godmlzaWJsZUl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgbWluID0gTWF0aC5taW4obWluLCBpdGVtLnRvcCk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIChpdGVtLnRvcCArIGl0ZW0uaGVpZ2h0KSk7XG4gICAgICBpZiAoaXRlbS5kYXRhLnN1Ymdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWUuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0uaGVpZ2h0ID0gTWF0aC5tYXgobWUuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0uaGVpZ2h0LGl0ZW0uaGVpZ2h0KTtcbiAgICAgICAgbWUuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0udmlzaWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG1pbiA+IG1hcmdpbi5heGlzKSB7XG4gICAgICAvLyB0aGVyZSBpcyBhbiBlbXB0eSBnYXAgYmV0d2VlbiB0aGUgbG93ZXN0IGl0ZW0gYW5kIHRoZSBheGlzXG4gICAgICB2YXIgb2Zmc2V0ID0gbWluIC0gbWFyZ2luLmF4aXM7XG4gICAgICBtYXggLT0gb2Zmc2V0O1xuICAgICAgdXRpbC5mb3JFYWNoKHZpc2libGVJdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaXRlbS50b3AgLT0gb2Zmc2V0O1xuICAgICAgfSk7XG4gICAgfVxuICAgIGhlaWdodCA9IG1heCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsIC8gMjtcbiAgfVxuICBlbHNlIHtcbiAgICBoZWlnaHQgPSAwO1xuICB9XG4gIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgdGhpcy5wcm9wcy5sYWJlbC5oZWlnaHQpO1xuXG4gIHJldHVybiBoZWlnaHQ7XG59O1xuXG4vKipcbiAqIFNob3cgdGhpcyBncm91cDogYXR0YWNoIHRvIHRoZSBET01cbiAqL1xuR3JvdXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRvbS5sYWJlbC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5pdGVtU2V0LmRvbS5sYWJlbFNldC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5sYWJlbCk7XG4gIH1cblxuICBpZiAoIXRoaXMuZG9tLmZvcmVncm91bmQucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuaXRlbVNldC5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5mb3JlZ3JvdW5kKTtcbiAgfVxuXG4gIGlmICghdGhpcy5kb20uYmFja2dyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5pdGVtU2V0LmRvbS5iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKHRoaXMuZG9tLmJhY2tncm91bmQpO1xuICB9XG5cbiAgaWYgKCF0aGlzLmRvbS5heGlzLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLml0ZW1TZXQuZG9tLmF4aXMuYXBwZW5kQ2hpbGQodGhpcy5kb20uYXhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogSGlkZSB0aGlzIGdyb3VwOiByZW1vdmUgZnJvbSB0aGUgRE9NXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsYWJlbCA9IHRoaXMuZG9tLmxhYmVsO1xuICBpZiAobGFiZWwucGFyZW50Tm9kZSkge1xuICAgIGxhYmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGFiZWwpO1xuICB9XG5cbiAgdmFyIGZvcmVncm91bmQgPSB0aGlzLmRvbS5mb3JlZ3JvdW5kO1xuICBpZiAoZm9yZWdyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgZm9yZWdyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZvcmVncm91bmQpO1xuICB9XG5cbiAgdmFyIGJhY2tncm91bmQgPSB0aGlzLmRvbS5iYWNrZ3JvdW5kO1xuICBpZiAoYmFja2dyb3VuZC5wYXJlbnROb2RlKSB7XG4gICAgYmFja2dyb3VuZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJhY2tncm91bmQpO1xuICB9XG5cbiAgdmFyIGF4aXMgPSB0aGlzLmRvbS5heGlzO1xuICBpZiAoYXhpcy5wYXJlbnROb2RlKSB7XG4gICAgYXhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGF4aXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZCBhbiBpdGVtIHRvIHRoZSBncm91cFxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuaXRlbXNbaXRlbS5pZF0gPSBpdGVtO1xuICBpdGVtLnNldFBhcmVudCh0aGlzKTtcblxuICAvLyBhZGQgdG9cbiAgaWYgKGl0ZW0uZGF0YS5zdWJncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdWJncm91cHNbaXRlbS5kYXRhLnN1Ymdyb3VwXSA9IHtoZWlnaHQ6MCwgdmlzaWJsZTogZmFsc2UsIGluZGV4OnRoaXMuc3ViZ3JvdXBJbmRleCwgaXRlbXM6IFtdfTtcbiAgICAgIHRoaXMuc3ViZ3JvdXBJbmRleCsrO1xuICAgIH1cbiAgICB0aGlzLnN1Ymdyb3Vwc1tpdGVtLmRhdGEuc3ViZ3JvdXBdLml0ZW1zLnB1c2goaXRlbSk7XG4gIH1cbiAgdGhpcy5vcmRlclN1Ymdyb3VwcygpO1xuXG4gIGlmICh0aGlzLnZpc2libGVJdGVtcy5pbmRleE9mKGl0ZW0pID09IC0xKSB7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5pdGVtU2V0LmJvZHkucmFuZ2U7IC8vIFRPRE86IG5vdCBuaWNlIGFjY2Vzc2luZyB0aGUgcmFuZ2UgbGlrZSB0aGlzXG4gICAgdGhpcy5fY2hlY2tJZlZpc2libGUoaXRlbSwgdGhpcy52aXNpYmxlSXRlbXMsIHJhbmdlKTtcbiAgfVxufTtcblxuR3JvdXAucHJvdG90eXBlLm9yZGVyU3ViZ3JvdXBzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN1Ymdyb3VwT3JkZXJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvcnRBcnJheSA9IFtdO1xuICAgIGlmICh0eXBlb2YgdGhpcy5zdWJncm91cE9yZGVyZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHRoaXMuc3ViZ3JvdXBzKSB7XG4gICAgICAgIHNvcnRBcnJheS5wdXNoKHtzdWJncm91cDogc3ViZ3JvdXAsIHNvcnRGaWVsZDogdGhpcy5zdWJncm91cHNbc3ViZ3JvdXBdLml0ZW1zWzBdLmRhdGFbdGhpcy5zdWJncm91cE9yZGVyZXJdfSlcbiAgICAgIH1cbiAgICAgIHNvcnRBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnNvcnRGaWVsZCAtIGIuc29ydEZpZWxkO1xuICAgICAgfSlcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuc3ViZ3JvdXBPcmRlcmVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHRoaXMuc3ViZ3JvdXBzKSB7XG4gICAgICAgIHNvcnRBcnJheS5wdXNoKHRoaXMuc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pdGVtc1swXS5kYXRhKTtcbiAgICAgIH1cbiAgICAgIHNvcnRBcnJheS5zb3J0KHRoaXMuc3ViZ3JvdXBPcmRlcmVyKTtcbiAgICB9XG5cbiAgICBpZiAoc29ydEFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc29ydEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc3ViZ3JvdXBzW3NvcnRBcnJheVtpXS5zdWJncm91cF0uaW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuR3JvdXAucHJvdG90eXBlLnJlc2V0U3ViZ3JvdXBzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIHN1Ymdyb3VwIGluIHRoaXMuc3ViZ3JvdXBzKSB7XG4gICAgaWYgKHRoaXMuc3ViZ3JvdXBzLmhhc093blByb3BlcnR5KHN1Ymdyb3VwKSkge1xuICAgICAgdGhpcy5zdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgZ3JvdXBcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICovXG5Hcm91cC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBkZWxldGUgdGhpcy5pdGVtc1tpdGVtLmlkXTtcbiAgaXRlbS5zZXRQYXJlbnQobnVsbCk7XG5cbiAgLy8gcmVtb3ZlIGZyb20gdmlzaWJsZSBpdGVtc1xuICB2YXIgaW5kZXggPSB0aGlzLnZpc2libGVJdGVtcy5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaW5kZXggIT0gLTEpIHRoaXMudmlzaWJsZUl0ZW1zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgaWYoaXRlbS5kYXRhLnN1Ymdyb3VwICE9PSB1bmRlZmluZWQpe1xuICAgIHZhciBzdWJncm91cCA9IHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF07XG4gICAgaWYgKHN1Ymdyb3VwKXtcbiAgICAgIHZhciBpdGVtSW5kZXggPSBzdWJncm91cC5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgc3ViZ3JvdXAuaXRlbXMuc3BsaWNlKGl0ZW1JbmRleCwxKTtcbiAgICAgIGlmICghc3ViZ3JvdXAuaXRlbXMubGVuZ3RoKXtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3ViZ3JvdXBzW2l0ZW0uZGF0YS5zdWJncm91cF07XG4gICAgICAgIHRoaXMuc3ViZ3JvdXBJbmRleC0tO1xuICAgICAgfVxuICAgICAgdGhpcy5vcmRlclN1Ymdyb3VwcygpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgRGF0YVNldFxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5yZW1vdmVGcm9tRGF0YVNldCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5pdGVtU2V0LnJlbW92ZUl0ZW0oaXRlbS5pZCk7XG59O1xuXG5cbi8qKlxuICogUmVvcmRlciB0aGUgaXRlbXNcbiAqL1xuR3JvdXAucHJvdG90eXBlLm9yZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLml0ZW1zKTtcbiAgdmFyIHN0YXJ0QXJyYXkgPSBbXTtcbiAgdmFyIGVuZEFycmF5ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJheVtpXS5kYXRhLmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmRBcnJheS5wdXNoKGFycmF5W2ldKTtcbiAgICB9XG4gICAgc3RhcnRBcnJheS5wdXNoKGFycmF5W2ldKTtcbiAgfVxuICB0aGlzLm9yZGVyZWRJdGVtcyA9IHtcbiAgICBieVN0YXJ0OiBzdGFydEFycmF5LFxuICAgIGJ5RW5kOiBlbmRBcnJheVxuICB9O1xuXG4gIHN0YWNrLm9yZGVyQnlTdGFydCh0aGlzLm9yZGVyZWRJdGVtcy5ieVN0YXJ0KTtcbiAgc3RhY2sub3JkZXJCeUVuZCh0aGlzLm9yZGVyZWRJdGVtcy5ieUVuZCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSB2aXNpYmxlIGl0ZW1zXG4gKiBAcGFyYW0ge3tieVN0YXJ0OiBJdGVtW10sIGJ5RW5kOiBJdGVtW119fSBvcmRlcmVkSXRlbXMgICBBbGwgaXRlbXMgb3JkZXJlZCBieSBzdGFydCBkYXRlIGFuZCBieSBlbmQgZGF0ZVxuICogQHBhcmFtIHtJdGVtW119IHZpc2libGVJdGVtcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHByZXZpb3VzbHkgdmlzaWJsZSBpdGVtcy5cbiAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgICAgICAgICAgICAgIFZpc2libGUgcmFuZ2VcbiAqIEByZXR1cm4ge0l0ZW1bXX0gdmlzaWJsZUl0ZW1zICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBuZXcgdmlzaWJsZSBpdGVtcy5cbiAqIEBwcml2YXRlXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5fdXBkYXRlVmlzaWJsZUl0ZW1zID0gZnVuY3Rpb24ob3JkZXJlZEl0ZW1zLCBvbGRWaXNpYmxlSXRlbXMsIHJhbmdlKSB7XG4gIHZhciB2aXNpYmxlSXRlbXMgPSBbXTtcbiAgdmFyIHZpc2libGVJdGVtc0xvb2t1cCA9IHt9OyAvLyB3ZSBrZWVwIHRoaXMgdG8gcXVpY2tseSBsb29rIHVwIGlmIGFuIGl0ZW0gYWxyZWFkeSBleGlzdHMgaW4gdGhlIGxpc3Qgd2l0aG91dCB1c2luZyBpbmRleE9mIG9uIHZpc2libGVJdGVtc1xuICB2YXIgaW50ZXJ2YWwgPSAocmFuZ2UuZW5kIC0gcmFuZ2Uuc3RhcnQpIC8gNDtcbiAgdmFyIGxvd2VyQm91bmQgPSByYW5nZS5zdGFydCAtIGludGVydmFsO1xuICB2YXIgdXBwZXJCb3VuZCA9IHJhbmdlLmVuZCArIGludGVydmFsO1xuICB2YXIgaXRlbSwgaTtcblxuICAvLyB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZG8gdGhlIGJpbmFyeSBzZWFyY2guXG4gIHZhciBzZWFyY2hGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICAgICAgKHZhbHVlIDwgbG93ZXJCb3VuZCkgIHtyZXR1cm4gLTE7fVxuICAgIGVsc2UgaWYgKHZhbHVlIDw9IHVwcGVyQm91bmQpIHtyZXR1cm4gIDA7fVxuICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZXR1cm4gIDE7fVxuICB9XG5cbiAgLy8gZmlyc3QgY2hlY2sgaWYgdGhlIGl0ZW1zIHRoYXQgd2VyZSBpbiB2aWV3IHByZXZpb3VzbHkgYXJlIHN0aWxsIGluIHZpZXcuXG4gIC8vIElNUE9SVEFOVDogdGhpcyBoYW5kbGVzIHRoZSBjYXNlIGZvciB0aGUgaXRlbXMgd2l0aCBzdGFydGRhdGUgYmVmb3JlIHRoZSB3aW5kb3cgYW5kIGVuZGRhdGUgYWZ0ZXIgdGhlIHdpbmRvdyFcbiAgLy8gYWxzbyBjbGVhbnMgdXAgaW52aXNpYmxlIGl0ZW1zLlxuICBpZiAob2xkVmlzaWJsZUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2xkVmlzaWJsZUl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jaGVja0lmVmlzaWJsZVdpdGhSZWZlcmVuY2Uob2xkVmlzaWJsZUl0ZW1zW2ldLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgcmFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHdlIGRvIGEgYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGl0ZW1zIHRoYXQgaGF2ZSBvbmx5IHN0YXJ0IHZhbHVlcy5cbiAgdmFyIGluaXRpYWxQb3NCeVN0YXJ0ID0gdXRpbC5iaW5hcnlTZWFyY2hDdXN0b20ob3JkZXJlZEl0ZW1zLmJ5U3RhcnQsIHNlYXJjaEZ1bmN0aW9uLCAnZGF0YScsJ3N0YXJ0Jyk7XG5cbiAgLy8gdHJhY2UgdGhlIHZpc2libGUgaXRlbXMgZnJvbSB0aGUgaW5pdGFsIHN0YXJ0IHBvcyBib3RoIHdheXMgdW50aWwgYW4gaW52aXNpYmxlIGl0ZW0gaXMgZm91bmQsIHdlIG9ubHkgbG9vayBhdCB0aGUgc3RhcnQgdmFsdWVzLlxuICB0aGlzLl90cmFjZVZpc2libGUoaW5pdGlhbFBvc0J5U3RhcnQsIG9yZGVyZWRJdGVtcy5ieVN0YXJ0LCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gKGl0ZW0uZGF0YS5zdGFydCA8IGxvd2VyQm91bmQgfHwgaXRlbS5kYXRhLnN0YXJ0ID4gdXBwZXJCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIGlmIHRoZSB3aW5kb3cgaGFzIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseSB3aXRob3V0IG92ZXJsYXBwaW5nIHRoZSBvbGQgd2luZG93LCB0aGUgcmFuZ2VkIGl0ZW1zIHdpdGggc3RhcnQgPCBsb3dlckJvdW5kIGFuZCBlbmQgPiB1cHBlcmJvdW5kIGFyZSBub3Qgc2hvd24uXG4gIC8vIFdlIHRoZXJlZm9yZSBoYXZlIHRvIGJydXRlIGZvcmNlIGNoZWNrIGFsbCBpdGVtcyBpbiB0aGUgYnlFbmQgbGlzdFxuICBpZiAodGhpcy5jaGVja1JhbmdlZEl0ZW1zID09IHRydWUpIHtcbiAgICB0aGlzLmNoZWNrUmFuZ2VkSXRlbXMgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3JkZXJlZEl0ZW1zLmJ5RW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9jaGVja0lmVmlzaWJsZVdpdGhSZWZlcmVuY2Uob3JkZXJlZEl0ZW1zLmJ5RW5kW2ldLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgcmFuZ2UpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyB3ZSBkbyBhIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpdGVtcyB0aGF0IGhhdmUgZGVmaW5lZCBlbmQgdGltZXMuXG4gICAgdmFyIGluaXRpYWxQb3NCeUVuZCA9IHV0aWwuYmluYXJ5U2VhcmNoQ3VzdG9tKG9yZGVyZWRJdGVtcy5ieUVuZCwgc2VhcmNoRnVuY3Rpb24sICdkYXRhJywnZW5kJyk7XG5cbiAgICAvLyB0cmFjZSB0aGUgdmlzaWJsZSBpdGVtcyBmcm9tIHRoZSBpbml0YWwgc3RhcnQgcG9zIGJvdGggd2F5cyB1bnRpbCBhbiBpbnZpc2libGUgaXRlbSBpcyBmb3VuZCwgd2Ugb25seSBsb29rIGF0IHRoZSBlbmQgdmFsdWVzLlxuICAgIHRoaXMuX3RyYWNlVmlzaWJsZShpbml0aWFsUG9zQnlFbmQsIG9yZGVyZWRJdGVtcy5ieUVuZCwgdmlzaWJsZUl0ZW1zLCB2aXNpYmxlSXRlbXNMb29rdXAsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gKGl0ZW0uZGF0YS5lbmQgPCBsb3dlckJvdW5kIHx8IGl0ZW0uZGF0YS5lbmQgPiB1cHBlckJvdW5kKTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLy8gZmluYWxseSwgd2UgcmVwb3NpdGlvbiBhbGwgdGhlIHZpc2libGUgaXRlbXMuXG4gIGZvciAoaSA9IDA7IGkgPCB2aXNpYmxlSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICBpdGVtID0gdmlzaWJsZUl0ZW1zW2ldO1xuICAgIGlmICghaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uc2hvdygpO1xuICAgIC8vIHJlcG9zaXRpb24gaXRlbSBob3Jpem9udGFsbHlcbiAgICBpdGVtLnJlcG9zaXRpb25YKCk7XG4gIH1cblxuICAvLyBkZWJ1Z1xuICAvL2NvbnNvbGUubG9nKFwibmV3IGxpbmVcIilcbiAgLy9pZiAodGhpcy5ncm91cElkID09IG51bGwpIHtcbiAgLy8gIGZvciAoaSA9IDA7IGkgPCBvcmRlcmVkSXRlbXMuYnlTdGFydC5sZW5ndGg7IGkrKykge1xuICAvLyAgICBpdGVtID0gb3JkZXJlZEl0ZW1zLmJ5U3RhcnRbaV0uZGF0YTtcbiAgLy8gICAgY29uc29sZS5sb2coJ3N0YXJ0JyxpLGluaXRpYWxQb3NCeVN0YXJ0LCBpdGVtLnN0YXJ0LnZhbHVlT2YoKSwgaXRlbS5jb250ZW50LCBpdGVtLnN0YXJ0ID49IGxvd2VyQm91bmQgJiYgaXRlbS5zdGFydCA8PSB1cHBlckJvdW5kLGkgPT0gaW5pdGlhbFBvc0J5U3RhcnQgPyBcIjwtLS0tLS0tLS0tLS0tLS0tLS0tIEhFUkVFRUVcIiA6IFwiXCIpXG4gIC8vICB9XG4gIC8vICBmb3IgKGkgPSAwOyBpIDwgb3JkZXJlZEl0ZW1zLmJ5RW5kLmxlbmd0aDsgaSsrKSB7XG4gIC8vICAgIGl0ZW0gPSBvcmRlcmVkSXRlbXMuYnlFbmRbaV0uZGF0YTtcbiAgLy8gICAgY29uc29sZS5sb2coJ3JhbmdlRW5kJyxpLGluaXRpYWxQb3NCeUVuZCwgaXRlbS5lbmQudmFsdWVPZigpLCBpdGVtLmNvbnRlbnQsIGl0ZW0uZW5kID49IHJhbmdlLnN0YXJ0ICYmIGl0ZW0uZW5kIDw9IHJhbmdlLmVuZCxpID09IGluaXRpYWxQb3NCeUVuZCA/IFwiPC0tLS0tLS0tLS0tLS0tLS0tLS0gSEVSRUVFRVwiIDogXCJcIilcbiAgLy8gIH1cbiAgLy99XG5cbiAgcmV0dXJuIHZpc2libGVJdGVtcztcbn07XG5cbkdyb3VwLnByb3RvdHlwZS5fdHJhY2VWaXNpYmxlID0gZnVuY3Rpb24gKGluaXRpYWxQb3MsIGl0ZW1zLCB2aXNpYmxlSXRlbXMsIHZpc2libGVJdGVtc0xvb2t1cCwgYnJlYWtDb25kaXRpb24pIHtcbiAgdmFyIGl0ZW07XG4gIHZhciBpO1xuXG4gIGlmIChpbml0aWFsUG9zICE9IC0xKSB7XG4gICAgZm9yIChpID0gaW5pdGlhbFBvczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGlmIChicmVha0NvbmRpdGlvbihpdGVtKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodmlzaWJsZUl0ZW1zTG9va3VwW2l0ZW0uaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgICAgIHZpc2libGVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gaW5pdGlhbFBvcyArIDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgaWYgKGJyZWFrQ29uZGl0aW9uKGl0ZW0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZpc2libGVJdGVtc0xvb2t1cFtpdGVtLmlkXSA9IHRydWU7XG4gICAgICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBzaW1pbGFyIHRvIHRoZSBfY2hlY2tJZkludmlzaWJsZSgpIGJ1dCBpdCBkb2VzIG5vdFxuICogcmV0dXJuIGJvb2xlYW5zLCBoaWRlcyB0aGUgaXRlbSBpZiBpdCBzaG91bGQgbm90IGJlIHNlZW4gYW5kIGFsd2F5cyBhZGRzIHRvXG4gKiB0aGUgdmlzaWJsZUl0ZW1zLlxuICogdGhpcyBvbmUgaXMgZm9yIGJydXRlIGZvcmNpbmcgYW5kIGhpZGluZy5cbiAqXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7QXJyYXl9IHZpc2libGVJdGVtc1xuICogQHBhcmFtIHt7c3RhcnQ6bnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2VcbiAqIEBwcml2YXRlXG4gKi9cbkdyb3VwLnByb3RvdHlwZS5fY2hlY2tJZlZpc2libGUgPSBmdW5jdGlvbihpdGVtLCB2aXNpYmxlSXRlbXMsIHJhbmdlKSB7XG4gICAgaWYgKGl0ZW0uaXNWaXNpYmxlKHJhbmdlKSkge1xuICAgICAgaWYgKCFpdGVtLmRpc3BsYXllZCkgaXRlbS5zaG93KCk7XG4gICAgICAvLyByZXBvc2l0aW9uIGl0ZW0gaG9yaXpvbnRhbGx5XG4gICAgICBpdGVtLnJlcG9zaXRpb25YKCk7XG4gICAgICB2aXNpYmxlSXRlbXMucHVzaChpdGVtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaXRlbS5kaXNwbGF5ZWQpIGl0ZW0uaGlkZSgpO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiB0aGlzIGZ1bmN0aW9uIGlzIHZlcnkgc2ltaWxhciB0byB0aGUgX2NoZWNrSWZJbnZpc2libGUoKSBidXQgaXQgZG9lcyBub3RcbiAqIHJldHVybiBib29sZWFucywgaGlkZXMgdGhlIGl0ZW0gaWYgaXQgc2hvdWxkIG5vdCBiZSBzZWVuIGFuZCBhbHdheXMgYWRkcyB0b1xuICogdGhlIHZpc2libGVJdGVtcy5cbiAqIHRoaXMgb25lIGlzIGZvciBicnV0ZSBmb3JjaW5nIGFuZCBoaWRpbmcuXG4gKlxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge0FycmF5fSB2aXNpYmxlSXRlbXNcbiAqIEBwYXJhbSB7e3N0YXJ0Om51bWJlciwgZW5kOm51bWJlcn19IHJhbmdlXG4gKiBAcHJpdmF0ZVxuICovXG5Hcm91cC5wcm90b3R5cGUuX2NoZWNrSWZWaXNpYmxlV2l0aFJlZmVyZW5jZSA9IGZ1bmN0aW9uKGl0ZW0sIHZpc2libGVJdGVtcywgdmlzaWJsZUl0ZW1zTG9va3VwLCByYW5nZSkge1xuICBpZiAoaXRlbS5pc1Zpc2libGUocmFuZ2UpKSB7XG4gICAgaWYgKHZpc2libGVJdGVtc0xvb2t1cFtpdGVtLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2aXNpYmxlSXRlbXNMb29rdXBbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgdmlzaWJsZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmIChpdGVtLmRpc3BsYXllZCkgaXRlbS5oaWRlKCk7XG4gIH1cbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwO1xuIl19
},{"../../util":46,"../Stack":29,"./item/RangeItem":43}],37:[function(require,module,exports){
'use strict';

var Hammer = require('../../module/hammer');
var util = require('../../util');
var DataSet = require('../../DataSet');
var DataView = require('../../DataView');
var TimeStep = require('../TimeStep');
var Component = require('./Component');
var Group = require('./Group');
var BackgroundGroup = require('./BackgroundGroup');
var BoxItem = require('./item/BoxItem');
var PointItem = require('./item/PointItem');
var RangeItem = require('./item/RangeItem');
var BackgroundItem = require('./item/BackgroundItem');

var UNGROUPED = '__ungrouped__'; // reserved group id for ungrouped items
var BACKGROUND = '__background__'; // reserved group id for background items without group

/**
 * An ItemSet holds a set of items and ranges which can be displayed in a
 * range. The width is determined by the parent of the ItemSet, and the height
 * is determined by the size of the items.
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
 * @param {Object} [options]      See ItemSet.setOptions for the available options.
 * @constructor ItemSet
 * @extends Component
 */
function ItemSet(body, options) {
  this.body = body;

  this.defaultOptions = {
    type: null, // 'box', 'point', 'range', 'background'
    orientation: {
      item: 'bottom' // item orientation: 'top' or 'bottom'
    },
    align: 'auto', // alignment of box items
    stack: true,
    groupOrderSwap: function groupOrderSwap(fromGroup, toGroup, groups) {
      var targetOrder = toGroup.order;
      toGroup.order = fromGroup.order;
      fromGroup.order = targetOrder;
    },
    groupOrder: 'order',

    selectable: true,
    multiselect: false,

    editable: {
      updateTime: false,
      updateGroup: false,
      add: false,
      remove: false
    },

    groupEditable: {
      order: false,
      add: false,
      remove: false
    },

    snap: TimeStep.snap,

    onAdd: function onAdd(item, callback) {
      callback(item);
    },
    onUpdate: function onUpdate(item, callback) {
      callback(item);
    },
    onMove: function onMove(item, callback) {
      callback(item);
    },
    onRemove: function onRemove(item, callback) {
      callback(item);
    },
    onMoving: function onMoving(item, callback) {
      callback(item);
    },
    onAddGroup: function onAddGroup(item, callback) {
      callback(item);
    },
    onMoveGroup: function onMoveGroup(item, callback) {
      callback(item);
    },
    onRemoveGroup: function onRemoveGroup(item, callback) {
      callback(item);
    },

    margin: {
      item: {
        horizontal: 10,
        vertical: 10
      },
      axis: 20
    }
  };

  // options is shared by this ItemSet and all its items
  this.options = util.extend({}, this.defaultOptions);

  // options for getting items from the DataSet with the correct type
  this.itemOptions = {
    type: { start: 'Date', end: 'Date' }
  };

  this.conversion = {
    toScreen: body.util.toScreen,
    toTime: body.util.toTime
  };
  this.dom = {};
  this.props = {};
  this.hammer = null;

  var me = this;
  this.itemsData = null; // DataSet
  this.groupsData = null; // DataSet

  // listeners for the DataSet of the items
  this.itemListeners = {
    'add': function add(event, params, senderId) {
      me._onAdd(params.items);
    },
    'update': function update(event, params, senderId) {
      me._onUpdate(params.items);
    },
    'remove': function remove(event, params, senderId) {
      me._onRemove(params.items);
    }
  };

  // listeners for the DataSet of the groups
  this.groupListeners = {
    'add': function add(event, params, senderId) {
      me._onAddGroups(params.items);
    },
    'update': function update(event, params, senderId) {
      me._onUpdateGroups(params.items);
    },
    'remove': function remove(event, params, senderId) {
      me._onRemoveGroups(params.items);
    }
  };

  this.items = {}; // object with an Item for every data item
  this.groups = {}; // Group object for every group
  this.groupIds = [];

  this.selection = []; // list with the ids of all selected nodes
  this.stackDirty = true; // if true, all items will be restacked on next redraw

  this.touchParams = {}; // stores properties while dragging
  this.groupTouchParams = {};
  // create the HTML DOM

  this._create();

  this.setOptions(options);
}

ItemSet.prototype = new Component();

// available item types will be registered here
ItemSet.types = {
  background: BackgroundItem,
  box: BoxItem,
  range: RangeItem,
  point: PointItem
};

/**
 * Create the HTML DOM for the ItemSet
 */
ItemSet.prototype._create = function () {
  var frame = document.createElement('div');
  frame.className = 'vis-itemset';
  frame['timeline-itemset'] = this;
  this.dom.frame = frame;

  // create background panel
  var background = document.createElement('div');
  background.className = 'vis-background';
  frame.appendChild(background);
  this.dom.background = background;

  // create foreground panel
  var foreground = document.createElement('div');
  foreground.className = 'vis-foreground';
  frame.appendChild(foreground);
  this.dom.foreground = foreground;

  // create axis panel
  var axis = document.createElement('div');
  axis.className = 'vis-axis';
  this.dom.axis = axis;

  // create labelset
  var labelSet = document.createElement('div');
  labelSet.className = 'vis-labelset';
  this.dom.labelSet = labelSet;

  // create ungrouped Group
  this._updateUngrouped();

  // create background Group
  var backgroundGroup = new BackgroundGroup(BACKGROUND, null, this);
  backgroundGroup.show();
  this.groups[BACKGROUND] = backgroundGroup;

  // attach event listeners
  // Note: we bind to the centerContainer for the case where the height
  //       of the center container is larger than of the ItemSet, so we
  //       can click in the empty area to create a new item or deselect an item.
  this.hammer = new Hammer(this.body.dom.centerContainer);

  // drag items when selected
  this.hammer.on('hammer.input', (function (event) {
    if (event.isFirst) {
      this._onTouch(event);
    }
  }).bind(this));
  this.hammer.on('panstart', this._onDragStart.bind(this));
  this.hammer.on('panmove', this._onDrag.bind(this));
  this.hammer.on('panend', this._onDragEnd.bind(this));
  this.hammer.get('pan').set({ threshold: 5, direction: 30 }); // 30 is ALL_DIRECTIONS in hammer.

  // single select (or unselect) when tapping an item
  this.hammer.on('tap', this._onSelectItem.bind(this));

  // multi select when holding mouse/touch, or on ctrl+click
  this.hammer.on('press', this._onMultiSelectItem.bind(this));

  // add item on doubletap
  this.hammer.on('doubletap', this._onAddItem.bind(this));

  this.groupHammer = new Hammer(this.body.dom.leftContainer);
  this.groupHammer.on('panstart', this._onGroupDragStart.bind(this));
  this.groupHammer.on('panmove', this._onGroupDrag.bind(this));
  this.groupHammer.on('panend', this._onGroupDragEnd.bind(this));
  this.groupHammer.get('pan').set({ threshold: 5, direction: 30 });

  // attach to the DOM
  this.show();
};

/**
 * Set options for the ItemSet. Existing options will be extended/overwritten.
 * @param {Object} [options] The following options are available:
 *                           {String} type
 *                              Default type for the items. Choose from 'box'
 *                              (default), 'point', 'range', or 'background'.
 *                              The default style can be overwritten by
 *                              individual items.
 *                           {String} align
 *                              Alignment for the items, only applicable for
 *                              BoxItem. Choose 'center' (default), 'left', or
 *                              'right'.
 *                           {String} orientation.item
 *                              Orientation of the item set. Choose 'top' or
 *                              'bottom' (default).
 *                           {Function} groupOrder
 *                              A sorting function for ordering groups
 *                           {Boolean} stack
 *                              If true (default), items will be stacked on
 *                              top of each other.
 *                           {Number} margin.axis
 *                              Margin between the axis and the items in pixels.
 *                              Default is 20.
 *                           {Number} margin.item.horizontal
 *                              Horizontal margin between items in pixels.
 *                              Default is 10.
 *                           {Number} margin.item.vertical
 *                              Vertical Margin between items in pixels.
 *                              Default is 10.
 *                           {Number} margin.item
 *                              Margin between items in pixels in both horizontal
 *                              and vertical direction. Default is 10.
 *                           {Number} margin
 *                              Set margin for both axis and items in pixels.
 *                           {Boolean} selectable
 *                              If true (default), items can be selected.
 *                           {Boolean} multiselect
 *                              If true, multiple items can be selected.
 *                              False by default.
 *                           {Boolean} editable
 *                              Set all editable options to true or false
 *                           {Boolean} editable.updateTime
 *                              Allow dragging an item to an other moment in time
 *                           {Boolean} editable.updateGroup
 *                              Allow dragging an item to an other group
 *                           {Boolean} editable.add
 *                              Allow creating new items on double tap
 *                           {Boolean} editable.remove
 *                              Allow removing items by clicking the delete button
 *                              top right of a selected item.
 *                           {Function(item: Item, callback: Function)} onAdd
 *                              Callback function triggered when an item is about to be added:
 *                              when the user double taps an empty space in the Timeline.
 *                           {Function(item: Item, callback: Function)} onUpdate
 *                              Callback function fired when an item is about to be updated.
 *                              This function typically has to show a dialog where the user
 *                              change the item. If not implemented, nothing happens.
 *                           {Function(item: Item, callback: Function)} onMove
 *                              Fired when an item has been moved. If not implemented,
 *                              the move action will be accepted.
 *                           {Function(item: Item, callback: Function)} onRemove
 *                              Fired when an item is about to be deleted.
 *                              If not implemented, the item will be always removed.
 */
ItemSet.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    var fields = ['type', 'align', 'order', 'stack', 'selectable', 'multiselect', 'groupOrder', 'dataAttributes', 'template', 'groupTemplate', 'hide', 'snap', 'groupOrderSwap'];
    util.selectiveExtend(fields, this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation.item = options.orientation === 'top' ? 'top' : 'bottom';
      } else if (typeof options.orientation === 'object' && 'item' in options.orientation) {
        this.options.orientation.item = options.orientation.item;
      }
    }

    if ('margin' in options) {
      if (typeof options.margin === 'number') {
        this.options.margin.axis = options.margin;
        this.options.margin.item.horizontal = options.margin;
        this.options.margin.item.vertical = options.margin;
      } else if (typeof options.margin === 'object') {
        util.selectiveExtend(['axis'], this.options.margin, options.margin);
        if ('item' in options.margin) {
          if (typeof options.margin.item === 'number') {
            this.options.margin.item.horizontal = options.margin.item;
            this.options.margin.item.vertical = options.margin.item;
          } else if (typeof options.margin.item === 'object') {
            util.selectiveExtend(['horizontal', 'vertical'], this.options.margin.item, options.margin.item);
          }
        }
      }
    }

    if ('editable' in options) {
      if (typeof options.editable === 'boolean') {
        this.options.editable.updateTime = options.editable;
        this.options.editable.updateGroup = options.editable;
        this.options.editable.add = options.editable;
        this.options.editable.remove = options.editable;
      } else if (typeof options.editable === 'object') {
        util.selectiveExtend(['updateTime', 'updateGroup', 'add', 'remove'], this.options.editable, options.editable);
      }
    }

    if ('groupEditable' in options) {
      if (typeof options.groupEditable === 'boolean') {
        this.options.groupEditable.order = options.groupEditable;
        this.options.groupEditable.add = options.groupEditable;
        this.options.groupEditable.remove = options.groupEditable;
      } else if (typeof options.groupEditable === 'object') {
        util.selectiveExtend(['order', 'add', 'remove'], this.options.groupEditable, options.groupEditable);
      }
    }

    // callback functions
    var addCallback = (function (name) {
      var fn = options[name];
      if (fn) {
        if (!(fn instanceof Function)) {
          throw new Error('option ' + name + ' must be a function ' + name + '(item, callback)');
        }
        this.options[name] = fn;
      }
    }).bind(this);
    ['onAdd', 'onUpdate', 'onRemove', 'onMove', 'onMoving', 'onAddGroup', 'onMoveGroup', 'onRemoveGroup'].forEach(addCallback);

    // force the itemSet to refresh: options like orientation and margins may be changed
    this.markDirty();
  }
};

/**
 * Mark the ItemSet dirty so it will refresh everything with next redraw.
 * Optionally, all items can be marked as dirty and be refreshed.
 * @param {{refreshItems: boolean}} [options]
 */
ItemSet.prototype.markDirty = function (options) {
  this.groupIds = [];
  this.stackDirty = true;

  if (options && options.refreshItems) {
    util.forEach(this.items, function (item) {
      item.dirty = true;
      if (item.displayed) item.redraw();
    });
  }
};

/**
 * Destroy the ItemSet
 */
ItemSet.prototype.destroy = function () {
  this.hide();
  this.setItems(null);
  this.setGroups(null);

  this.hammer = null;

  this.body = null;
  this.conversion = null;
};

/**
 * Hide the component from the DOM
 */
ItemSet.prototype.hide = function () {
  // remove the frame containing the items
  if (this.dom.frame.parentNode) {
    this.dom.frame.parentNode.removeChild(this.dom.frame);
  }

  // remove the axis with dots
  if (this.dom.axis.parentNode) {
    this.dom.axis.parentNode.removeChild(this.dom.axis);
  }

  // remove the labelset containing all group labels
  if (this.dom.labelSet.parentNode) {
    this.dom.labelSet.parentNode.removeChild(this.dom.labelSet);
  }
};

/**
 * Show the component in the DOM (when not already visible).
 * @return {Boolean} changed
 */
ItemSet.prototype.show = function () {
  // show frame containing the items
  if (!this.dom.frame.parentNode) {
    this.body.dom.center.appendChild(this.dom.frame);
  }

  // show axis with dots
  if (!this.dom.axis.parentNode) {
    this.body.dom.backgroundVertical.appendChild(this.dom.axis);
  }

  // show labelset containing labels
  if (!this.dom.labelSet.parentNode) {
    this.body.dom.left.appendChild(this.dom.labelSet);
  }
};

/**
 * Set selected items by their id. Replaces the current selection
 * Unknown id's are silently ignored.
 * @param {string[] | string} [ids] An array with zero or more id's of the items to be
 *                                  selected, or a single item id. If ids is undefined
 *                                  or an empty array, all items will be unselected.
 */
ItemSet.prototype.setSelection = function (ids) {
  var i, ii, id, item;

  if (ids == undefined) ids = [];
  if (!Array.isArray(ids)) ids = [ids];

  // unselect currently selected items
  for (i = 0, ii = this.selection.length; i < ii; i++) {
    id = this.selection[i];
    item = this.items[id];
    if (item) item.unselect();
  }

  // select items
  this.selection = [];
  for (i = 0, ii = ids.length; i < ii; i++) {
    id = ids[i];
    item = this.items[id];
    if (item) {
      this.selection.push(id);
      item.select();
    }
  }
};

/**
 * Get the selected items by their id
 * @return {Array} ids  The ids of the selected items
 */
ItemSet.prototype.getSelection = function () {
  return this.selection.concat([]);
};

/**
 * Get the id's of the currently visible items.
 * @returns {Array} The ids of the visible items
 */
ItemSet.prototype.getVisibleItems = function () {
  var range = this.body.range.getRange();
  var left = this.body.util.toScreen(range.start);
  var right = this.body.util.toScreen(range.end);

  var ids = [];
  for (var groupId in this.groups) {
    if (this.groups.hasOwnProperty(groupId)) {
      var group = this.groups[groupId];
      var rawVisibleItems = group.visibleItems;

      // filter the "raw" set with visibleItems into a set which is really
      // visible by pixels
      for (var i = 0; i < rawVisibleItems.length; i++) {
        var item = rawVisibleItems[i];
        // TODO: also check whether visible vertically
        if (item.left < right && item.left + item.width > left) {
          ids.push(item.id);
        }
      }
    }
  }

  return ids;
};

/**
 * Deselect a selected item
 * @param {String | Number} id
 * @private
 */
ItemSet.prototype._deselect = function (id) {
  var selection = this.selection;
  for (var i = 0, ii = selection.length; i < ii; i++) {
    if (selection[i] == id) {
      // non-strict comparison!
      selection.splice(i, 1);
      break;
    }
  }
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
ItemSet.prototype.redraw = function () {
  var margin = this.options.margin,
      range = this.body.range,
      asSize = util.option.asSize,
      options = this.options,
      orientation = options.orientation.item,
      resized = false,
      frame = this.dom.frame;

  // recalculate absolute position (before redrawing groups)
  this.props.top = this.body.domProps.top.height + this.body.domProps.border.top;
  this.props.left = this.body.domProps.left.width + this.body.domProps.border.left;

  // update class name
  frame.className = 'vis-itemset';

  // reorder the groups (if needed)
  resized = this._orderGroups() || resized;

  // check whether zoomed (in that case we need to re-stack everything)
  // TODO: would be nicer to get this as a trigger from Range
  var visibleInterval = range.end - range.start;
  var zoomed = visibleInterval != this.lastVisibleInterval || this.props.width != this.props.lastWidth;
  if (zoomed) this.stackDirty = true;
  this.lastVisibleInterval = visibleInterval;
  this.props.lastWidth = this.props.width;

  var restack = this.stackDirty;
  var firstGroup = this._firstGroup();
  var firstMargin = {
    item: margin.item,
    axis: margin.axis
  };
  var nonFirstMargin = {
    item: margin.item,
    axis: margin.item.vertical / 2
  };
  var height = 0;
  var minHeight = margin.axis + margin.item.vertical;

  // redraw the background group
  this.groups[BACKGROUND].redraw(range, nonFirstMargin, restack);

  // redraw all regular groups
  util.forEach(this.groups, function (group) {
    var groupMargin = group == firstGroup ? firstMargin : nonFirstMargin;
    var groupResized = group.redraw(range, groupMargin, restack);
    resized = groupResized || resized;
    height += group.height;
  });
  height = Math.max(height, minHeight);
  this.stackDirty = false;

  // update frame height
  frame.style.height = asSize(height);

  // calculate actual size
  this.props.width = frame.offsetWidth;
  this.props.height = height;

  // reposition axis
  this.dom.axis.style.top = asSize(orientation == 'top' ? this.body.domProps.top.height + this.body.domProps.border.top : this.body.domProps.top.height + this.body.domProps.centerContainer.height);
  this.dom.axis.style.left = '0';

  // check if this component is resized
  resized = this._isResized() || resized;

  return resized;
};

/**
 * Get the first group, aligned with the axis
 * @return {Group | null} firstGroup
 * @private
 */
ItemSet.prototype._firstGroup = function () {
  var firstGroupIndex = this.options.orientation.item == 'top' ? 0 : this.groupIds.length - 1;
  var firstGroupId = this.groupIds[firstGroupIndex];
  var firstGroup = this.groups[firstGroupId] || this.groups[UNGROUPED];

  return firstGroup || null;
};

/**
 * Create or delete the group holding all ungrouped items. This group is used when
 * there are no groups specified.
 * @protected
 */
ItemSet.prototype._updateUngrouped = function () {
  var ungrouped = this.groups[UNGROUPED];
  var background = this.groups[BACKGROUND];
  var item, itemId;

  if (this.groupsData) {
    // remove the group holding all ungrouped items
    if (ungrouped) {
      ungrouped.hide();
      delete this.groups[UNGROUPED];

      for (itemId in this.items) {
        if (this.items.hasOwnProperty(itemId)) {
          item = this.items[itemId];
          item.parent && item.parent.remove(item);
          var groupId = this._getGroupId(item.data);
          var group = this.groups[groupId];
          group && group.add(item) || item.hide();
        }
      }
    }
  } else {
    // create a group holding all (unfiltered) items
    if (!ungrouped) {
      var id = null;
      var data = null;
      ungrouped = new Group(id, data, this);
      this.groups[UNGROUPED] = ungrouped;

      for (itemId in this.items) {
        if (this.items.hasOwnProperty(itemId)) {
          item = this.items[itemId];
          ungrouped.add(item);
        }
      }

      ungrouped.show();
    }
  }
};

/**
 * Get the element for the labelset
 * @return {HTMLElement} labelSet
 */
ItemSet.prototype.getLabelSet = function () {
  return this.dom.labelSet;
};

/**
 * Set items
 * @param {vis.DataSet | null} items
 */
ItemSet.prototype.setItems = function (items) {
  var me = this,
      ids,
      oldItemsData = this.itemsData;

  // replace the dataset
  if (!items) {
    this.itemsData = null;
  } else if (items instanceof DataSet || items instanceof DataView) {
    this.itemsData = items;
  } else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (oldItemsData) {
    // unsubscribe from old dataset
    util.forEach(this.itemListeners, function (callback, event) {
      oldItemsData.off(event, callback);
    });

    // remove all drawn items
    ids = oldItemsData.getIds();
    this._onRemove(ids);
  }

  if (this.itemsData) {
    // subscribe to new dataset
    var id = this.id;
    util.forEach(this.itemListeners, function (callback, event) {
      me.itemsData.on(event, callback, id);
    });

    // add all new items
    ids = this.itemsData.getIds();
    this._onAdd(ids);

    // update the group holding all ungrouped items
    this._updateUngrouped();
  }
};

/**
 * Get the current items
 * @returns {vis.DataSet | null}
 */
ItemSet.prototype.getItems = function () {
  return this.itemsData;
};

/**
 * Set groups
 * @param {vis.DataSet} groups
 */
ItemSet.prototype.setGroups = function (groups) {
  var me = this,
      ids;

  // unsubscribe from current dataset
  if (this.groupsData) {
    util.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.off(event, callback);
    });

    // remove all drawn groups
    ids = this.groupsData.getIds();
    this.groupsData = null;
    this._onRemoveGroups(ids); // note: this will cause a redraw
  }

  // replace the dataset
  if (!groups) {
    this.groupsData = null;
  } else if (groups instanceof DataSet || groups instanceof DataView) {
    this.groupsData = groups;
  } else {
    throw new TypeError('Data must be an instance of DataSet or DataView');
  }

  if (this.groupsData) {
    // subscribe to new dataset
    var id = this.id;
    util.forEach(this.groupListeners, function (callback, event) {
      me.groupsData.on(event, callback, id);
    });

    // draw all ms
    ids = this.groupsData.getIds();
    this._onAddGroups(ids);
  }

  // update the group holding all ungrouped items
  this._updateUngrouped();

  // update the order of all items in each group
  this._order();

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Get the current groups
 * @returns {vis.DataSet | null} groups
 */
ItemSet.prototype.getGroups = function () {
  return this.groupsData;
};

/**
 * Remove an item by its id
 * @param {String | Number} id
 */
ItemSet.prototype.removeItem = function (id) {
  var item = this.itemsData.get(id),
      dataset = this.itemsData.getDataSet();

  if (item) {
    // confirm deletion
    this.options.onRemove(item, function (item) {
      if (item) {
        // remove by id here, it is possible that an item has no id defined
        // itself, so better not delete by the item itself
        dataset.remove(id);
      }
    });
  }
};

/**
 * Get the time of an item based on it's data and options.type
 * @param {Object} itemData
 * @returns {string} Returns the type
 * @private
 */
ItemSet.prototype._getType = function (itemData) {
  return itemData.type || this.options.type || (itemData.end ? 'range' : 'box');
};

/**
 * Get the group id for an item
 * @param {Object} itemData
 * @returns {string} Returns the groupId
 * @private
 */
ItemSet.prototype._getGroupId = function (itemData) {
  var type = this._getType(itemData);
  if (type == 'background' && itemData.group == undefined) {
    return BACKGROUND;
  } else {
    return this.groupsData ? itemData.group : UNGROUPED;
  }
};

/**
 * Handle updated items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onUpdate = function (ids) {
  var me = this;

  ids.forEach((function (id) {
    var itemData = me.itemsData.get(id, me.itemOptions);
    var item = me.items[id];
    var type = me._getType(itemData);

    var constructor = ItemSet.types[type];
    var selected;

    if (item) {
      // update item
      if (!constructor || !(item instanceof constructor)) {
        // item type has changed, delete the item and recreate it
        selected = item.selected; // preserve selection of this item
        me._removeItem(item);
        item = null;
      } else {
        me._updateItem(item, itemData);
      }
    }

    if (!item) {
      // create item
      if (constructor) {
        item = new constructor(itemData, me.conversion, me.options);
        item.id = id; // TODO: not so nice setting id afterwards
        me._addItem(item);
        if (selected) {
          this.selection.push(id);
          item.select();
        }
      } else if (type == 'rangeoverflow') {
        // TODO: deprecated since version 2.1.0 (or 3.0.0?). cleanup some day
        throw new TypeError('Item type "rangeoverflow" is deprecated. Use css styling instead: ' + '.vis-item.vis-range .vis-item-content {overflow: visible;}');
      } else {
        throw new TypeError('Unknown item type "' + type + '"');
      }
    }
  }).bind(this));

  this._order();
  this.stackDirty = true; // force re-stacking of all items next redraw
  this.body.emitter.emit('change', { queue: true });
};

/**
 * Handle added items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onAdd = ItemSet.prototype._onUpdate;

/**
 * Handle removed items
 * @param {Number[]} ids
 * @protected
 */
ItemSet.prototype._onRemove = function (ids) {
  var count = 0;
  var me = this;
  ids.forEach(function (id) {
    var item = me.items[id];
    if (item) {
      count++;
      me._removeItem(item);
    }
  });

  if (count) {
    // update order
    this._order();
    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('change', { queue: true });
  }
};

/**
 * Update the order of item in all groups
 * @private
 */
ItemSet.prototype._order = function () {
  // reorder the items in all groups
  // TODO: optimization: only reorder groups affected by the changed items
  util.forEach(this.groups, function (group) {
    group.order();
  });
};

/**
 * Handle updated groups
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onUpdateGroups = function (ids) {
  this._onAddGroups(ids);
};

/**
 * Handle changed groups (added or updated)
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onAddGroups = function (ids) {
  var me = this;

  ids.forEach(function (id) {
    var groupData = me.groupsData.get(id);
    var group = me.groups[id];

    if (!group) {
      // check for reserved ids
      if (id == UNGROUPED || id == BACKGROUND) {
        throw new Error('Illegal group id. ' + id + ' is a reserved id.');
      }

      var groupOptions = Object.create(me.options);
      util.extend(groupOptions, {
        height: null
      });

      group = new Group(id, groupData, me);
      me.groups[id] = group;

      // add items with this groupId to the new group
      for (var itemId in me.items) {
        if (me.items.hasOwnProperty(itemId)) {
          var item = me.items[itemId];
          if (item.data.group == id) {
            group.add(item);
          }
        }
      }

      group.order();
      group.show();
    } else {
      // update group
      group.setData(groupData);
    }
  });

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Handle removed groups
 * @param {Number[]} ids
 * @private
 */
ItemSet.prototype._onRemoveGroups = function (ids) {
  var groups = this.groups;
  ids.forEach(function (id) {
    var group = groups[id];

    if (group) {
      group.hide();
      delete groups[id];
    }
  });

  this.markDirty();

  this.body.emitter.emit('change', { queue: true });
};

/**
 * Reorder the groups if needed
 * @return {boolean} changed
 * @private
 */
ItemSet.prototype._orderGroups = function () {
  if (this.groupsData) {
    // reorder the groups
    var groupIds = this.groupsData.getIds({
      order: this.options.groupOrder
    });

    var changed = !util.equalArray(groupIds, this.groupIds);
    if (changed) {
      // hide all groups, removes them from the DOM
      var groups = this.groups;
      groupIds.forEach(function (groupId) {
        groups[groupId].hide();
      });

      // show the groups again, attach them to the DOM in correct order
      groupIds.forEach(function (groupId) {
        groups[groupId].show();
      });

      this.groupIds = groupIds;
    }

    return changed;
  } else {
    return false;
  }
};

/**
 * Add a new item
 * @param {Item} item
 * @private
 */
ItemSet.prototype._addItem = function (item) {
  this.items[item.id] = item;

  // add to group
  var groupId = this._getGroupId(item.data);
  var group = this.groups[groupId];
  if (group) group.add(item);
};

/**
 * Update an existing item
 * @param {Item} item
 * @param {Object} itemData
 * @private
 */
ItemSet.prototype._updateItem = function (item, itemData) {
  var oldGroupId = item.data.group;
  var oldSubGroupId = item.data.subgroup;

  // update the items data (will redraw the item when displayed)
  item.setData(itemData);

  // update group
  if (oldGroupId != item.data.group || oldSubGroupId != item.data.subgroup) {
    var oldGroup = this.groups[oldGroupId];
    if (oldGroup) oldGroup.remove(item);

    var groupId = this._getGroupId(item.data);
    var group = this.groups[groupId];
    if (group) group.add(item);
  }
};

/**
 * Delete an item from the ItemSet: remove it from the DOM, from the map
 * with items, and from the map with visible items, and from the selection
 * @param {Item} item
 * @private
 */
ItemSet.prototype._removeItem = function (item) {
  // remove from DOM
  item.hide();

  // remove from items
  delete this.items[item.id];

  // remove from selection
  var index = this.selection.indexOf(item.id);
  if (index != -1) this.selection.splice(index, 1);

  // remove from group
  item.parent && item.parent.remove(item);
};

/**
 * Create an array containing all items being a range (having an end date)
 * @param array
 * @returns {Array}
 * @private
 */
ItemSet.prototype._constructByEndArray = function (array) {
  var endArray = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i] instanceof RangeItem) {
      endArray.push(array[i]);
    }
  }
  return endArray;
};

/**
 * Register the clicked item on touch, before dragStart is initiated.
 *
 * dragStart is initiated from a mousemove event, AFTER the mouse/touch is
 * already moving. Therefore, the mouse/touch can sometimes be above an other
 * DOM element than the item itself.
 *
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onTouch = function (event) {
  // store the touched item, used in _onDragStart
  this.touchParams.item = this.itemFromTarget(event);
  this.touchParams.dragLeftItem = event.target.dragLeftItem || false;
  this.touchParams.dragRightItem = event.target.dragRightItem || false;
  this.touchParams.itemProps = null;
};

/**
 * Given an group id, returns the index it has.
 *
 * @param {Number} groupID
 * @private
 */
ItemSet.prototype._getGroupIndex = function (groupId) {
  for (var i = 0; i < this.groupIds.length; i++) {
    if (groupId == this.groupIds[i]) return i;
  }
};

/**
 * Start dragging the selected events
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragStart = function (event) {
  var item = this.touchParams.item || null;
  var me = this;
  var props;

  if (item && item.selected) {

    if (!this.options.editable.updateTime && !this.options.editable.updateGroup && !item.editable) {
      return;
    }

    // override options.editable
    if (item.editable === false) {
      return;
    }

    var dragLeftItem = this.touchParams.dragLeftItem;
    var dragRightItem = this.touchParams.dragRightItem;

    if (dragLeftItem) {
      props = {
        item: dragLeftItem,
        initialX: event.center.x,
        dragLeft: true,
        data: this._cloneItemData(item.data)
      };

      this.touchParams.itemProps = [props];
    } else if (dragRightItem) {
      props = {
        item: dragRightItem,
        initialX: event.center.x,
        dragRight: true,
        data: this._cloneItemData(item.data)
      };

      this.touchParams.itemProps = [props];
    } else {
      this.touchParams.selectedItem = item;

      var baseGroupIndex = this._getGroupIndex(item.data.group);

      this.touchParams.itemProps = this.getSelection().map((function (id) {
        var item = me.items[id];
        var groupIndex = me._getGroupIndex(item.data.group);
        return {
          item: item,
          initialX: event.center.x,
          groupOffset: baseGroupIndex - groupIndex,
          data: this._cloneItemData(item.data)
        };
      }).bind(this));
    }

    event.stopPropagation();
  } else if (this.options.editable.add && (event.srcEvent.ctrlKey || event.srcEvent.metaKey)) {
    // create a new range item when dragging with ctrl key down
    this._onDragStartAddItem(event);
  }
};

/**
 * Start creating a new range item by dragging.
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragStartAddItem = function (event) {
  var snap = this.options.snap || null;
  var xAbs = util.getAbsoluteLeft(this.dom.frame);
  var x = event.center.x - xAbs - 10; // minus 10 to compensate for the drag starting as soon as you've moved 10px
  var time = this.body.util.toTime(x);
  var scale = this.body.util.getScale();
  var step = this.body.util.getStep();
  var start = snap ? snap(time, scale, step) : start;
  var end = start;

  var itemData = {
    type: 'range',
    start: start,
    end: end,
    content: 'new item'
  };

  var id = util.randomUUID();
  itemData[this.itemsData._fieldId] = id;

  var group = this.groupFromTarget(event);
  if (group) {
    itemData.group = group.groupId;
  }

  var newItem = new RangeItem(itemData, this.conversion, this.options);
  newItem.id = id; // TODO: not so nice setting id afterwards
  newItem.data = this._cloneItemData(itemData);
  this._addItem(newItem);

  var props = {
    item: newItem,
    dragRight: true,
    initialX: event.center.x,
    data: newItem.data
  };
  this.touchParams.itemProps = [props];

  event.stopPropagation();
};

/**
 * Drag selected items
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDrag = function (event) {
  if (this.touchParams.itemProps) {
    event.stopPropagation();

    var me = this;
    var snap = this.options.snap || null;
    var xOffset = this.body.dom.root.offsetLeft + this.body.domProps.left.width;
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();

    //only calculate the new group for the item that's actually dragged
    var selectedItem = this.touchParams.selectedItem;
    var updateGroupAllowed = me.options.editable.updateGroup;
    var newGroupBase = null;
    if (updateGroupAllowed && selectedItem) {
      if (selectedItem.data.group != undefined) {
        // drag from one group to another
        var group = me.groupFromTarget(event);
        if (group) {
          //we know the offset for all items, so the new group for all items
          //will be relative to this one.
          newGroupBase = this._getGroupIndex(group.groupId);
        }
      }
    }

    // move
    this.touchParams.itemProps.forEach((function (props) {
      var current = me.body.util.toTime(event.center.x - xOffset);
      var initial = me.body.util.toTime(props.initialX - xOffset);
      var offset = current - initial; // ms

      var itemData = this._cloneItemData(props.item.data); // clone the data
      if (props.item.editable === false) {
        return;
      }

      var updateTimeAllowed = me.options.editable.updateTime || props.item.editable === true;

      if (updateTimeAllowed) {
        if (props.dragLeft) {
          // drag left side of a range item
          if (itemData.start != undefined) {
            var initialStart = util.convert(props.data.start, 'Date');
            var start = new Date(initialStart.valueOf() + offset);
            // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
            itemData.start = snap ? snap(start, scale, step) : start;
          }
        } else if (props.dragRight) {
          // drag right side of a range item
          if (itemData.end != undefined) {
            var initialEnd = util.convert(props.data.end, 'Date');
            var end = new Date(initialEnd.valueOf() + offset);
            // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
            itemData.end = snap ? snap(end, scale, step) : end;
          }
        } else {
          // drag both start and end
          if (itemData.start != undefined) {
            var initialStart = util.convert(props.data.start, 'Date').valueOf();
            var start = new Date(initialStart + offset);

            if (itemData.end != undefined) {
              var initialEnd = util.convert(props.data.end, 'Date');
              var duration = initialEnd.valueOf() - initialStart.valueOf();

              // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
              itemData.start = snap ? snap(start, scale, step) : start;
              itemData.end = new Date(itemData.start.valueOf() + duration);
            } else {
              // TODO: pass a Moment instead of a Date to snap(). (Breaking change)
              itemData.start = snap ? snap(start, scale, step) : start;
            }
          }
        }
      }

      var updateGroupAllowed = me.options.editable.updateGroup || props.item.editable === true;

      if (updateGroupAllowed && !props.dragLeft && !props.dragRight && newGroupBase != null) {
        if (itemData.group != undefined) {
          var newOffset = newGroupBase - props.groupOffset;

          //make sure we stay in bounds
          newOffset = Math.max(0, newOffset);
          newOffset = Math.min(me.groupIds.length - 1, newOffset);

          itemData.group = me.groupIds[newOffset];
        }
      }

      // confirm moving the item
      itemData = this._cloneItemData(itemData); // convert start and end to the correct type
      me.options.onMoving(itemData, (function (itemData) {
        if (itemData) {
          props.item.setData(this._cloneItemData(itemData, 'Date'));
        }
      }).bind(this));
    }).bind(this));

    this.stackDirty = true; // force re-stacking of all items next redraw
    this.body.emitter.emit('change');
  }
};

/**
 * Move an item to another group
 * @param {Item} item
 * @param {String | Number} groupId
 * @private
 */
ItemSet.prototype._moveToGroup = function (item, groupId) {
  var group = this.groups[groupId];
  if (group && group.groupId != item.data.group) {
    var oldGroup = item.parent;
    oldGroup.remove(item);
    oldGroup.order();
    group.add(item);
    group.order();

    item.data.group = group.groupId;
  }
};

/**
 * End of dragging selected items
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onDragEnd = function (event) {
  if (this.touchParams.itemProps) {
    event.stopPropagation();

    var me = this;
    var dataset = this.itemsData.getDataSet();
    var itemProps = this.touchParams.itemProps;
    this.touchParams.itemProps = null;

    itemProps.forEach((function (props) {
      var id = props.item.id;
      var exists = me.itemsData.get(id, me.itemOptions) != null;

      if (!exists) {
        // add a new item
        me.options.onAdd(props.item.data, function (itemData) {
          me._removeItem(props.item); // remove temporary item
          if (itemData) {
            me.itemsData.getDataSet().add(itemData);
          }

          // force re-stacking of all items next redraw
          me.stackDirty = true;
          me.body.emitter.emit('change');
        });
      } else {
        // update existing item
        var itemData = this._cloneItemData(props.item.data); // convert start and end to the correct type
        me.options.onMove(itemData, function (itemData) {
          if (itemData) {
            // apply changes
            itemData[dataset._fieldId] = id; // ensure the item contains its id (can be undefined)
            dataset.update(itemData);
          } else {
            // restore original values
            props.item.setData(props.data);

            me.stackDirty = true; // force re-stacking of all items next redraw
            me.body.emitter.emit('change');
          }
        });
      }
    }).bind(this));
  }
};

ItemSet.prototype._onGroupDragStart = function (event) {
  if (this.options.groupEditable.order) {
    this.groupTouchParams.group = this.groupFromTarget(event);

    if (this.groupTouchParams.group) {
      event.stopPropagation();

      this.groupTouchParams.originalOrder = this.groupsData.getIds({
        order: this.options.groupOrder
      });
    }
  }
};

ItemSet.prototype._onGroupDrag = function (event) {
  if (this.options.groupEditable.order && this.groupTouchParams.group) {
    event.stopPropagation();

    // drag from one group to another
    var group = this.groupFromTarget(event);

    // try to avoid toggling when groups differ in height
    if (group && group.height != this.groupTouchParams.group.height) {
      var movingUp = group.top < this.groupTouchParams.group.top;
      var clientY = event.center ? event.center.y : event.clientY;
      var targetGroupTop = util.getAbsoluteTop(group.dom.foreground);
      var draggedGroupHeight = this.groupTouchParams.group.height;
      if (movingUp) {
        // skip swapping the groups when the dragged group is not below clientY afterwards
        if (targetGroupTop + draggedGroupHeight < clientY) {
          return;
        }
      } else {
        var targetGroupHeight = group.height;
        // skip swapping the groups when the dragged group is not below clientY afterwards
        if (targetGroupTop + targetGroupHeight - draggedGroupHeight > clientY) {
          return;
        }
      }
    }

    if (group && group != this.groupTouchParams.group) {
      var groupsData = this.groupsData;
      var targetGroup = groupsData.get(group.groupId);
      var draggedGroup = groupsData.get(this.groupTouchParams.group.groupId);

      // switch groups
      if (draggedGroup && targetGroup) {
        this.options.groupOrderSwap(draggedGroup, targetGroup, this.groupsData);
        this.groupsData.update(draggedGroup);
        this.groupsData.update(targetGroup);
      }

      // fetch current order of groups
      var newOrder = this.groupsData.getIds({
        order: this.options.groupOrder
      });

      // in case of changes since _onGroupDragStart
      if (!util.equalArray(newOrder, this.groupTouchParams.originalOrder)) {
        var groupsData = this.groupsData;
        var origOrder = this.groupTouchParams.originalOrder;
        var draggedId = this.groupTouchParams.group.groupId;
        var numGroups = Math.min(origOrder.length, newOrder.length);
        var curPos = 0;
        var newOffset = 0;
        var orgOffset = 0;
        while (curPos < numGroups) {
          // as long as the groups are where they should be step down along the groups order
          while (curPos + newOffset < numGroups && curPos + orgOffset < numGroups && newOrder[curPos + newOffset] == origOrder[curPos + orgOffset]) {
            curPos++;
          }

          // all ok
          if (curPos + newOffset >= numGroups) {
            break;
          }

          // not all ok
          // if dragged group was move upwards everything below should have an offset
          if (newOrder[curPos + newOffset] == draggedId) {
            newOffset = 1;
            continue;
          }
          // if dragged group was move downwards everything above should have an offset
          else if (origOrder[curPos + orgOffset] == draggedId) {
              orgOffset = 1;
              continue;
            }
            // found a group (apart from dragged group) that has the wrong position -> switch with the
            // group at the position where other one should be, fix index arrays and continue
            else {
                var slippedPosition = newOrder.indexOf(origOrder[curPos + orgOffset]);
                var switchGroup = groupsData.get(newOrder[curPos + newOffset]);
                var shouldBeGroup = groupsData.get(origOrder[curPos + orgOffset]);
                this.options.groupOrderSwap(switchGroup, shouldBeGroup, groupsData);
                groupsData.update(switchGroup);
                groupsData.update(shouldBeGroup);

                var switchGroupId = newOrder[curPos + newOffset];
                newOrder[curPos + newOffset] = origOrder[curPos + orgOffset];
                newOrder[slippedPosition] = switchGroupId;

                curPos++;
              }
        }
      }
    }
  }
};

ItemSet.prototype._onGroupDragEnd = function (event) {
  if (this.options.groupEditable.order && this.groupTouchParams.group) {
    event.stopPropagation();

    // update existing group
    var me = this;
    var id = me.groupTouchParams.group.groupId;
    var dataset = me.groupsData.getDataSet();
    var groupData = util.extend({}, dataset.get(id)); // clone the data
    me.options.onMoveGroup(groupData, function (groupData) {
      if (groupData) {
        // apply changes
        groupData[dataset._fieldId] = id; // ensure the group contains its id (can be undefined)
        dataset.update(groupData);
      } else {

        // fetch current order of groups
        var newOrder = dataset.getIds({
          order: me.options.groupOrder
        });

        // restore original order
        if (!util.equalArray(newOrder, me.groupTouchParams.originalOrder)) {
          var origOrder = me.groupTouchParams.originalOrder;
          var numGroups = Math.min(origOrder.length, newOrder.length);
          var curPos = 0;
          while (curPos < numGroups) {
            // as long as the groups are where they should be step down along the groups order
            while (curPos < numGroups && newOrder[curPos] == origOrder[curPos]) {
              curPos++;
            }

            // all ok
            if (curPos >= numGroups) {
              break;
            }

            // found a group that has the wrong position -> switch with the
            // group at the position where other one should be, fix index arrays and continue
            var slippedPosition = newOrder.indexOf(origOrder[curPos]);
            var switchGroup = dataset.get(newOrder[curPos]);
            var shouldBeGroup = dataset.get(origOrder[curPos]);
            me.options.groupOrderSwap(switchGroup, shouldBeGroup, dataset);
            groupsData.update(switchGroup);
            groupsData.update(shouldBeGroup);

            var switchGroupId = newOrder[curPos];
            newOrder[curPos] = origOrder[curPos];
            newOrder[slippedPosition] = switchGroupId;

            curPos++;
          }
        }
      }
    });

    me.body.emitter.emit('groupDragged', { groupId: id });
  }
};

/**
 * Handle selecting/deselecting an item when tapping it
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onSelectItem = function (event) {
  if (!this.options.selectable) return;

  var ctrlKey = event.srcEvent && (event.srcEvent.ctrlKey || event.srcEvent.metaKey);
  var shiftKey = event.srcEvent && event.srcEvent.shiftKey;
  if (ctrlKey || shiftKey) {
    this._onMultiSelectItem(event);
    return;
  }

  var oldSelection = this.getSelection();

  var item = this.itemFromTarget(event);
  var selection = item ? [item.id] : [];
  this.setSelection(selection);

  var newSelection = this.getSelection();

  // emit a select event,
  // except when old selection is empty and new selection is still empty
  if (newSelection.length > 0 || oldSelection.length > 0) {
    this.body.emitter.emit('select', {
      items: newSelection,
      event: event
    });
  }
};

/**
 * Handle creation and updates of an item on double tap
 * @param event
 * @private
 */
ItemSet.prototype._onAddItem = function (event) {
  if (!this.options.selectable) return;
  if (!this.options.editable.add) return;

  var me = this;
  var snap = this.options.snap || null;
  var item = this.itemFromTarget(event);

  event.stopPropagation();

  if (item) {
    // update item

    // execute async handler to update the item (or cancel it)
    var itemData = me.itemsData.get(item.id); // get a clone of the data from the dataset
    this.options.onUpdate(itemData, function (itemData) {
      if (itemData) {
        me.itemsData.getDataSet().update(itemData);
      }
    });
  } else {
    // add item
    var xAbs = util.getAbsoluteLeft(this.dom.frame);
    var x = event.center.x - xAbs;
    var start = this.body.util.toTime(x);
    var scale = this.body.util.getScale();
    var step = this.body.util.getStep();

    var newItemData = {
      start: snap ? snap(start, scale, step) : start,
      content: 'new item'
    };

    // when default type is a range, add a default end date to the new item
    if (this.options.type === 'range') {
      var end = this.body.util.toTime(x + this.props.width / 5);
      newItemData.end = snap ? snap(end, scale, step) : end;
    }

    newItemData[this.itemsData._fieldId] = util.randomUUID();

    var group = this.groupFromTarget(event);
    if (group) {
      newItemData.group = group.groupId;
    }

    // execute async handler to customize (or cancel) adding an item
    newItemData = this._cloneItemData(newItemData); // convert start and end to the correct type
    this.options.onAdd(newItemData, function (item) {
      if (item) {
        me.itemsData.getDataSet().add(item);
        // TODO: need to trigger a redraw?
      }
    });
  }
};

/**
 * Handle selecting/deselecting multiple items when holding an item
 * @param {Event} event
 * @private
 */
ItemSet.prototype._onMultiSelectItem = function (event) {
  if (!this.options.selectable) return;

  var item = this.itemFromTarget(event);

  if (item) {
    // multi select items (if allowed)

    var selection = this.options.multiselect ? this.getSelection() // take current selection
    : []; // deselect current selection

    var shiftKey = event.srcEvent && event.srcEvent.shiftKey || false;

    if (shiftKey && this.options.multiselect) {
      // select all items between the old selection and the tapped item

      // determine the selection range
      selection.push(item.id);
      var range = ItemSet._getItemRange(this.itemsData.get(selection, this.itemOptions));

      // select all items within the selection range
      selection = [];
      for (var id in this.items) {
        if (this.items.hasOwnProperty(id)) {
          var _item = this.items[id];
          var start = _item.data.start;
          var end = _item.data.end !== undefined ? _item.data.end : start;

          if (start >= range.min && end <= range.max && !(_item instanceof BackgroundItem)) {
            selection.push(_item.id); // do not use id but item.id, id itself is stringified
          }
        }
      }
    } else {
        // add/remove this item from the current selection
        var index = selection.indexOf(item.id);
        if (index == -1) {
          // item is not yet selected -> select it
          selection.push(item.id);
        } else {
          // item is already selected -> deselect it
          selection.splice(index, 1);
        }
      }

    this.setSelection(selection);

    this.body.emitter.emit('select', {
      items: this.getSelection(),
      event: event
    });
  }
};

/**
 * Calculate the time range of a list of items
 * @param {Array.<Object>} itemsData
 * @return {{min: Date, max: Date}} Returns the range of the provided items
 * @private
 */
ItemSet._getItemRange = function (itemsData) {
  var max = null;
  var min = null;

  itemsData.forEach(function (data) {
    if (min == null || data.start < min) {
      min = data.start;
    }

    if (data.end != undefined) {
      if (max == null || data.end > max) {
        max = data.end;
      }
    } else {
      if (max == null || data.start > max) {
        max = data.start;
      }
    }
  });

  return {
    min: min,
    max: max
  };
};

/**
 * Find an item from an event target:
 * searches for the attribute 'timeline-item' in the event target's element tree
 * @param {Event} event
 * @return {Item | null} item
 */
ItemSet.prototype.itemFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('timeline-item')) {
      return target['timeline-item'];
    }
    target = target.parentNode;
  }

  return null;
};

/**
 * Find the Group from an event target:
 * searches for the attribute 'timeline-group' in the event target's element tree
 * @param {Event} event
 * @return {Group | null} group
 */
ItemSet.prototype.groupFromTarget = function (event) {
  var clientY = event.center ? event.center.y : event.clientY;
  for (var i = 0; i < this.groupIds.length; i++) {
    var groupId = this.groupIds[i];
    var group = this.groups[groupId];
    var foreground = group.dom.foreground;
    var top = util.getAbsoluteTop(foreground);
    if (clientY > top && clientY < top + foreground.offsetHeight) {
      return group;
    }

    if (this.options.orientation.item === 'top') {
      if (i === this.groupIds.length - 1 && clientY > top) {
        return group;
      }
    } else {
      if (i === 0 && clientY < top + foreground.offset) {
        return group;
      }
    }
  }

  return null;
};

/**
 * Find the ItemSet from an event target:
 * searches for the attribute 'timeline-itemset' in the event target's element tree
 * @param {Event} event
 * @return {ItemSet | null} item
 */
ItemSet.itemSetFromTarget = function (event) {
  var target = event.target;
  while (target) {
    if (target.hasOwnProperty('timeline-itemset')) {
      return target['timeline-itemset'];
    }
    target = target.parentNode;
  }

  return null;
};

/**
 * Clone the data of an item, and "normalize" it: convert the start and end date
 * to the type (Date, Moment, ...) configured in the DataSet. If not configured,
 * start and end are converted to Date.
 * @param {Object} itemData, typically `item.data`
 * @param {string} [type]  Optional Date type. If not provided, the type from the DataSet is taken
 * @return {Object} The cloned object
 * @private
 */
ItemSet.prototype._cloneItemData = function (itemData, type) {
  var clone = util.extend({}, itemData);

  if (!type) {
    // convert start and end date to the type (Date, Moment, ...) configured in the DataSet
    type = this.itemsData.getDataSet()._options.type;
  }

  if (clone.start != undefined) {
    clone.start = util.convert(clone.start, type && type.start || 'Date');
  }
  if (clone.end != undefined) {
    clone.end = util.convert(clone.end, type && type.end || 'Date');
  }

  return clone;
};

module.exports = ItemSet;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvSXRlbVNldC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0FBQzVDLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNqQyxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDdkMsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFDekMsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3RDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN2QyxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDL0IsSUFBSSxlQUFlLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDbkQsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFDeEMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDNUMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDNUMsSUFBSSxjQUFjLEdBQUcsT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUM7O0FBR3RELElBQUksU0FBUyxHQUFHLGVBQWUsQ0FBQztBQUNoQyxJQUFJLFVBQVUsR0FBRyxnQkFBZ0IsQ0FBQzs7Ozs7Ozs7Ozs7QUFXbEMsU0FBUyxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUM5QixNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzs7QUFFakIsTUFBSSxDQUFDLGNBQWMsR0FBRztBQUNwQixRQUFJLEVBQUUsSUFBSTtBQUNWLGVBQVcsRUFBRTtBQUNY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RSxFQUFFLFFBQVEsQ0FBQyxDQUFDOztBQUV0QyxNQUFJLENBQUMsSUFBSSxFQUFFOztBQUVULFFBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7R0FDbEQ7O0FBRUQsTUFBSSxLQUFLLENBQUMsS0FBSyxJQUFJLFNBQVMsRUFBRTtBQUM1QixTQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxNQUFNLENBQUMsQ0FBQztHQUN2RTtBQUNELE1BQUksS0FBSyxDQUFDLEdBQUcsSUFBSSxTQUFTLEVBQUU7QUFDMUIsU0FBSyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUcsSUFBSSxJQUFJLElBQUksQ0FBQyxHQUFHLElBQUksTUFBTSxDQUFDLENBQUM7R0FDbEU7O0FBRUQsU0FBTyxLQUFLLENBQUM7Q0FDZCxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDIiwiZmlsZSI6Ii91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvSXRlbVNldC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBIYW1tZXIgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGUvaGFtbWVyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBEYXRhU2V0ID0gcmVxdWlyZSgnLi4vLi4vRGF0YVNldCcpO1xudmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi4vLi4vRGF0YVZpZXcnKTtcbnZhciBUaW1lU3RlcCA9IHJlcXVpcmUoJy4uL1RpbWVTdGVwJyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbnZhciBHcm91cCA9IHJlcXVpcmUoJy4vR3JvdXAnKTtcbnZhciBCYWNrZ3JvdW5kR3JvdXAgPSByZXF1aXJlKCcuL0JhY2tncm91bmRHcm91cCcpO1xudmFyIEJveEl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0vQm94SXRlbScpO1xudmFyIFBvaW50SXRlbSA9IHJlcXVpcmUoJy4vaXRlbS9Qb2ludEl0ZW0nKTtcbnZhciBSYW5nZUl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0vUmFuZ2VJdGVtJyk7XG52YXIgQmFja2dyb3VuZEl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0vQmFja2dyb3VuZEl0ZW0nKTtcblxuXG52YXIgVU5HUk9VUEVEID0gJ19fdW5ncm91cGVkX18nOyAgIC8vIHJlc2VydmVkIGdyb3VwIGlkIGZvciB1bmdyb3VwZWQgaXRlbXNcbnZhciBCQUNLR1JPVU5EID0gJ19fYmFja2dyb3VuZF9fJzsgLy8gcmVzZXJ2ZWQgZ3JvdXAgaWQgZm9yIGJhY2tncm91bmQgaXRlbXMgd2l0aG91dCBncm91cFxuXG4vKipcbiAqIEFuIEl0ZW1TZXQgaG9sZHMgYSBzZXQgb2YgaXRlbXMgYW5kIHJhbmdlcyB3aGljaCBjYW4gYmUgZGlzcGxheWVkIGluIGFcbiAqIHJhbmdlLiBUaGUgd2lkdGggaXMgZGV0ZXJtaW5lZCBieSB0aGUgcGFyZW50IG9mIHRoZSBJdGVtU2V0LCBhbmQgdGhlIGhlaWdodFxuICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgc2l6ZSBvZiB0aGUgaXRlbXMuXG4gKiBAcGFyYW0ge3tkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdCwgZW1pdHRlcjogRW1pdHRlciwgcmFuZ2U6IFJhbmdlfX0gYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgIFNlZSBJdGVtU2V0LnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvciBJdGVtU2V0XG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gSXRlbVNldChib2R5LCBvcHRpb25zKSB7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICB0eXBlOiBudWxsLCAgLy8gJ2JveCcsICdwb2ludCcsICdyYW5nZScsICdiYWNrZ3JvdW5kJ1xuICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICBpdGVtOiAnYm90dG9tJyAgIC8vIGl0ZW0gb3JpZW50YXRpb246ICd0b3AnIG9yICdib3R0b20nXG4gICAgfSxcbiAgICBhbGlnbjogJ2F1dG8nLCAvLyBhbGlnbm1lbnQgb2YgYm94IGl0ZW1zXG4gICAgc3RhY2s6IHRydWUsXG4gICAgZ3JvdXBPcmRlclN3YXA6IGZ1bmN0aW9uKGZyb21Hcm91cCwgdG9Hcm91cCwgZ3JvdXBzKSB7XG4gICAgXHR2YXIgdGFyZ2V0T3JkZXIgPSB0b0dyb3VwLm9yZGVyO1xuICAgIFx0dG9Hcm91cC5vcmRlciA9IGZyb21Hcm91cC5vcmRlcjtcbiAgICBcdGZyb21Hcm91cC5vcmRlciA9IHRhcmdldE9yZGVyO1xuICAgIH0sXG4gICAgZ3JvdXBPcmRlcjogJ29yZGVyJyxcblxuICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgbXVsdGlzZWxlY3Q6IGZhbHNlLFxuXG4gICAgZWRpdGFibGU6IHtcbiAgICAgIHVwZGF0ZVRpbWU6IGZhbHNlLFxuICAgICAgdXBkYXRlR3JvdXA6IGZhbHNlLFxuICAgICAgYWRkOiBmYWxzZSxcbiAgICAgIHJlbW92ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgZ3JvdXBFZGl0YWJsZToge1xuICAgICAgb3JkZXI6IGZhbHNlLFxuICAgICAgYWRkOiBmYWxzZSxcbiAgICAgIHJlbW92ZTogZmFsc2VcbiAgICB9LCAgICBcbiAgICBcbiAgICBzbmFwOiBUaW1lU3RlcC5zbmFwLFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcbiAgICBvblVwZGF0ZTogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuICAgIG9uTW92ZTogZnVuY3Rpb24gKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICB9LFxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG4gICAgb25Nb3Zpbmc6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcbiAgICBvbkFkZEdyb3VwOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG4gICAgb25Nb3ZlR3JvdXA6IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soaXRlbSk7XG4gICAgfSxcbiAgICBvblJlbW92ZUdyb3VwOiBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGl0ZW0pO1xuICAgIH0sXG5cbiAgICBtYXJnaW46IHtcbiAgICAgIGl0ZW06IHtcbiAgICAgICAgaG9yaXpvbnRhbDogMTAsXG4gICAgICAgIHZlcnRpY2FsOiAxMFxuICAgICAgfSxcbiAgICAgIGF4aXM6IDIwXG4gICAgfVxuICB9O1xuXG4gIC8vIG9wdGlvbnMgaXMgc2hhcmVkIGJ5IHRoaXMgSXRlbVNldCBhbmQgYWxsIGl0cyBpdGVtc1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgLy8gb3B0aW9ucyBmb3IgZ2V0dGluZyBpdGVtcyBmcm9tIHRoZSBEYXRhU2V0IHdpdGggdGhlIGNvcnJlY3QgdHlwZVxuICB0aGlzLml0ZW1PcHRpb25zID0ge1xuICAgIHR5cGU6IHtzdGFydDogJ0RhdGUnLCBlbmQ6ICdEYXRlJ31cbiAgfTtcblxuICB0aGlzLmNvbnZlcnNpb24gPSB7XG4gICAgdG9TY3JlZW46IGJvZHkudXRpbC50b1NjcmVlbixcbiAgICB0b1RpbWU6IGJvZHkudXRpbC50b1RpbWVcbiAgfTtcbiAgdGhpcy5kb20gPSB7fTtcbiAgdGhpcy5wcm9wcyA9IHt9O1xuICB0aGlzLmhhbW1lciA9IG51bGw7XG5cbiAgdmFyIG1lID0gdGhpcztcbiAgdGhpcy5pdGVtc0RhdGEgPSBudWxsOyAgICAvLyBEYXRhU2V0XG4gIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7ICAgLy8gRGF0YVNldFxuXG4gIC8vIGxpc3RlbmVycyBmb3IgdGhlIERhdGFTZXQgb2YgdGhlIGl0ZW1zXG4gIHRoaXMuaXRlbUxpc3RlbmVycyA9IHtcbiAgICAnYWRkJzogZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICBtZS5fb25BZGQocGFyYW1zLml0ZW1zKTtcbiAgICB9LFxuICAgICd1cGRhdGUnOiBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgIG1lLl9vblVwZGF0ZShwYXJhbXMuaXRlbXMpO1xuICAgIH0sXG4gICAgJ3JlbW92ZSc6IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgbWUuX29uUmVtb3ZlKHBhcmFtcy5pdGVtcyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGxpc3RlbmVycyBmb3IgdGhlIERhdGFTZXQgb2YgdGhlIGdyb3Vwc1xuICB0aGlzLmdyb3VwTGlzdGVuZXJzID0ge1xuICAgICdhZGQnOiBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcywgc2VuZGVySWQpIHtcbiAgICAgIG1lLl9vbkFkZEdyb3VwcyhwYXJhbXMuaXRlbXMpO1xuICAgIH0sXG4gICAgJ3VwZGF0ZSc6IGZ1bmN0aW9uIChldmVudCwgcGFyYW1zLCBzZW5kZXJJZCkge1xuICAgICAgbWUuX29uVXBkYXRlR3JvdXBzKHBhcmFtcy5pdGVtcyk7XG4gICAgfSxcbiAgICAncmVtb3ZlJzogZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMsIHNlbmRlcklkKSB7XG4gICAgICBtZS5fb25SZW1vdmVHcm91cHMocGFyYW1zLml0ZW1zKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5pdGVtcyA9IHt9OyAgICAgIC8vIG9iamVjdCB3aXRoIGFuIEl0ZW0gZm9yIGV2ZXJ5IGRhdGEgaXRlbVxuICB0aGlzLmdyb3VwcyA9IHt9OyAgICAgLy8gR3JvdXAgb2JqZWN0IGZvciBldmVyeSBncm91cFxuICB0aGlzLmdyb3VwSWRzID0gW107XG5cbiAgdGhpcy5zZWxlY3Rpb24gPSBbXTsgIC8vIGxpc3Qgd2l0aCB0aGUgaWRzIG9mIGFsbCBzZWxlY3RlZCBub2Rlc1xuICB0aGlzLnN0YWNrRGlydHkgPSB0cnVlOyAvLyBpZiB0cnVlLCBhbGwgaXRlbXMgd2lsbCBiZSByZXN0YWNrZWQgb24gbmV4dCByZWRyYXdcblxuICB0aGlzLnRvdWNoUGFyYW1zID0ge307IC8vIHN0b3JlcyBwcm9wZXJ0aWVzIHdoaWxlIGRyYWdnaW5nXG4gIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcyA9IHt9O1xuICAvLyBjcmVhdGUgdGhlIEhUTUwgRE9NXG5cbiAgdGhpcy5fY3JlYXRlKCk7XG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xufVxuXG5JdGVtU2V0LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLy8gYXZhaWxhYmxlIGl0ZW0gdHlwZXMgd2lsbCBiZSByZWdpc3RlcmVkIGhlcmVcbkl0ZW1TZXQudHlwZXMgPSB7XG4gIGJhY2tncm91bmQ6IEJhY2tncm91bmRJdGVtLFxuICBib3g6IEJveEl0ZW0sXG4gIHJhbmdlOiBSYW5nZUl0ZW0sXG4gIHBvaW50OiBQb2ludEl0ZW1cbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBIVE1MIERPTSBmb3IgdGhlIEl0ZW1TZXRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2NyZWF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBmcmFtZS5jbGFzc05hbWUgPSAndmlzLWl0ZW1zZXQnO1xuICBmcmFtZVsndGltZWxpbmUtaXRlbXNldCddID0gdGhpcztcbiAgdGhpcy5kb20uZnJhbWUgPSBmcmFtZTtcblxuICAvLyBjcmVhdGUgYmFja2dyb3VuZCBwYW5lbFxuICB2YXIgYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBiYWNrZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtYmFja2dyb3VuZCc7XG4gIGZyYW1lLmFwcGVuZENoaWxkKGJhY2tncm91bmQpO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblxuICAvLyBjcmVhdGUgZm9yZWdyb3VuZCBwYW5lbFxuICB2YXIgZm9yZWdyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBmb3JlZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtZm9yZWdyb3VuZCc7XG4gIGZyYW1lLmFwcGVuZENoaWxkKGZvcmVncm91bmQpO1xuICB0aGlzLmRvbS5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcblxuICAvLyBjcmVhdGUgYXhpcyBwYW5lbFxuICB2YXIgYXhpcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBheGlzLmNsYXNzTmFtZSA9ICd2aXMtYXhpcyc7XG4gIHRoaXMuZG9tLmF4aXMgPSBheGlzO1xuXG4gIC8vIGNyZWF0ZSBsYWJlbHNldFxuICB2YXIgbGFiZWxTZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgbGFiZWxTZXQuY2xhc3NOYW1lID0gJ3Zpcy1sYWJlbHNldCc7XG4gIHRoaXMuZG9tLmxhYmVsU2V0ID0gbGFiZWxTZXQ7XG5cbiAgLy8gY3JlYXRlIHVuZ3JvdXBlZCBHcm91cFxuICB0aGlzLl91cGRhdGVVbmdyb3VwZWQoKTtcblxuICAvLyBjcmVhdGUgYmFja2dyb3VuZCBHcm91cFxuICB2YXIgYmFja2dyb3VuZEdyb3VwID0gbmV3IEJhY2tncm91bmRHcm91cChCQUNLR1JPVU5ELCBudWxsLCB0aGlzKTtcbiAgYmFja2dyb3VuZEdyb3VwLnNob3coKTtcbiAgdGhpcy5ncm91cHNbQkFDS0dST1VORF0gPSBiYWNrZ3JvdW5kR3JvdXA7XG5cbiAgLy8gYXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICAvLyBOb3RlOiB3ZSBiaW5kIHRvIHRoZSBjZW50ZXJDb250YWluZXIgZm9yIHRoZSBjYXNlIHdoZXJlIHRoZSBoZWlnaHRcbiAgLy8gICAgICAgb2YgdGhlIGNlbnRlciBjb250YWluZXIgaXMgbGFyZ2VyIHRoYW4gb2YgdGhlIEl0ZW1TZXQsIHNvIHdlXG4gIC8vICAgICAgIGNhbiBjbGljayBpbiB0aGUgZW1wdHkgYXJlYSB0byBjcmVhdGUgYSBuZXcgaXRlbSBvciBkZXNlbGVjdCBhbiBpdGVtLlxuICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5ib2R5LmRvbS5jZW50ZXJDb250YWluZXIpO1xuXG4gIC8vIGRyYWcgaXRlbXMgd2hlbiBzZWxlY3RlZFxuICB0aGlzLmhhbW1lci5vbignaGFtbWVyLmlucHV0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlzRmlyc3QpIHtcbiAgICAgIHRoaXMuX29uVG91Y2goZXZlbnQpO1xuICAgIH1cbiAgfS5iaW5kKHRoaXMpKTtcbiAgdGhpcy5oYW1tZXIub24oJ3BhbnN0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gIHRoaXMuaGFtbWVyLm9uKCdwYW5tb3ZlJywgIHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpKTtcbiAgdGhpcy5oYW1tZXIub24oJ3BhbmVuZCcsICAgdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcykpO1xuICB0aGlzLmhhbW1lci5nZXQoJ3BhbicpLnNldCh7dGhyZXNob2xkOjUsIGRpcmVjdGlvbjozMH0pOyAvLyAzMCBpcyBBTExfRElSRUNUSU9OUyBpbiBoYW1tZXIuXG5cbiAgLy8gc2luZ2xlIHNlbGVjdCAob3IgdW5zZWxlY3QpIHdoZW4gdGFwcGluZyBhbiBpdGVtXG4gIHRoaXMuaGFtbWVyLm9uKCd0YXAnLCAgdGhpcy5fb25TZWxlY3RJdGVtLmJpbmQodGhpcykpO1xuXG4gIC8vIG11bHRpIHNlbGVjdCB3aGVuIGhvbGRpbmcgbW91c2UvdG91Y2gsIG9yIG9uIGN0cmwrY2xpY2tcbiAgdGhpcy5oYW1tZXIub24oJ3ByZXNzJywgdGhpcy5fb25NdWx0aVNlbGVjdEl0ZW0uYmluZCh0aGlzKSk7XG5cbiAgLy8gYWRkIGl0ZW0gb24gZG91YmxldGFwXG4gIHRoaXMuaGFtbWVyLm9uKCdkb3VibGV0YXAnLCB0aGlzLl9vbkFkZEl0ZW0uYmluZCh0aGlzKSk7XG5cbiAgdGhpcy5ncm91cEhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5ib2R5LmRvbS5sZWZ0Q29udGFpbmVyKTtcbiAgdGhpcy5ncm91cEhhbW1lci5vbigncGFuc3RhcnQnLCB0aGlzLl9vbkdyb3VwRHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuICB0aGlzLmdyb3VwSGFtbWVyLm9uKCdwYW5tb3ZlJywgIHRoaXMuX29uR3JvdXBEcmFnLmJpbmQodGhpcykpO1xuICB0aGlzLmdyb3VwSGFtbWVyLm9uKCdwYW5lbmQnLCAgIHRoaXMuX29uR3JvdXBEcmFnRW5kLmJpbmQodGhpcykpO1xuICB0aGlzLmdyb3VwSGFtbWVyLmdldCgncGFuJykuc2V0KHt0aHJlc2hvbGQ6NSwgZGlyZWN0aW9uOjMwfSk7XG4gIFxuICAvLyBhdHRhY2ggdG8gdGhlIERPTVxuICB0aGlzLnNob3coKTtcbn07XG5cbi8qKlxuICogU2V0IG9wdGlvbnMgZm9yIHRoZSBJdGVtU2V0LiBFeGlzdGluZyBvcHRpb25zIHdpbGwgYmUgZXh0ZW5kZWQvb3ZlcndyaXR0ZW4uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSB0eXBlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgdHlwZSBmb3IgdGhlIGl0ZW1zLiBDaG9vc2UgZnJvbSAnYm94J1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGVmYXVsdCksICdwb2ludCcsICdyYW5nZScsIG9yICdiYWNrZ3JvdW5kJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgc3R5bGUgY2FuIGJlIG92ZXJ3cml0dGVuIGJ5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGl2aWR1YWwgaXRlbXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IGFsaWduXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsaWdubWVudCBmb3IgdGhlIGl0ZW1zLCBvbmx5IGFwcGxpY2FibGUgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJveEl0ZW0uIENob29zZSAnY2VudGVyJyAoZGVmYXVsdCksICdsZWZ0Jywgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JpZ2h0Jy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge1N0cmluZ30gb3JpZW50YXRpb24uaXRlbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcmllbnRhdGlvbiBvZiB0aGUgaXRlbSBzZXQuIENob29zZSAndG9wJyBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYm90dG9tJyAoZGVmYXVsdCkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbn0gZ3JvdXBPcmRlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBIHNvcnRpbmcgZnVuY3Rpb24gZm9yIG9yZGVyaW5nIGdyb3Vwc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gc3RhY2tcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdHJ1ZSAoZGVmYXVsdCksIGl0ZW1zIHdpbGwgYmUgc3RhY2tlZCBvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3Agb2YgZWFjaCBvdGhlci5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLmF4aXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWFyZ2luIGJldHdlZW4gdGhlIGF4aXMgYW5kIHRoZSBpdGVtcyBpbiBwaXhlbHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgMjAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpbi5pdGVtLmhvcml6b250YWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSG9yaXpvbnRhbCBtYXJnaW4gYmV0d2VlbiBpdGVtcyBpbiBwaXhlbHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgMTAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IG1hcmdpbi5pdGVtLnZlcnRpY2FsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2FsIE1hcmdpbiBiZXR3ZWVuIGl0ZW1zIGluIHBpeGVscy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyAxMC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gbWFyZ2luLml0ZW1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWFyZ2luIGJldHdlZW4gaXRlbXMgaW4gcGl4ZWxzIGluIGJvdGggaG9yaXpvbnRhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdmVydGljYWwgZGlyZWN0aW9uLiBEZWZhdWx0IGlzIDEwLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBtYXJnaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0IG1hcmdpbiBmb3IgYm90aCBheGlzIGFuZCBpdGVtcyBpbiBwaXhlbHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBzZWxlY3RhYmxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRydWUgKGRlZmF1bHQpLCBpdGVtcyBjYW4gYmUgc2VsZWN0ZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBtdWx0aXNlbGVjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlLCBtdWx0aXBsZSBpdGVtcyBjYW4gYmUgc2VsZWN0ZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZhbHNlIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXQgYWxsIGVkaXRhYmxlIG9wdGlvbnMgdG8gdHJ1ZSBvciBmYWxzZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gZWRpdGFibGUudXBkYXRlVGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGxvdyBkcmFnZ2luZyBhbiBpdGVtIHRvIGFuIG90aGVyIG1vbWVudCBpbiB0aW1lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZS51cGRhdGVHcm91cFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGxvdyBkcmFnZ2luZyBhbiBpdGVtIHRvIGFuIG90aGVyIGdyb3VwXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBlZGl0YWJsZS5hZGRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxsb3cgY3JlYXRpbmcgbmV3IGl0ZW1zIG9uIGRvdWJsZSB0YXBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IGVkaXRhYmxlLnJlbW92ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbGxvdyByZW1vdmluZyBpdGVtcyBieSBjbGlja2luZyB0aGUgZGVsZXRlIGJ1dHRvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AgcmlnaHQgb2YgYSBzZWxlY3RlZCBpdGVtLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB7RnVuY3Rpb24oaXRlbTogSXRlbSwgY2FsbGJhY2s6IEZ1bmN0aW9uKX0gb25BZGRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIHdoZW4gYW4gaXRlbSBpcyBhYm91dCB0byBiZSBhZGRlZDpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgdXNlciBkb3VibGUgdGFwcyBhbiBlbXB0eSBzcGFjZSBpbiB0aGUgVGltZWxpbmUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvblVwZGF0ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBmdW5jdGlvbiBmaXJlZCB3aGVuIGFuIGl0ZW0gaXMgYWJvdXQgdG8gYmUgdXBkYXRlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBmdW5jdGlvbiB0eXBpY2FsbHkgaGFzIHRvIHNob3cgYSBkaWFsb2cgd2hlcmUgdGhlIHVzZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlIHRoZSBpdGVtLiBJZiBub3QgaW1wbGVtZW50ZWQsIG5vdGhpbmcgaGFwcGVucy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAge0Z1bmN0aW9uKGl0ZW06IEl0ZW0sIGNhbGxiYWNrOiBGdW5jdGlvbil9IG9uTW92ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGFuIGl0ZW0gaGFzIGJlZW4gbW92ZWQuIElmIG5vdCBpbXBsZW1lbnRlZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG1vdmUgYWN0aW9uIHdpbGwgYmUgYWNjZXB0ZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHtGdW5jdGlvbihpdGVtOiBJdGVtLCBjYWxsYmFjazogRnVuY3Rpb24pfSBvblJlbW92ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGFuIGl0ZW0gaXMgYWJvdXQgdG8gYmUgZGVsZXRlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IGltcGxlbWVudGVkLCB0aGUgaXRlbSB3aWxsIGJlIGFsd2F5cyByZW1vdmVkLlxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIC8vIGNvcHkgYWxsIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgdmFyIGZpZWxkcyA9IFsndHlwZScsICdhbGlnbicsICdvcmRlcicsICdzdGFjaycsICdzZWxlY3RhYmxlJywgJ211bHRpc2VsZWN0JywgJ2dyb3VwT3JkZXInLCAnZGF0YUF0dHJpYnV0ZXMnLCAndGVtcGxhdGUnLCAnZ3JvdXBUZW1wbGF0ZScsICdoaWRlJywgJ3NuYXAnLCAnZ3JvdXBPcmRlclN3YXAnXTtcbiAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ29yaWVudGF0aW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID0gb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ3RvcCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMub3JpZW50YXRpb24gPT09ICdvYmplY3QnICYmICdpdGVtJyBpbiBvcHRpb25zLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtID0gb3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgnbWFyZ2luJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWFyZ2luID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLmF4aXMgPSBvcHRpb25zLm1hcmdpbjtcbiAgICAgICAgdGhpcy5vcHRpb25zLm1hcmdpbi5pdGVtLmhvcml6b250YWwgPSBvcHRpb25zLm1hcmdpbjtcbiAgICAgICAgdGhpcy5vcHRpb25zLm1hcmdpbi5pdGVtLnZlcnRpY2FsID0gb3B0aW9ucy5tYXJnaW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnYXhpcyddLCB0aGlzLm9wdGlvbnMubWFyZ2luLCBvcHRpb25zLm1hcmdpbik7XG4gICAgICAgIGlmICgnaXRlbScgaW4gb3B0aW9ucy5tYXJnaW4pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWFyZ2luLml0ZW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0uaG9yaXpvbnRhbCA9IG9wdGlvbnMubWFyZ2luLml0ZW07XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0udmVydGljYWwgPSBvcHRpb25zLm1hcmdpbi5pdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW4uaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHV0aWwuc2VsZWN0aXZlRXh0ZW5kKFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddLCB0aGlzLm9wdGlvbnMubWFyZ2luLml0ZW0sIG9wdGlvbnMubWFyZ2luLml0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgnZWRpdGFibGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lICA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS5hZGQgICAgICAgICA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS5yZW1vdmUgICAgICA9IG9wdGlvbnMuZWRpdGFibGU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGl0YWJsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoWyd1cGRhdGVUaW1lJywgJ3VwZGF0ZUdyb3VwJywgJ2FkZCcsICdyZW1vdmUnXSwgdGhpcy5vcHRpb25zLmVkaXRhYmxlLCBvcHRpb25zLmVkaXRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKCdncm91cEVkaXRhYmxlJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZ3JvdXBFZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyICA9IG9wdGlvbnMuZ3JvdXBFZGl0YWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUuYWRkICAgID0gb3B0aW9ucy5ncm91cEVkaXRhYmxlO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5yZW1vdmUgPSBvcHRpb25zLmdyb3VwRWRpdGFibGU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5ncm91cEVkaXRhYmxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB1dGlsLnNlbGVjdGl2ZUV4dGVuZChbJ29yZGVyJywgJ2FkZCcsICdyZW1vdmUnXSwgdGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUsIG9wdGlvbnMuZ3JvdXBFZGl0YWJsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAgdmFyIGFkZENhbGxiYWNrID0gKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZm4gPSBvcHRpb25zW25hbWVdO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGlmICghKGZuIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb24gJyArIG5hbWUgKyAnIG11c3QgYmUgYSBmdW5jdGlvbiAnICsgbmFtZSArICcoaXRlbSwgY2FsbGJhY2spJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW25hbWVdID0gZm47XG4gICAgICB9XG4gICAgfSkuYmluZCh0aGlzKTtcbiAgICBbJ29uQWRkJywgJ29uVXBkYXRlJywgJ29uUmVtb3ZlJywgJ29uTW92ZScsICdvbk1vdmluZycsICdvbkFkZEdyb3VwJywgJ29uTW92ZUdyb3VwJywgJ29uUmVtb3ZlR3JvdXAnXS5mb3JFYWNoKGFkZENhbGxiYWNrKTtcblxuICAgIC8vIGZvcmNlIHRoZSBpdGVtU2V0IHRvIHJlZnJlc2g6IG9wdGlvbnMgbGlrZSBvcmllbnRhdGlvbiBhbmQgbWFyZ2lucyBtYXkgYmUgY2hhbmdlZFxuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFyayB0aGUgSXRlbVNldCBkaXJ0eSBzbyBpdCB3aWxsIHJlZnJlc2ggZXZlcnl0aGluZyB3aXRoIG5leHQgcmVkcmF3LlxuICogT3B0aW9uYWxseSwgYWxsIGl0ZW1zIGNhbiBiZSBtYXJrZWQgYXMgZGlydHkgYW5kIGJlIHJlZnJlc2hlZC5cbiAqIEBwYXJhbSB7e3JlZnJlc2hJdGVtczogYm9vbGVhbn19IFtvcHRpb25zXVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5tYXJrRGlydHkgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMuZ3JvdXBJZHMgPSBbXTtcbiAgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlZnJlc2hJdGVtcykge1xuICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaXRlbS5kaXJ0eSA9IHRydWU7XG4gICAgICBpZiAoaXRlbS5kaXNwbGF5ZWQpIGl0ZW0ucmVkcmF3KCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgSXRlbVNldFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaGlkZSgpO1xuICB0aGlzLnNldEl0ZW1zKG51bGwpO1xuICB0aGlzLnNldEdyb3VwcyhudWxsKTtcblxuICB0aGlzLmhhbW1lciA9IG51bGw7XG5cbiAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgdGhpcy5jb252ZXJzaW9uID0gbnVsbDtcbn07XG5cbi8qKlxuICogSGlkZSB0aGUgY29tcG9uZW50IGZyb20gdGhlIERPTVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJlbW92ZSB0aGUgZnJhbWUgY29udGFpbmluZyB0aGUgaXRlbXNcbiAgaWYgKHRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmRvbS5mcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmZyYW1lKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSB0aGUgYXhpcyB3aXRoIGRvdHNcbiAgaWYgKHRoaXMuZG9tLmF4aXMucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLmF4aXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5heGlzKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSB0aGUgbGFiZWxzZXQgY29udGFpbmluZyBhbGwgZ3JvdXAgbGFiZWxzXG4gIGlmICh0aGlzLmRvbS5sYWJlbFNldC5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5kb20ubGFiZWxTZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5sYWJlbFNldCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2hvdyB0aGUgY29tcG9uZW50IGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2hvdyBmcmFtZSBjb250YWluaW5nIHRoZSBpdGVtc1xuICBpZiAoIXRoaXMuZG9tLmZyYW1lLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmJvZHkuZG9tLmNlbnRlci5hcHBlbmRDaGlsZCh0aGlzLmRvbS5mcmFtZSk7XG4gIH1cblxuICAvLyBzaG93IGF4aXMgd2l0aCBkb3RzXG4gIGlmICghdGhpcy5kb20uYXhpcy5wYXJlbnROb2RlKSB7XG4gICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuYXBwZW5kQ2hpbGQodGhpcy5kb20uYXhpcyk7XG4gIH1cblxuICAvLyBzaG93IGxhYmVsc2V0IGNvbnRhaW5pbmcgbGFiZWxzXG4gIGlmICghdGhpcy5kb20ubGFiZWxTZXQucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuYm9keS5kb20ubGVmdC5hcHBlbmRDaGlsZCh0aGlzLmRvbS5sYWJlbFNldCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHNlbGVjdGVkIGl0ZW1zIGJ5IHRoZWlyIGlkLiBSZXBsYWNlcyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAqIFVua25vd24gaWQncyBhcmUgc2lsZW50bHkgaWdub3JlZC5cbiAqIEBwYXJhbSB7c3RyaW5nW10gfCBzdHJpbmd9IFtpZHNdIEFuIGFycmF5IHdpdGggemVybyBvciBtb3JlIGlkJ3Mgb2YgdGhlIGl0ZW1zIHRvIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCwgb3IgYSBzaW5nbGUgaXRlbSBpZC4gSWYgaWRzIGlzIHVuZGVmaW5lZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYW4gZW1wdHkgYXJyYXksIGFsbCBpdGVtcyB3aWxsIGJlIHVuc2VsZWN0ZWQuXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKGlkcykge1xuICB2YXIgaSwgaWksIGlkLCBpdGVtO1xuXG4gIGlmIChpZHMgPT0gdW5kZWZpbmVkKSBpZHMgPSBbXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkcykpIGlkcyA9IFtpZHNdO1xuXG4gIC8vIHVuc2VsZWN0IGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtc1xuICBmb3IgKGkgPSAwLCBpaSA9IHRoaXMuc2VsZWN0aW9uLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZCA9IHRoaXMuc2VsZWN0aW9uW2ldO1xuICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2lkXTtcbiAgICBpZiAoaXRlbSkgaXRlbS51bnNlbGVjdCgpO1xuICB9XG5cbiAgLy8gc2VsZWN0IGl0ZW1zXG4gIHRoaXMuc2VsZWN0aW9uID0gW107XG4gIGZvciAoaSA9IDAsIGlpID0gaWRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZCA9IGlkc1tpXTtcbiAgICBpdGVtID0gdGhpcy5pdGVtc1tpZF07XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnB1c2goaWQpO1xuICAgICAgaXRlbS5zZWxlY3QoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBzZWxlY3RlZCBpdGVtcyBieSB0aGVpciBpZFxuICogQHJldHVybiB7QXJyYXl9IGlkcyAgVGhlIGlkcyBvZiB0aGUgc2VsZWN0ZWQgaXRlbXNcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbi5jb25jYXQoW10pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGlkJ3Mgb2YgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGl0ZW1zLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgaWRzIG9mIHRoZSB2aXNpYmxlIGl0ZW1zXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmdldFZpc2libGVJdGVtcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmFuZ2UgPSB0aGlzLmJvZHkucmFuZ2UuZ2V0UmFuZ2UoKTtcbiAgdmFyIGxlZnQgID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4ocmFuZ2Uuc3RhcnQpO1xuICB2YXIgcmlnaHQgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihyYW5nZS5lbmQpO1xuXG4gIHZhciBpZHMgPSBbXTtcbiAgZm9yICh2YXIgZ3JvdXBJZCBpbiB0aGlzLmdyb3Vwcykge1xuICAgIGlmICh0aGlzLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cElkKSkge1xuICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgICB2YXIgcmF3VmlzaWJsZUl0ZW1zID0gZ3JvdXAudmlzaWJsZUl0ZW1zO1xuXG4gICAgICAvLyBmaWx0ZXIgdGhlIFwicmF3XCIgc2V0IHdpdGggdmlzaWJsZUl0ZW1zIGludG8gYSBzZXQgd2hpY2ggaXMgcmVhbGx5XG4gICAgICAvLyB2aXNpYmxlIGJ5IHBpeGVsc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdWaXNpYmxlSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSByYXdWaXNpYmxlSXRlbXNbaV07XG4gICAgICAgIC8vIFRPRE86IGFsc28gY2hlY2sgd2hldGhlciB2aXNpYmxlIHZlcnRpY2FsbHlcbiAgICAgICAgaWYgKChpdGVtLmxlZnQgPCByaWdodCkgJiYgKGl0ZW0ubGVmdCArIGl0ZW0ud2lkdGggPiBsZWZ0KSkge1xuICAgICAgICAgIGlkcy5wdXNoKGl0ZW0uaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlkcztcbn07XG5cbi8qKlxuICogRGVzZWxlY3QgYSBzZWxlY3RlZCBpdGVtXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gaWRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9kZXNlbGVjdCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gc2VsZWN0aW9uLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZiAoc2VsZWN0aW9uW2ldID09IGlkKSB7IC8vIG5vbi1zdHJpY3QgY29tcGFyaXNvbiFcbiAgICAgIHNlbGVjdGlvbi5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZXNpemVkXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWFyZ2luID0gdGhpcy5vcHRpb25zLm1hcmdpbixcbiAgICAgIHJhbmdlID0gdGhpcy5ib2R5LnJhbmdlLFxuICAgICAgYXNTaXplID0gdXRpbC5vcHRpb24uYXNTaXplLFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgIG9yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtLFxuICAgICAgcmVzaXplZCA9IGZhbHNlLFxuICAgICAgZnJhbWUgPSB0aGlzLmRvbS5mcmFtZTtcblxuICAvLyByZWNhbGN1bGF0ZSBhYnNvbHV0ZSBwb3NpdGlvbiAoYmVmb3JlIHJlZHJhd2luZyBncm91cHMpXG4gIHRoaXMucHJvcHMudG9wID0gdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyB0aGlzLmJvZHkuZG9tUHJvcHMuYm9yZGVyLnRvcDtcbiAgdGhpcy5wcm9wcy5sZWZ0ID0gdGhpcy5ib2R5LmRvbVByb3BzLmxlZnQud2lkdGggKyB0aGlzLmJvZHkuZG9tUHJvcHMuYm9yZGVyLmxlZnQ7XG5cbiAgLy8gdXBkYXRlIGNsYXNzIG5hbWVcbiAgZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtc2V0JztcblxuICAvLyByZW9yZGVyIHRoZSBncm91cHMgKGlmIG5lZWRlZClcbiAgcmVzaXplZCA9IHRoaXMuX29yZGVyR3JvdXBzKCkgfHwgcmVzaXplZDtcblxuICAvLyBjaGVjayB3aGV0aGVyIHpvb21lZCAoaW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gcmUtc3RhY2sgZXZlcnl0aGluZylcbiAgLy8gVE9ETzogd291bGQgYmUgbmljZXIgdG8gZ2V0IHRoaXMgYXMgYSB0cmlnZ2VyIGZyb20gUmFuZ2VcbiAgdmFyIHZpc2libGVJbnRlcnZhbCA9IHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0O1xuICB2YXIgem9vbWVkID0gKHZpc2libGVJbnRlcnZhbCAhPSB0aGlzLmxhc3RWaXNpYmxlSW50ZXJ2YWwpIHx8ICh0aGlzLnByb3BzLndpZHRoICE9IHRoaXMucHJvcHMubGFzdFdpZHRoKTtcbiAgaWYgKHpvb21lZCkgdGhpcy5zdGFja0RpcnR5ID0gdHJ1ZTtcbiAgdGhpcy5sYXN0VmlzaWJsZUludGVydmFsID0gdmlzaWJsZUludGVydmFsO1xuICB0aGlzLnByb3BzLmxhc3RXaWR0aCA9IHRoaXMucHJvcHMud2lkdGg7XG5cbiAgdmFyIHJlc3RhY2sgPSB0aGlzLnN0YWNrRGlydHk7XG4gIHZhciBmaXJzdEdyb3VwID0gdGhpcy5fZmlyc3RHcm91cCgpO1xuICB2YXIgZmlyc3RNYXJnaW4gPSB7XG4gICAgaXRlbTogbWFyZ2luLml0ZW0sXG4gICAgYXhpczogbWFyZ2luLmF4aXNcbiAgfTtcbiAgdmFyIG5vbkZpcnN0TWFyZ2luID0ge1xuICAgIGl0ZW06IG1hcmdpbi5pdGVtLFxuICAgIGF4aXM6IG1hcmdpbi5pdGVtLnZlcnRpY2FsIC8gMlxuICB9O1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgdmFyIG1pbkhlaWdodCA9IG1hcmdpbi5heGlzICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG5cbiAgLy8gcmVkcmF3IHRoZSBiYWNrZ3JvdW5kIGdyb3VwXG4gIHRoaXMuZ3JvdXBzW0JBQ0tHUk9VTkRdLnJlZHJhdyhyYW5nZSwgbm9uRmlyc3RNYXJnaW4sIHJlc3RhY2spO1xuXG4gIC8vIHJlZHJhdyBhbGwgcmVndWxhciBncm91cHNcbiAgdXRpbC5mb3JFYWNoKHRoaXMuZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICB2YXIgZ3JvdXBNYXJnaW4gPSAoZ3JvdXAgPT0gZmlyc3RHcm91cCkgPyBmaXJzdE1hcmdpbiA6IG5vbkZpcnN0TWFyZ2luO1xuICAgIHZhciBncm91cFJlc2l6ZWQgPSBncm91cC5yZWRyYXcocmFuZ2UsIGdyb3VwTWFyZ2luLCByZXN0YWNrKTtcbiAgICByZXNpemVkID0gZ3JvdXBSZXNpemVkIHx8IHJlc2l6ZWQ7XG4gICAgaGVpZ2h0ICs9IGdyb3VwLmhlaWdodDtcbiAgfSk7XG4gIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgbWluSGVpZ2h0KTtcbiAgdGhpcy5zdGFja0RpcnR5ID0gZmFsc2U7XG5cbiAgLy8gdXBkYXRlIGZyYW1lIGhlaWdodFxuICBmcmFtZS5zdHlsZS5oZWlnaHQgID0gYXNTaXplKGhlaWdodCk7XG5cbiAgLy8gY2FsY3VsYXRlIGFjdHVhbCBzaXplXG4gIHRoaXMucHJvcHMud2lkdGggPSBmcmFtZS5vZmZzZXRXaWR0aDtcbiAgdGhpcy5wcm9wcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgLy8gcmVwb3NpdGlvbiBheGlzXG4gIHRoaXMuZG9tLmF4aXMuc3R5bGUudG9wID0gYXNTaXplKChvcmllbnRhdGlvbiA9PSAndG9wJykgP1xuICAgICAgKHRoaXMuYm9keS5kb21Qcm9wcy50b3AuaGVpZ2h0ICsgdGhpcy5ib2R5LmRvbVByb3BzLmJvcmRlci50b3ApIDpcbiAgICAgICh0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArIHRoaXMuYm9keS5kb21Qcm9wcy5jZW50ZXJDb250YWluZXIuaGVpZ2h0KSk7XG4gIHRoaXMuZG9tLmF4aXMuc3R5bGUubGVmdCA9ICcwJztcblxuICAvLyBjaGVjayBpZiB0aGlzIGNvbXBvbmVudCBpcyByZXNpemVkXG4gIHJlc2l6ZWQgPSB0aGlzLl9pc1Jlc2l6ZWQoKSB8fCByZXNpemVkO1xuXG4gIHJldHVybiByZXNpemVkO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGdyb3VwLCBhbGlnbmVkIHdpdGggdGhlIGF4aXNcbiAqIEByZXR1cm4ge0dyb3VwIHwgbnVsbH0gZmlyc3RHcm91cFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2ZpcnN0R3JvdXAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZpcnN0R3JvdXBJbmRleCA9ICh0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9PSAndG9wJykgPyAwIDogKHRoaXMuZ3JvdXBJZHMubGVuZ3RoIC0gMSk7XG4gIHZhciBmaXJzdEdyb3VwSWQgPSB0aGlzLmdyb3VwSWRzW2ZpcnN0R3JvdXBJbmRleF07XG4gIHZhciBmaXJzdEdyb3VwID0gdGhpcy5ncm91cHNbZmlyc3RHcm91cElkXSB8fCB0aGlzLmdyb3Vwc1tVTkdST1VQRURdO1xuXG4gIHJldHVybiBmaXJzdEdyb3VwIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBvciBkZWxldGUgdGhlIGdyb3VwIGhvbGRpbmcgYWxsIHVuZ3JvdXBlZCBpdGVtcy4gVGhpcyBncm91cCBpcyB1c2VkIHdoZW5cbiAqIHRoZXJlIGFyZSBubyBncm91cHMgc3BlY2lmaWVkLlxuICogQHByb3RlY3RlZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fdXBkYXRlVW5ncm91cGVkID0gZnVuY3Rpb24oKSB7XG4gIHZhciB1bmdyb3VwZWQgPSB0aGlzLmdyb3Vwc1tVTkdST1VQRURdO1xuICB2YXIgYmFja2dyb3VuZCA9IHRoaXMuZ3JvdXBzW0JBQ0tHUk9VTkRdO1xuICB2YXIgaXRlbSwgaXRlbUlkO1xuXG4gIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICAvLyByZW1vdmUgdGhlIGdyb3VwIGhvbGRpbmcgYWxsIHVuZ3JvdXBlZCBpdGVtc1xuICAgIGlmICh1bmdyb3VwZWQpIHtcbiAgICAgIHVuZ3JvdXBlZC5oaWRlKCk7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbVU5HUk9VUEVEXTtcblxuICAgICAgZm9yIChpdGVtSWQgaW4gdGhpcy5pdGVtcykge1xuICAgICAgICBpZiAodGhpcy5pdGVtcy5oYXNPd25Qcm9wZXJ0eShpdGVtSWQpKSB7XG4gICAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbaXRlbUlkXTtcbiAgICAgICAgICBpdGVtLnBhcmVudCAmJiBpdGVtLnBhcmVudC5yZW1vdmUoaXRlbSk7XG4gICAgICAgICAgdmFyIGdyb3VwSWQgPSB0aGlzLl9nZXRHcm91cElkKGl0ZW0uZGF0YSk7XG4gICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgICAgICAgZ3JvdXAgJiYgZ3JvdXAuYWRkKGl0ZW0pIHx8IGl0ZW0uaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBhIGdyb3VwIGhvbGRpbmcgYWxsICh1bmZpbHRlcmVkKSBpdGVtc1xuICAgIGlmICghdW5ncm91cGVkKSB7XG4gICAgICB2YXIgaWQgPSBudWxsO1xuICAgICAgdmFyIGRhdGEgPSBudWxsO1xuICAgICAgdW5ncm91cGVkID0gbmV3IEdyb3VwKGlkLCBkYXRhLCB0aGlzKTtcbiAgICAgIHRoaXMuZ3JvdXBzW1VOR1JPVVBFRF0gPSB1bmdyb3VwZWQ7XG5cbiAgICAgIGZvciAoaXRlbUlkIGluIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXMuaGFzT3duUHJvcGVydHkoaXRlbUlkKSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLml0ZW1zW2l0ZW1JZF07XG4gICAgICAgICAgdW5ncm91cGVkLmFkZChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1bmdyb3VwZWQuc2hvdygpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGVsZW1lbnQgZm9yIHRoZSBsYWJlbHNldFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IGxhYmVsU2V0XG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmdldExhYmVsU2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRvbS5sYWJlbFNldDtcbn07XG5cbi8qKlxuICogU2V0IGl0ZW1zXG4gKiBAcGFyYW0ge3Zpcy5EYXRhU2V0IHwgbnVsbH0gaXRlbXNcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuc2V0SXRlbXMgPSBmdW5jdGlvbihpdGVtcykge1xuICB2YXIgbWUgPSB0aGlzLFxuICAgICAgaWRzLFxuICAgICAgb2xkSXRlbXNEYXRhID0gdGhpcy5pdGVtc0RhdGE7XG5cbiAgLy8gcmVwbGFjZSB0aGUgZGF0YXNldFxuICBpZiAoIWl0ZW1zKSB7XG4gICAgdGhpcy5pdGVtc0RhdGEgPSBudWxsO1xuICB9XG4gIGVsc2UgaWYgKGl0ZW1zIGluc3RhbmNlb2YgRGF0YVNldCB8fCBpdGVtcyBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgdGhpcy5pdGVtc0RhdGEgPSBpdGVtcztcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEYXRhIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRGF0YVNldCBvciBEYXRhVmlldycpO1xuICB9XG5cbiAgaWYgKG9sZEl0ZW1zRGF0YSkge1xuICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gb2xkIGRhdGFzZXRcbiAgICB1dGlsLmZvckVhY2godGhpcy5pdGVtTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICBvbGRJdGVtc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgYWxsIGRyYXduIGl0ZW1zXG4gICAgaWRzID0gb2xkSXRlbXNEYXRhLmdldElkcygpO1xuICAgIHRoaXMuX29uUmVtb3ZlKGlkcyk7XG4gIH1cblxuICBpZiAodGhpcy5pdGVtc0RhdGEpIHtcbiAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgIHV0aWwuZm9yRWFjaCh0aGlzLml0ZW1MaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgIG1lLml0ZW1zRGF0YS5vbihldmVudCwgY2FsbGJhY2ssIGlkKTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBhbGwgbmV3IGl0ZW1zXG4gICAgaWRzID0gdGhpcy5pdGVtc0RhdGEuZ2V0SWRzKCk7XG4gICAgdGhpcy5fb25BZGQoaWRzKTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgZ3JvdXAgaG9sZGluZyBhbGwgdW5ncm91cGVkIGl0ZW1zXG4gICAgdGhpcy5fdXBkYXRlVW5ncm91cGVkKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGl0ZW1zXG4gKiBAcmV0dXJucyB7dmlzLkRhdGFTZXQgfCBudWxsfVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5nZXRJdGVtcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pdGVtc0RhdGE7XG59O1xuXG4vKipcbiAqIFNldCBncm91cHNcbiAqIEBwYXJhbSB7dmlzLkRhdGFTZXR9IGdyb3Vwc1xuICovXG5JdGVtU2V0LnByb3RvdHlwZS5zZXRHcm91cHMgPSBmdW5jdGlvbihncm91cHMpIHtcbiAgdmFyIG1lID0gdGhpcyxcbiAgICAgIGlkcztcblxuICAvLyB1bnN1YnNjcmliZSBmcm9tIGN1cnJlbnQgZGF0YXNldFxuICBpZiAodGhpcy5ncm91cHNEYXRhKSB7XG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuZ3JvdXBMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgIG1lLmdyb3Vwc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgYWxsIGRyYXduIGdyb3Vwc1xuICAgIGlkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoKTtcbiAgICB0aGlzLmdyb3Vwc0RhdGEgPSBudWxsO1xuICAgIHRoaXMuX29uUmVtb3ZlR3JvdXBzKGlkcyk7IC8vIG5vdGU6IHRoaXMgd2lsbCBjYXVzZSBhIHJlZHJhd1xuICB9XG5cbiAgLy8gcmVwbGFjZSB0aGUgZGF0YXNldFxuICBpZiAoIWdyb3Vwcykge1xuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IG51bGw7XG4gIH1cbiAgZWxzZSBpZiAoZ3JvdXBzIGluc3RhbmNlb2YgRGF0YVNldCB8fCBncm91cHMgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHRoaXMuZ3JvdXBzRGF0YSA9IGdyb3VwcztcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEYXRhIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRGF0YVNldCBvciBEYXRhVmlldycpO1xuICB9XG5cbiAgaWYgKHRoaXMuZ3JvdXBzRGF0YSkge1xuICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgdXRpbC5mb3JFYWNoKHRoaXMuZ3JvdXBMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgIG1lLmdyb3Vwc0RhdGEub24oZXZlbnQsIGNhbGxiYWNrLCBpZCk7XG4gICAgfSk7XG5cbiAgICAvLyBkcmF3IGFsbCBtc1xuICAgIGlkcyA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoKTtcbiAgICB0aGlzLl9vbkFkZEdyb3VwcyhpZHMpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHRoZSBncm91cCBob2xkaW5nIGFsbCB1bmdyb3VwZWQgaXRlbXNcbiAgdGhpcy5fdXBkYXRlVW5ncm91cGVkKCk7XG5cbiAgLy8gdXBkYXRlIHRoZSBvcmRlciBvZiBhbGwgaXRlbXMgaW4gZWFjaCBncm91cFxuICB0aGlzLl9vcmRlcigpO1xuXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHtxdWV1ZTogdHJ1ZX0pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgZ3JvdXBzXG4gKiBAcmV0dXJucyB7dmlzLkRhdGFTZXQgfCBudWxsfSBncm91cHNcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuZ2V0R3JvdXBzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdyb3Vwc0RhdGE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGJ5IGl0cyBpZFxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGlkXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbihpZCkge1xuICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNEYXRhLmdldChpZCksXG4gICAgICBkYXRhc2V0ID0gdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpO1xuXG4gIGlmIChpdGVtKSB7XG4gICAgLy8gY29uZmlybSBkZWxldGlvblxuICAgIHRoaXMub3B0aW9ucy5vblJlbW92ZShpdGVtLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgLy8gcmVtb3ZlIGJ5IGlkIGhlcmUsIGl0IGlzIHBvc3NpYmxlIHRoYXQgYW4gaXRlbSBoYXMgbm8gaWQgZGVmaW5lZFxuICAgICAgICAvLyBpdHNlbGYsIHNvIGJldHRlciBub3QgZGVsZXRlIGJ5IHRoZSBpdGVtIGl0c2VsZlxuICAgICAgICBkYXRhc2V0LnJlbW92ZShpZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSB0aW1lIG9mIGFuIGl0ZW0gYmFzZWQgb24gaXQncyBkYXRhIGFuZCBvcHRpb25zLnR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRGF0YVxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHlwZVxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2dldFR5cGUgPSBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgcmV0dXJuIGl0ZW1EYXRhLnR5cGUgfHwgdGhpcy5vcHRpb25zLnR5cGUgfHwgKGl0ZW1EYXRhLmVuZCA/ICdyYW5nZScgOiAnYm94Jyk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBncm91cCBpZCBmb3IgYW4gaXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1EYXRhXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBncm91cElkXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fZ2V0R3JvdXBJZCA9IGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICB2YXIgdHlwZSA9IHRoaXMuX2dldFR5cGUoaXRlbURhdGEpO1xuICBpZiAodHlwZSA9PSAnYmFja2dyb3VuZCcgJiYgaXRlbURhdGEuZ3JvdXAgPT0gdW5kZWZpbmVkKSB7XG4gICByZXR1cm4gQkFDS0dST1VORDtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cHNEYXRhID8gaXRlbURhdGEuZ3JvdXAgOiBVTkdST1VQRUQ7XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIHVwZGF0ZWQgaXRlbXNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByb3RlY3RlZFxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25VcGRhdGUgPSBmdW5jdGlvbihpZHMpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbURhdGEgPSBtZS5pdGVtc0RhdGEuZ2V0KGlkLCBtZS5pdGVtT3B0aW9ucyk7XG4gICAgdmFyIGl0ZW0gPSBtZS5pdGVtc1tpZF07XG4gICAgdmFyIHR5cGUgPSBtZS5fZ2V0VHlwZShpdGVtRGF0YSk7XG5cbiAgICB2YXIgY29uc3RydWN0b3IgPSBJdGVtU2V0LnR5cGVzW3R5cGVdO1xuICAgIHZhciBzZWxlY3RlZDtcblxuICAgIGlmIChpdGVtKSB7XG4gICAgICAvLyB1cGRhdGUgaXRlbVxuICAgICAgaWYgKCFjb25zdHJ1Y3RvciB8fCAhKGl0ZW0gaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgLy8gaXRlbSB0eXBlIGhhcyBjaGFuZ2VkLCBkZWxldGUgdGhlIGl0ZW0gYW5kIHJlY3JlYXRlIGl0XG4gICAgICAgIHNlbGVjdGVkID0gaXRlbS5zZWxlY3RlZDsgLy8gcHJlc2VydmUgc2VsZWN0aW9uIG9mIHRoaXMgaXRlbVxuICAgICAgICBtZS5fcmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgaXRlbSA9IG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWUuX3VwZGF0ZUl0ZW0oaXRlbSwgaXRlbURhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXRlbSkge1xuICAgICAgLy8gY3JlYXRlIGl0ZW1cbiAgICAgIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICBpdGVtID0gbmV3IGNvbnN0cnVjdG9yKGl0ZW1EYXRhLCBtZS5jb252ZXJzaW9uLCBtZS5vcHRpb25zKTtcbiAgICAgICAgaXRlbS5pZCA9IGlkOyAvLyBUT0RPOiBub3Qgc28gbmljZSBzZXR0aW5nIGlkIGFmdGVyd2FyZHNcbiAgICAgICAgbWUuX2FkZEl0ZW0oaXRlbSk7XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnB1c2goaWQpO1xuICAgICAgICAgIGl0ZW0uc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gJ3Jhbmdlb3ZlcmZsb3cnKSB7XG4gICAgICAgIC8vIFRPRE86IGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuMCAob3IgMy4wLjA/KS4gY2xlYW51cCBzb21lIGRheVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJdGVtIHR5cGUgXCJyYW5nZW92ZXJmbG93XCIgaXMgZGVwcmVjYXRlZC4gVXNlIGNzcyBzdHlsaW5nIGluc3RlYWQ6ICcgK1xuICAgICAgICAgICAgJy52aXMtaXRlbS52aXMtcmFuZ2UgLnZpcy1pdGVtLWNvbnRlbnQge292ZXJmbG93OiB2aXNpYmxlO30nKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGl0ZW0gdHlwZSBcIicgKyB0eXBlICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuICB9LmJpbmQodGhpcykpO1xuXG4gIHRoaXMuX29yZGVyKCk7XG4gIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7cXVldWU6IHRydWV9KTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGFkZGVkIGl0ZW1zXG4gKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uQWRkID0gSXRlbVNldC5wcm90b3R5cGUuX29uVXBkYXRlO1xuXG4vKipcbiAqIEhhbmRsZSByZW1vdmVkIGl0ZW1zXG4gKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uUmVtb3ZlID0gZnVuY3Rpb24oaWRzKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBtZSA9IHRoaXM7XG4gIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gbWUuaXRlbXNbaWRdO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjb3VudCsrO1xuICAgICAgbWUuX3JlbW92ZUl0ZW0oaXRlbSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoY291bnQpIHtcbiAgICAvLyB1cGRhdGUgb3JkZXJcbiAgICB0aGlzLl9vcmRlcigpO1xuICAgIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHtxdWV1ZTogdHJ1ZX0pO1xuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgb3JkZXIgb2YgaXRlbSBpbiBhbGwgZ3JvdXBzXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmVvcmRlciB0aGUgaXRlbXMgaW4gYWxsIGdyb3Vwc1xuICAvLyBUT0RPOiBvcHRpbWl6YXRpb246IG9ubHkgcmVvcmRlciBncm91cHMgYWZmZWN0ZWQgYnkgdGhlIGNoYW5nZWQgaXRlbXNcbiAgdXRpbC5mb3JFYWNoKHRoaXMuZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICBncm91cC5vcmRlcigpO1xuICB9KTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHVwZGF0ZWQgZ3JvdXBzXG4gKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vblVwZGF0ZUdyb3VwcyA9IGZ1bmN0aW9uKGlkcykge1xuICB0aGlzLl9vbkFkZEdyb3VwcyhpZHMpO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgY2hhbmdlZCBncm91cHMgKGFkZGVkIG9yIHVwZGF0ZWQpXG4gKiBAcGFyYW0ge051bWJlcltdfSBpZHNcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vbkFkZEdyb3VwcyA9IGZ1bmN0aW9uKGlkcykge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBncm91cERhdGEgPSBtZS5ncm91cHNEYXRhLmdldChpZCk7XG4gICAgdmFyIGdyb3VwID0gbWUuZ3JvdXBzW2lkXTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIC8vIGNoZWNrIGZvciByZXNlcnZlZCBpZHNcbiAgICAgIGlmIChpZCA9PSBVTkdST1VQRUQgfHwgaWQgPT0gQkFDS0dST1VORCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgZ3JvdXAgaWQuICcgKyBpZCArICcgaXMgYSByZXNlcnZlZCBpZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyb3VwT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobWUub3B0aW9ucyk7XG4gICAgICB1dGlsLmV4dGVuZChncm91cE9wdGlvbnMsIHtcbiAgICAgICAgaGVpZ2h0OiBudWxsXG4gICAgICB9KTtcblxuICAgICAgZ3JvdXAgPSBuZXcgR3JvdXAoaWQsIGdyb3VwRGF0YSwgbWUpO1xuICAgICAgbWUuZ3JvdXBzW2lkXSA9IGdyb3VwO1xuXG4gICAgICAvLyBhZGQgaXRlbXMgd2l0aCB0aGlzIGdyb3VwSWQgdG8gdGhlIG5ldyBncm91cFxuICAgICAgZm9yICh2YXIgaXRlbUlkIGluIG1lLml0ZW1zKSB7XG4gICAgICAgIGlmIChtZS5pdGVtcy5oYXNPd25Qcm9wZXJ0eShpdGVtSWQpKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBtZS5pdGVtc1tpdGVtSWRdO1xuICAgICAgICAgIGlmIChpdGVtLmRhdGEuZ3JvdXAgPT0gaWQpIHtcbiAgICAgICAgICAgIGdyb3VwLmFkZChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ3JvdXAub3JkZXIoKTtcbiAgICAgIGdyb3VwLnNob3coKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgZ3JvdXBcbiAgICAgIGdyb3VwLnNldERhdGEoZ3JvdXBEYXRhKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHtxdWV1ZTogdHJ1ZX0pO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgcmVtb3ZlZCBncm91cHNcbiAqIEBwYXJhbSB7TnVtYmVyW119IGlkc1xuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uUmVtb3ZlR3JvdXBzID0gZnVuY3Rpb24oaWRzKSB7XG4gIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcbiAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGdyb3VwID0gZ3JvdXBzW2lkXTtcblxuICAgIGlmIChncm91cCkge1xuICAgICAgZ3JvdXAuaGlkZSgpO1xuICAgICAgZGVsZXRlIGdyb3Vwc1tpZF07XG4gICAgfVxuICB9KTtcblxuICB0aGlzLm1hcmtEaXJ0eSgpO1xuXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHtxdWV1ZTogdHJ1ZX0pO1xufTtcblxuLyoqXG4gKiBSZW9yZGVyIHRoZSBncm91cHMgaWYgbmVlZGVkXG4gKiBAcmV0dXJuIHtib29sZWFufSBjaGFuZ2VkXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb3JkZXJHcm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmdyb3Vwc0RhdGEpIHtcbiAgICAvLyByZW9yZGVyIHRoZSBncm91cHNcbiAgICB2YXIgZ3JvdXBJZHMgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKHtcbiAgICAgIG9yZGVyOiB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclxuICAgIH0pO1xuXG4gICAgdmFyIGNoYW5nZWQgPSAhdXRpbC5lcXVhbEFycmF5KGdyb3VwSWRzLCB0aGlzLmdyb3VwSWRzKTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgLy8gaGlkZSBhbGwgZ3JvdXBzLCByZW1vdmVzIHRoZW0gZnJvbSB0aGUgRE9NXG4gICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgICBncm91cElkcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cElkKSB7XG4gICAgICAgIGdyb3Vwc1tncm91cElkXS5oaWRlKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gc2hvdyB0aGUgZ3JvdXBzIGFnYWluLCBhdHRhY2ggdGhlbSB0byB0aGUgRE9NIGluIGNvcnJlY3Qgb3JkZXJcbiAgICAgIGdyb3VwSWRzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwSWQpIHtcbiAgICAgICAgZ3JvdXBzW2dyb3VwSWRdLnNob3coKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmdyb3VwSWRzID0gZ3JvdXBJZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIG5ldyBpdGVtXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9hZGRJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB0aGlzLml0ZW1zW2l0ZW0uaWRdID0gaXRlbTtcblxuICAvLyBhZGQgdG8gZ3JvdXBcbiAgdmFyIGdyb3VwSWQgPSB0aGlzLl9nZXRHcm91cElkKGl0ZW0uZGF0YSk7XG4gIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICBpZiAoZ3JvdXApIGdyb3VwLmFkZChpdGVtKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGFuIGV4aXN0aW5nIGl0ZW1cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1EYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fdXBkYXRlSXRlbSA9IGZ1bmN0aW9uKGl0ZW0sIGl0ZW1EYXRhKSB7XG4gIHZhciBvbGRHcm91cElkID0gaXRlbS5kYXRhLmdyb3VwO1xuICB2YXIgb2xkU3ViR3JvdXBJZCA9IGl0ZW0uZGF0YS5zdWJncm91cDtcblxuICAvLyB1cGRhdGUgdGhlIGl0ZW1zIGRhdGEgKHdpbGwgcmVkcmF3IHRoZSBpdGVtIHdoZW4gZGlzcGxheWVkKVxuICBpdGVtLnNldERhdGEoaXRlbURhdGEpO1xuXG4gIC8vIHVwZGF0ZSBncm91cFxuICBpZiAob2xkR3JvdXBJZCAhPSBpdGVtLmRhdGEuZ3JvdXAgfHwgb2xkU3ViR3JvdXBJZCAhPSBpdGVtLmRhdGEuc3ViZ3JvdXApIHtcbiAgICB2YXIgb2xkR3JvdXAgPSB0aGlzLmdyb3Vwc1tvbGRHcm91cElkXTtcbiAgICBpZiAob2xkR3JvdXApIG9sZEdyb3VwLnJlbW92ZShpdGVtKTtcblxuICAgIHZhciBncm91cElkID0gdGhpcy5fZ2V0R3JvdXBJZChpdGVtLmRhdGEpO1xuICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICAgIGlmIChncm91cCkgZ3JvdXAuYWRkKGl0ZW0pO1xuICB9XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhbiBpdGVtIGZyb20gdGhlIEl0ZW1TZXQ6IHJlbW92ZSBpdCBmcm9tIHRoZSBET00sIGZyb20gdGhlIG1hcFxuICogd2l0aCBpdGVtcywgYW5kIGZyb20gdGhlIG1hcCB3aXRoIHZpc2libGUgaXRlbXMsIGFuZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX3JlbW92ZUl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIC8vIHJlbW92ZSBmcm9tIERPTVxuICBpdGVtLmhpZGUoKTtcblxuICAvLyByZW1vdmUgZnJvbSBpdGVtc1xuICBkZWxldGUgdGhpcy5pdGVtc1tpdGVtLmlkXTtcblxuICAvLyByZW1vdmUgZnJvbSBzZWxlY3Rpb25cbiAgdmFyIGluZGV4ID0gdGhpcy5zZWxlY3Rpb24uaW5kZXhPZihpdGVtLmlkKTtcbiAgaWYgKGluZGV4ICE9IC0xKSB0aGlzLnNlbGVjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIC8vIHJlbW92ZSBmcm9tIGdyb3VwXG4gIGl0ZW0ucGFyZW50ICYmIGl0ZW0ucGFyZW50LnJlbW92ZShpdGVtKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGl0ZW1zIGJlaW5nIGEgcmFuZ2UgKGhhdmluZyBhbiBlbmQgZGF0ZSlcbiAqIEBwYXJhbSBhcnJheVxuICogQHJldHVybnMge0FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2NvbnN0cnVjdEJ5RW5kQXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xuICB2YXIgZW5kQXJyYXkgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldIGluc3RhbmNlb2YgUmFuZ2VJdGVtKSB7XG4gICAgICBlbmRBcnJheS5wdXNoKGFycmF5W2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZEFycmF5O1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGUgY2xpY2tlZCBpdGVtIG9uIHRvdWNoLCBiZWZvcmUgZHJhZ1N0YXJ0IGlzIGluaXRpYXRlZC5cbiAqXG4gKiBkcmFnU3RhcnQgaXMgaW5pdGlhdGVkIGZyb20gYSBtb3VzZW1vdmUgZXZlbnQsIEFGVEVSIHRoZSBtb3VzZS90b3VjaCBpc1xuICogYWxyZWFkeSBtb3ZpbmcuIFRoZXJlZm9yZSwgdGhlIG1vdXNlL3RvdWNoIGNhbiBzb21ldGltZXMgYmUgYWJvdmUgYW4gb3RoZXJcbiAqIERPTSBlbGVtZW50IHRoYW4gdGhlIGl0ZW0gaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25Ub3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBzdG9yZSB0aGUgdG91Y2hlZCBpdGVtLCB1c2VkIGluIF9vbkRyYWdTdGFydFxuICB0aGlzLnRvdWNoUGFyYW1zLml0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcbiAgdGhpcy50b3VjaFBhcmFtcy5kcmFnTGVmdEl0ZW0gPSBldmVudC50YXJnZXQuZHJhZ0xlZnRJdGVtIHx8IGZhbHNlO1xuICB0aGlzLnRvdWNoUGFyYW1zLmRyYWdSaWdodEl0ZW0gPSBldmVudC50YXJnZXQuZHJhZ1JpZ2h0SXRlbSB8fCBmYWxzZTtcbiAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBudWxsO1xufTtcblxuXG4vKipcbiAqIEdpdmVuIGFuIGdyb3VwIGlkLCByZXR1cm5zIHRoZSBpbmRleCBpdCBoYXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGdyb3VwSURcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9nZXRHcm91cEluZGV4ID0gZnVuY3Rpb24oZ3JvdXBJZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncm91cElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZ3JvdXBJZCA9PSB0aGlzLmdyb3VwSWRzW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTdGFydCBkcmFnZ2luZyB0aGUgc2VsZWN0ZWQgZXZlbnRzXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBpdGVtID0gdGhpcy50b3VjaFBhcmFtcy5pdGVtIHx8IG51bGw7XG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBwcm9wcztcblxuICBpZiAoaXRlbSAmJiBpdGVtLnNlbGVjdGVkKSB7XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lICYmXG4gICAgICAgICF0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlR3JvdXAgJiZcbiAgICAgICAgIWl0ZW0uZWRpdGFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZSBvcHRpb25zLmVkaXRhYmxlXG4gICAgaWYgKGl0ZW0uZWRpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRyYWdMZWZ0SXRlbSA9IHRoaXMudG91Y2hQYXJhbXMuZHJhZ0xlZnRJdGVtO1xuICAgIHZhciBkcmFnUmlnaHRJdGVtID0gdGhpcy50b3VjaFBhcmFtcy5kcmFnUmlnaHRJdGVtO1xuXG4gICAgaWYgKGRyYWdMZWZ0SXRlbSkge1xuICAgICAgcHJvcHMgPSB7XG4gICAgICAgIGl0ZW06IGRyYWdMZWZ0SXRlbSxcbiAgICAgICAgaW5pdGlhbFg6IGV2ZW50LmNlbnRlci54LFxuICAgICAgICBkcmFnTGVmdDogIHRydWUsXG4gICAgICAgIGRhdGE6IHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbS5kYXRhKVxuICAgICAgfTtcblxuICAgICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBbcHJvcHNdO1xuICAgIH1cbiAgICBlbHNlIGlmIChkcmFnUmlnaHRJdGVtKSB7XG4gICAgICBwcm9wcyA9IHtcbiAgICAgICAgaXRlbTogZHJhZ1JpZ2h0SXRlbSxcbiAgICAgICAgaW5pdGlhbFg6IGV2ZW50LmNlbnRlci54LFxuICAgICAgICBkcmFnUmlnaHQ6IHRydWUsXG4gICAgICAgIGRhdGE6IHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbS5kYXRhKVxuICAgICAgfTtcblxuICAgICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBbcHJvcHNdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMudG91Y2hQYXJhbXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcblxuICAgICAgdmFyIGJhc2VHcm91cEluZGV4ID0gdGhpcy5fZ2V0R3JvdXBJbmRleChpdGVtLmRhdGEuZ3JvdXApO1xuXG4gICAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgaXRlbSA9IG1lLml0ZW1zW2lkXTtcbiAgICAgICAgdmFyIGdyb3VwSW5kZXggPSBtZS5fZ2V0R3JvdXBJbmRleChpdGVtLmRhdGEuZ3JvdXApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgaW5pdGlhbFg6IGV2ZW50LmNlbnRlci54LFxuICAgICAgICAgIGdyb3VwT2Zmc2V0OiBiYXNlR3JvdXBJbmRleC1ncm91cEluZGV4LFxuICAgICAgICAgIGRhdGE6IHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbS5kYXRhKVxuICAgICAgICB9O1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWRpdGFibGUuYWRkICYmIChldmVudC5zcmNFdmVudC5jdHJsS2V5IHx8IGV2ZW50LnNyY0V2ZW50Lm1ldGFLZXkpKSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHJhbmdlIGl0ZW0gd2hlbiBkcmFnZ2luZyB3aXRoIGN0cmwga2V5IGRvd25cbiAgICB0aGlzLl9vbkRyYWdTdGFydEFkZEl0ZW0oZXZlbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0IGNyZWF0aW5nIGEgbmV3IHJhbmdlIGl0ZW0gYnkgZHJhZ2dpbmcuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0QWRkSXRlbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgc25hcCA9IHRoaXMub3B0aW9ucy5zbmFwIHx8IG51bGw7XG4gIHZhciB4QWJzID0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5kb20uZnJhbWUpO1xuICB2YXIgeCA9IGV2ZW50LmNlbnRlci54IC0geEFicyAtIDEwOyAgLy8gbWludXMgMTAgdG8gY29tcGVuc2F0ZSBmb3IgdGhlIGRyYWcgc3RhcnRpbmcgYXMgc29vbiBhcyB5b3UndmUgbW92ZWQgMTBweFxuICB2YXIgdGltZSA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4KTtcbiAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnV0aWwuZ2V0U2NhbGUoKTtcbiAgdmFyIHN0ZXAgPSB0aGlzLmJvZHkudXRpbC5nZXRTdGVwKCk7XG4gIHZhciBzdGFydCA9IHNuYXAgPyBzbmFwKHRpbWUsIHNjYWxlLCBzdGVwKSA6IHN0YXJ0O1xuICB2YXIgZW5kID0gc3RhcnQ7XG5cbiAgdmFyIGl0ZW1EYXRhID0ge1xuICAgIHR5cGU6ICdyYW5nZScsXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kLFxuICAgIGNvbnRlbnQ6ICduZXcgaXRlbSdcbiAgfTtcblxuICB2YXIgaWQgPSB1dGlsLnJhbmRvbVVVSUQoKTtcbiAgaXRlbURhdGFbdGhpcy5pdGVtc0RhdGEuX2ZpZWxkSWRdID0gaWQ7XG5cbiAgdmFyIGdyb3VwID0gdGhpcy5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuICBpZiAoZ3JvdXApIHtcbiAgICBpdGVtRGF0YS5ncm91cCA9IGdyb3VwLmdyb3VwSWQ7XG4gIH1cblxuICB2YXIgbmV3SXRlbSA9IG5ldyBSYW5nZUl0ZW0oaXRlbURhdGEsIHRoaXMuY29udmVyc2lvbiwgdGhpcy5vcHRpb25zKTtcbiAgbmV3SXRlbS5pZCA9IGlkOyAvLyBUT0RPOiBub3Qgc28gbmljZSBzZXR0aW5nIGlkIGFmdGVyd2FyZHNcbiAgbmV3SXRlbS5kYXRhID0gdGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtRGF0YSk7XG4gIHRoaXMuX2FkZEl0ZW0obmV3SXRlbSk7XG5cbiAgdmFyIHByb3BzID0ge1xuICAgIGl0ZW06IG5ld0l0ZW0sXG4gICAgZHJhZ1JpZ2h0OiB0cnVlLFxuICAgIGluaXRpYWxYOiBldmVudC5jZW50ZXIueCxcbiAgICBkYXRhOiBuZXdJdGVtLmRhdGFcbiAgfTtcbiAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMgPSBbcHJvcHNdO1xuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuLyoqXG4gKiBEcmFnIHNlbGVjdGVkIGl0ZW1zXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAodGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIHNuYXAgPSB0aGlzLm9wdGlvbnMuc25hcCB8fCBudWxsO1xuICAgIHZhciB4T2Zmc2V0ID0gdGhpcy5ib2R5LmRvbS5yb290Lm9mZnNldExlZnQgKyB0aGlzLmJvZHkuZG9tUHJvcHMubGVmdC53aWR0aDtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudXRpbC5nZXRTY2FsZSgpO1xuICAgIHZhciBzdGVwID0gdGhpcy5ib2R5LnV0aWwuZ2V0U3RlcCgpO1xuXG4gICAgLy9vbmx5IGNhbGN1bGF0ZSB0aGUgbmV3IGdyb3VwIGZvciB0aGUgaXRlbSB0aGF0J3MgYWN0dWFsbHkgZHJhZ2dlZFxuICAgIHZhciBzZWxlY3RlZEl0ZW0gPSB0aGlzLnRvdWNoUGFyYW1zLnNlbGVjdGVkSXRlbTtcbiAgICB2YXIgdXBkYXRlR3JvdXBBbGxvd2VkID0gbWUub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cDtcbiAgICB2YXIgbmV3R3JvdXBCYXNlID0gbnVsbDtcbiAgICBpZiAodXBkYXRlR3JvdXBBbGxvd2VkICYmIHNlbGVjdGVkSXRlbSkge1xuICAgICAgaWYgKHNlbGVjdGVkSXRlbS5kYXRhLmdyb3VwICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBkcmFnIGZyb20gb25lIGdyb3VwIHRvIGFub3RoZXJcbiAgICAgICAgdmFyIGdyb3VwID0gbWUuZ3JvdXBGcm9tVGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgLy93ZSBrbm93IHRoZSBvZmZzZXQgZm9yIGFsbCBpdGVtcywgc28gdGhlIG5ldyBncm91cCBmb3IgYWxsIGl0ZW1zXG4gICAgICAgICAgLy93aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMgb25lLlxuICAgICAgICAgIG5ld0dyb3VwQmFzZSA9IHRoaXMuX2dldEdyb3VwSW5kZXgoZ3JvdXAuZ3JvdXBJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtb3ZlXG4gICAgdGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gbWUuYm9keS51dGlsLnRvVGltZShldmVudC5jZW50ZXIueCAtIHhPZmZzZXQpO1xuICAgICAgdmFyIGluaXRpYWwgPSBtZS5ib2R5LnV0aWwudG9UaW1lKHByb3BzLmluaXRpYWxYIC0geE9mZnNldCk7XG4gICAgICB2YXIgb2Zmc2V0ID0gY3VycmVudCAtIGluaXRpYWw7IC8vIG1zXG5cbiAgICAgIHZhciBpdGVtRGF0YSA9IHRoaXMuX2Nsb25lSXRlbURhdGEocHJvcHMuaXRlbS5kYXRhKTsgLy8gY2xvbmUgdGhlIGRhdGFcbiAgICAgIGlmIChwcm9wcy5pdGVtLmVkaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVUaW1lQWxsb3dlZCA9IG1lLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fFxuICAgICAgICAgIHByb3BzLml0ZW0uZWRpdGFibGUgPT09IHRydWU7XG5cbiAgICAgIGlmICh1cGRhdGVUaW1lQWxsb3dlZCkge1xuICAgICAgICBpZiAocHJvcHMuZHJhZ0xlZnQpIHtcbiAgICAgICAgICAvLyBkcmFnIGxlZnQgc2lkZSBvZiBhIHJhbmdlIGl0ZW1cbiAgICAgICAgICBpZiAoaXRlbURhdGEuc3RhcnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFN0YXJ0ID0gdXRpbC5jb252ZXJ0KHByb3BzLmRhdGEuc3RhcnQsICdEYXRlJyk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShpbml0aWFsU3RhcnQudmFsdWVPZigpICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBNb21lbnQgaW5zdGVhZCBvZiBhIERhdGUgdG8gc25hcCgpLiAoQnJlYWtpbmcgY2hhbmdlKVxuICAgICAgICAgICAgaXRlbURhdGEuc3RhcnQgPSBzbmFwID8gc25hcChzdGFydCwgc2NhbGUsIHN0ZXApIDogc3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3BzLmRyYWdSaWdodCkge1xuICAgICAgICAgIC8vIGRyYWcgcmlnaHQgc2lkZSBvZiBhIHJhbmdlIGl0ZW1cbiAgICAgICAgICBpZiAoaXRlbURhdGEuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxFbmQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5lbmQsICdEYXRlJyk7XG4gICAgICAgICAgICB2YXIgZW5kID0gbmV3IERhdGUoaW5pdGlhbEVuZC52YWx1ZU9mKCkgKyBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIE1vbWVudCBpbnN0ZWFkIG9mIGEgRGF0ZSB0byBzbmFwKCkuIChCcmVha2luZyBjaGFuZ2UpXG4gICAgICAgICAgICBpdGVtRGF0YS5lbmQgPSBzbmFwID8gc25hcChlbmQsIHNjYWxlLCBzdGVwKSA6IGVuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gZHJhZyBib3RoIHN0YXJ0IGFuZCBlbmRcbiAgICAgICAgICBpZiAoaXRlbURhdGEuc3RhcnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFN0YXJ0ID0gdXRpbC5jb252ZXJ0KHByb3BzLmRhdGEuc3RhcnQsICdEYXRlJykudmFsdWVPZigpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoaW5pdGlhbFN0YXJ0ICsgb2Zmc2V0KTtcblxuICAgICAgICAgICAgaWYgKGl0ZW1EYXRhLmVuZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdmFyIGluaXRpYWxFbmQgPSB1dGlsLmNvbnZlcnQocHJvcHMuZGF0YS5lbmQsICdEYXRlJyk7XG4gICAgICAgICAgICAgIHZhciBkdXJhdGlvbiAgPSBpbml0aWFsRW5kLnZhbHVlT2YoKSAtIGluaXRpYWxTdGFydC52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBhIE1vbWVudCBpbnN0ZWFkIG9mIGEgRGF0ZSB0byBzbmFwKCkuIChCcmVha2luZyBjaGFuZ2UpXG4gICAgICAgICAgICAgIGl0ZW1EYXRhLnN0YXJ0ID0gc25hcCA/IHNuYXAoc3RhcnQsIHNjYWxlLCBzdGVwKSA6IHN0YXJ0O1xuICAgICAgICAgICAgICBpdGVtRGF0YS5lbmQgICA9IG5ldyBEYXRlKGl0ZW1EYXRhLnN0YXJ0LnZhbHVlT2YoKSArIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGEgTW9tZW50IGluc3RlYWQgb2YgYSBEYXRlIHRvIHNuYXAoKS4gKEJyZWFraW5nIGNoYW5nZSlcbiAgICAgICAgICAgICAgaXRlbURhdGEuc3RhcnQgPSBzbmFwID8gc25hcChzdGFydCwgc2NhbGUsIHN0ZXApIDogc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVHcm91cEFsbG93ZWQgPSBtZS5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwIHx8XG4gICAgICAgICAgcHJvcHMuaXRlbS5lZGl0YWJsZSA9PT0gdHJ1ZTtcblxuICAgICAgaWYgKHVwZGF0ZUdyb3VwQWxsb3dlZCAmJiAoIXByb3BzLmRyYWdMZWZ0ICYmICFwcm9wcy5kcmFnUmlnaHQpICYmIG5ld0dyb3VwQmFzZSE9bnVsbCkge1xuICAgICAgICBpZiAoaXRlbURhdGEuZ3JvdXAgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG5ld09mZnNldCA9IG5ld0dyb3VwQmFzZSAtIHByb3BzLmdyb3VwT2Zmc2V0O1xuXG4gICAgICAgICAgLy9tYWtlIHN1cmUgd2Ugc3RheSBpbiBib3VuZHNcbiAgICAgICAgICBuZXdPZmZzZXQgPSBNYXRoLm1heCgwLCBuZXdPZmZzZXQpO1xuICAgICAgICAgIG5ld09mZnNldCA9IE1hdGgubWluKG1lLmdyb3VwSWRzLmxlbmd0aC0xLCBuZXdPZmZzZXQpO1xuXG4gICAgICAgICAgaXRlbURhdGEuZ3JvdXAgPSBtZS5ncm91cElkc1tuZXdPZmZzZXRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbmZpcm0gbW92aW5nIHRoZSBpdGVtXG4gICAgICBpdGVtRGF0YSA9IHRoaXMuX2Nsb25lSXRlbURhdGEoaXRlbURhdGEpOyAgLy8gY29udmVydCBzdGFydCBhbmQgZW5kIHRvIHRoZSBjb3JyZWN0IHR5cGVcbiAgICAgIG1lLm9wdGlvbnMub25Nb3ZpbmcoaXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgICBpZiAoaXRlbURhdGEpIHtcbiAgICAgICAgICBwcm9wcy5pdGVtLnNldERhdGEodGhpcy5fY2xvbmVJdGVtRGF0YShpdGVtRGF0YSwgJ0RhdGUnKSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScpO1xuICB9XG59O1xuXG4vKipcbiAqIE1vdmUgYW4gaXRlbSB0byBhbm90aGVyIGdyb3VwXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBncm91cElkXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fbW92ZVRvR3JvdXAgPSBmdW5jdGlvbihpdGVtLCBncm91cElkKSB7XG4gIHZhciBncm91cCA9IHRoaXMuZ3JvdXBzW2dyb3VwSWRdO1xuICBpZiAoZ3JvdXAgJiYgZ3JvdXAuZ3JvdXBJZCAhPSBpdGVtLmRhdGEuZ3JvdXApIHtcbiAgICB2YXIgb2xkR3JvdXAgPSBpdGVtLnBhcmVudDtcbiAgICBvbGRHcm91cC5yZW1vdmUoaXRlbSk7XG4gICAgb2xkR3JvdXAub3JkZXIoKTtcbiAgICBncm91cC5hZGQoaXRlbSk7XG4gICAgZ3JvdXAub3JkZXIoKTtcblxuICAgIGl0ZW0uZGF0YS5ncm91cCA9IGdyb3VwLmdyb3VwSWQ7XG4gIH1cbn07XG5cbi8qKlxuICogRW5kIG9mIGRyYWdnaW5nIHNlbGVjdGVkIGl0ZW1zXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAodGhpcy50b3VjaFBhcmFtcy5pdGVtUHJvcHMpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGRhdGFzZXQgPSB0aGlzLml0ZW1zRGF0YS5nZXREYXRhU2V0KCk7XG4gICAgdmFyIGl0ZW1Qcm9wcyA9IHRoaXMudG91Y2hQYXJhbXMuaXRlbVByb3BzIDtcbiAgICB0aGlzLnRvdWNoUGFyYW1zLml0ZW1Qcm9wcyA9IG51bGw7XG5cbiAgICBpdGVtUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgIHZhciBpZCA9IHByb3BzLml0ZW0uaWQ7XG4gICAgICB2YXIgZXhpc3RzID0gbWUuaXRlbXNEYXRhLmdldChpZCwgbWUuaXRlbU9wdGlvbnMpICE9IG51bGw7XG5cbiAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgIC8vIGFkZCBhIG5ldyBpdGVtXG4gICAgICAgIG1lLm9wdGlvbnMub25BZGQocHJvcHMuaXRlbS5kYXRhLCBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICAgICAgICBtZS5fcmVtb3ZlSXRlbShwcm9wcy5pdGVtKTsgLy8gcmVtb3ZlIHRlbXBvcmFyeSBpdGVtXG4gICAgICAgICAgaWYgKGl0ZW1EYXRhKSB7XG4gICAgICAgICAgICBtZS5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpLmFkZChpdGVtRGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZm9yY2UgcmUtc3RhY2tpbmcgb2YgYWxsIGl0ZW1zIG5leHQgcmVkcmF3XG4gICAgICAgICAgbWUuc3RhY2tEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgaXRlbVxuICAgICAgICB2YXIgaXRlbURhdGEgPSB0aGlzLl9jbG9uZUl0ZW1EYXRhKHByb3BzLml0ZW0uZGF0YSk7IC8vIGNvbnZlcnQgc3RhcnQgYW5kIGVuZCB0byB0aGUgY29ycmVjdCB0eXBlXG4gICAgICAgIG1lLm9wdGlvbnMub25Nb3ZlKGl0ZW1EYXRhLCBmdW5jdGlvbiAoaXRlbURhdGEpIHtcbiAgICAgICAgICBpZiAoaXRlbURhdGEpIHtcbiAgICAgICAgICAgIC8vIGFwcGx5IGNoYW5nZXNcbiAgICAgICAgICAgIGl0ZW1EYXRhW2RhdGFzZXQuX2ZpZWxkSWRdID0gaWQ7IC8vIGVuc3VyZSB0aGUgaXRlbSBjb250YWlucyBpdHMgaWQgKGNhbiBiZSB1bmRlZmluZWQpXG4gICAgICAgICAgICBkYXRhc2V0LnVwZGF0ZShpdGVtRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgIHByb3BzLml0ZW0uc2V0RGF0YShwcm9wcy5kYXRhKTtcblxuICAgICAgICAgICAgbWUuc3RhY2tEaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHJlLXN0YWNraW5nIG9mIGFsbCBpdGVtcyBuZXh0IHJlZHJhd1xuICAgICAgICAgICAgbWUuYm9keS5lbWl0dGVyLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxufTtcblxuSXRlbVNldC5wcm90b3R5cGUuX29uR3JvdXBEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0aWYgKHRoaXMub3B0aW9ucy5ncm91cEVkaXRhYmxlLm9yZGVyKSB7XG5cdFx0dGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwID0gdGhpcy5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuXHRcdFxuXHRcdGlmICh0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXApIHtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XG5cdFx0XHR0aGlzLmdyb3VwVG91Y2hQYXJhbXMub3JpZ2luYWxPcmRlciA9IHRoaXMuZ3JvdXBzRGF0YS5nZXRJZHMoe1xuXHRcdFx0ICAgIG9yZGVyOiB0aGlzLm9wdGlvbnMuZ3JvdXBPcmRlclxuXHRcdCAgICB9KTtcblx0XHR9XG5cdH1cbn1cblxuSXRlbVNldC5wcm90b3R5cGUuX29uR3JvdXBEcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdGlmICh0aGlzLm9wdGlvbnMuZ3JvdXBFZGl0YWJsZS5vcmRlciAmJiB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXApIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcblx0XHQvLyBkcmFnIGZyb20gb25lIGdyb3VwIHRvIGFub3RoZXJcblx0XHR2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwRnJvbVRhcmdldChldmVudCk7XG5cdFx0XG5cdFx0Ly8gdHJ5IHRvIGF2b2lkIHRvZ2dsaW5nIHdoZW4gZ3JvdXBzIGRpZmZlciBpbiBoZWlnaHRcblx0XHRpZiAoZ3JvdXAgJiYgZ3JvdXAuaGVpZ2h0ICE9IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cC5oZWlnaHQpIHtcblx0XHRcdHZhciBtb3ZpbmdVcCA9IChncm91cC50b3AgPCB0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAudG9wKTtcblx0XHRcdHZhciBjbGllbnRZID0gZXZlbnQuY2VudGVyID8gZXZlbnQuY2VudGVyLnkgOiBldmVudC5jbGllbnRZO1xuXHRcdFx0dmFyIHRhcmdldEdyb3VwVG9wID0gdXRpbC5nZXRBYnNvbHV0ZVRvcChncm91cC5kb20uZm9yZWdyb3VuZCk7XG5cdFx0XHR2YXIgZHJhZ2dlZEdyb3VwSGVpZ2h0ID0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmhlaWdodDtcblx0XHRcdGlmIChtb3ZpbmdVcCkge1xuXHRcdFx0XHQvLyBza2lwIHN3YXBwaW5nIHRoZSBncm91cHMgd2hlbiB0aGUgZHJhZ2dlZCBncm91cCBpcyBub3QgYmVsb3cgY2xpZW50WSBhZnRlcndhcmRzXG5cdFx0XHRcdGlmICh0YXJnZXRHcm91cFRvcCArIGRyYWdnZWRHcm91cEhlaWdodCA8IGNsaWVudFkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB0YXJnZXRHcm91cEhlaWdodCA9IGdyb3VwLmhlaWdodDtcblx0XHRcdFx0Ly8gc2tpcCBzd2FwcGluZyB0aGUgZ3JvdXBzIHdoZW4gdGhlIGRyYWdnZWQgZ3JvdXAgaXMgbm90IGJlbG93IGNsaWVudFkgYWZ0ZXJ3YXJkc1xuXHRcdFx0XHRpZiAodGFyZ2V0R3JvdXBUb3AgKyB0YXJnZXRHcm91cEhlaWdodCAtIGRyYWdnZWRHcm91cEhlaWdodCA+IGNsaWVudFkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGdyb3VwICYmIGdyb3VwICE9IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5ncm91cCkge1xuXHRcdFx0dmFyIGdyb3Vwc0RhdGEgPSB0aGlzLmdyb3Vwc0RhdGE7XG5cdFx0XHR2YXIgdGFyZ2V0R3JvdXAgPSBncm91cHNEYXRhLmdldChncm91cC5ncm91cElkKTtcblx0XHRcdHZhciBkcmFnZ2VkR3JvdXAgPSBncm91cHNEYXRhLmdldCh0aGlzLmdyb3VwVG91Y2hQYXJhbXMuZ3JvdXAuZ3JvdXBJZCk7XG5cdFx0XHRcblx0XHRcdC8vIHN3aXRjaCBncm91cHNcblx0XHRcdGlmIChkcmFnZ2VkR3JvdXAgJiYgdGFyZ2V0R3JvdXApIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLmdyb3VwT3JkZXJTd2FwKGRyYWdnZWRHcm91cCwgdGFyZ2V0R3JvdXAsIHRoaXMuZ3JvdXBzRGF0YSk7XG5cdFx0XHRcdHRoaXMuZ3JvdXBzRGF0YS51cGRhdGUoZHJhZ2dlZEdyb3VwKTtcblx0XHRcdFx0dGhpcy5ncm91cHNEYXRhLnVwZGF0ZSh0YXJnZXRHcm91cCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGZldGNoIGN1cnJlbnQgb3JkZXIgb2YgZ3JvdXBzXG5cdFx0XHR2YXIgbmV3T3JkZXIgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0SWRzKHtcblx0XHRcdCAgICBvcmRlcjogdGhpcy5vcHRpb25zLmdyb3VwT3JkZXJcblx0XHQgICAgfSk7XG5cdFx0XHRcblx0XHRcdC8vIGluIGNhc2Ugb2YgY2hhbmdlcyBzaW5jZSBfb25Hcm91cERyYWdTdGFydFxuXHRcdFx0aWYgKCF1dGlsLmVxdWFsQXJyYXkobmV3T3JkZXIsIHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5vcmlnaW5hbE9yZGVyKSkge1xuXHRcdFx0XHR2YXIgZ3JvdXBzRGF0YSA9IHRoaXMuZ3JvdXBzRGF0YTtcblx0XHRcdFx0dmFyIG9yaWdPcmRlciA9IHRoaXMuZ3JvdXBUb3VjaFBhcmFtcy5vcmlnaW5hbE9yZGVyO1xuXHRcdFx0XHR2YXIgZHJhZ2dlZElkID0gdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmdyb3VwSWQ7XG5cdFx0XHRcdHZhciBudW1Hcm91cHMgPSBNYXRoLm1pbihvcmlnT3JkZXIubGVuZ3RoLCBuZXdPcmRlci5sZW5ndGgpO1xuXHRcdFx0XHR2YXIgY3VyUG9zID0gMDtcblx0XHRcdFx0dmFyIG5ld09mZnNldCA9IDA7XG5cdFx0XHRcdHZhciBvcmdPZmZzZXQgPSAwO1xuXHRcdFx0XHR3aGlsZSAoY3VyUG9zIDwgbnVtR3JvdXBzKSB7XG5cdFx0XHRcdFx0Ly8gYXMgbG9uZyBhcyB0aGUgZ3JvdXBzIGFyZSB3aGVyZSB0aGV5IHNob3VsZCBiZSBzdGVwIGRvd24gYWxvbmcgdGhlIGdyb3VwcyBvcmRlclxuXHRcdFx0XHRcdHdoaWxlICgoY3VyUG9zK25ld09mZnNldCkgPCBudW1Hcm91cHMgXG5cdFx0XHRcdFx0XHQmJiAoY3VyUG9zK29yZ09mZnNldCkgPCBudW1Hcm91cHMgXG5cdFx0XHRcdFx0XHQmJiBuZXdPcmRlcltjdXJQb3MrbmV3T2Zmc2V0XSA9PSBvcmlnT3JkZXJbY3VyUG9zK29yZ09mZnNldF0pIHtcblx0XHRcdFx0XHRcdGN1clBvcysrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBhbGwgb2tcblx0XHRcdFx0XHRpZiAoY3VyUG9zK25ld09mZnNldCA+PSBudW1Hcm91cHMpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBub3QgYWxsIG9rXG5cdFx0XHRcdFx0Ly8gaWYgZHJhZ2dlZCBncm91cCB3YXMgbW92ZSB1cHdhcmRzIGV2ZXJ5dGhpbmcgYmVsb3cgc2hvdWxkIGhhdmUgYW4gb2Zmc2V0XG5cdFx0XHRcdFx0aWYgKG5ld09yZGVyW2N1clBvcytuZXdPZmZzZXRdID09IGRyYWdnZWRJZCkge1xuXHRcdFx0XHRcdFx0bmV3T2Zmc2V0ID0gMTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBpZiBkcmFnZ2VkIGdyb3VwIHdhcyBtb3ZlIGRvd253YXJkcyBldmVyeXRoaW5nIGFib3ZlIHNob3VsZCBoYXZlIGFuIG9mZnNldFxuXHRcdFx0XHRcdGVsc2UgaWYgKG9yaWdPcmRlcltjdXJQb3Mrb3JnT2Zmc2V0XSA9PSBkcmFnZ2VkSWQpIHtcblx0XHRcdFx0XHRcdG9yZ09mZnNldCA9IDE7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IFxuXHRcdFx0XHRcdC8vIGZvdW5kIGEgZ3JvdXAgKGFwYXJ0IGZyb20gZHJhZ2dlZCBncm91cCkgdGhhdCBoYXMgdGhlIHdyb25nIHBvc2l0aW9uIC0+IHN3aXRjaCB3aXRoIHRoZSBcblx0XHRcdFx0XHQvLyBncm91cCBhdCB0aGUgcG9zaXRpb24gd2hlcmUgb3RoZXIgb25lIHNob3VsZCBiZSwgZml4IGluZGV4IGFycmF5cyBhbmQgY29udGludWVcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBzbGlwcGVkUG9zaXRpb24gPSBuZXdPcmRlci5pbmRleE9mKG9yaWdPcmRlcltjdXJQb3Mrb3JnT2Zmc2V0XSlcblx0XHRcdFx0XHRcdHZhciBzd2l0Y2hHcm91cCA9IGdyb3Vwc0RhdGEuZ2V0KG5ld09yZGVyW2N1clBvcytuZXdPZmZzZXRdKTtcblx0XHRcdFx0XHRcdHZhciBzaG91bGRCZUdyb3VwID0gZ3JvdXBzRGF0YS5nZXQob3JpZ09yZGVyW2N1clBvcytvcmdPZmZzZXRdKTtcblx0XHRcdFx0XHRcdHRoaXMub3B0aW9ucy5ncm91cE9yZGVyU3dhcChzd2l0Y2hHcm91cCwgc2hvdWxkQmVHcm91cCwgZ3JvdXBzRGF0YSk7XG5cdFx0XHRcdFx0XHRncm91cHNEYXRhLnVwZGF0ZShzd2l0Y2hHcm91cCk7XG5cdFx0XHRcdFx0XHRncm91cHNEYXRhLnVwZGF0ZShzaG91bGRCZUdyb3VwKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0dmFyIHN3aXRjaEdyb3VwSWQgPSBuZXdPcmRlcltjdXJQb3MrbmV3T2Zmc2V0XTtcblx0XHRcdFx0XHRcdG5ld09yZGVyW2N1clBvcytuZXdPZmZzZXRdID0gb3JpZ09yZGVyW2N1clBvcytvcmdPZmZzZXRdO1xuXHRcdFx0XHRcdFx0bmV3T3JkZXJbc2xpcHBlZFBvc2l0aW9uXSA9IHN3aXRjaEdyb3VwSWQ7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGN1clBvcysrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fVxuXHR9XG59XG5cbkl0ZW1TZXQucHJvdG90eXBlLl9vbkdyb3VwRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRpZiAodGhpcy5vcHRpb25zLmdyb3VwRWRpdGFibGUub3JkZXIgJiYgdGhpcy5ncm91cFRvdWNoUGFyYW1zLmdyb3VwKSB7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XG5cdFx0Ly8gdXBkYXRlIGV4aXN0aW5nIGdyb3VwXG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaWQgPSBtZS5ncm91cFRvdWNoUGFyYW1zLmdyb3VwLmdyb3VwSWQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5ncm91cHNEYXRhLmdldERhdGFTZXQoKTtcbiAgICAgICAgdmFyIGdyb3VwRGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBkYXRhc2V0LmdldChpZCkpOyAvLyBjbG9uZSB0aGUgZGF0YVxuICAgICAgICBtZS5vcHRpb25zLm9uTW92ZUdyb3VwKGdyb3VwRGF0YSwgZnVuY3Rpb24gKGdyb3VwRGF0YSkge1xuICAgICAgICAgIGlmIChncm91cERhdGEpIHtcbiAgICAgICAgICAgIC8vIGFwcGx5IGNoYW5nZXNcbiAgICAgICAgXHRncm91cERhdGFbZGF0YXNldC5fZmllbGRJZF0gPSBpZDsgLy8gZW5zdXJlIHRoZSBncm91cCBjb250YWlucyBpdHMgaWQgKGNhbiBiZSB1bmRlZmluZWQpXG4gICAgICAgICAgICBkYXRhc2V0LnVwZGF0ZShncm91cERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgXHQgIFxuICAgICAgICBcdC8vIGZldGNoIGN1cnJlbnQgb3JkZXIgb2YgZ3JvdXBzXG4gIFx0XHRcdHZhciBuZXdPcmRlciA9IGRhdGFzZXQuZ2V0SWRzKHtcbiAgXHRcdFx0ICAgIG9yZGVyOiBtZS5vcHRpb25zLmdyb3VwT3JkZXJcbiAgXHRcdCAgICB9KTtcbiAgICAgICAgXHQgIFxuICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBvcmRlclxuICAgICAgICBcdGlmICghdXRpbC5lcXVhbEFycmF5KG5ld09yZGVyLCBtZS5ncm91cFRvdWNoUGFyYW1zLm9yaWdpbmFsT3JkZXIpKSB7XG4gICAgICAgIFx0XHR2YXIgb3JpZ09yZGVyID0gbWUuZ3JvdXBUb3VjaFBhcmFtcy5vcmlnaW5hbE9yZGVyO1xuICBcdFx0XHRcdHZhciBudW1Hcm91cHMgPSBNYXRoLm1pbihvcmlnT3JkZXIubGVuZ3RoLCBuZXdPcmRlci5sZW5ndGgpO1xuICBcdFx0XHRcdHZhciBjdXJQb3MgPSAwO1xuICBcdFx0XHRcdHdoaWxlIChjdXJQb3MgPCBudW1Hcm91cHMpIHtcbiAgXHRcdFx0XHRcdC8vIGFzIGxvbmcgYXMgdGhlIGdyb3VwcyBhcmUgd2hlcmUgdGhleSBzaG91bGQgYmUgc3RlcCBkb3duIGFsb25nIHRoZSBncm91cHMgb3JkZXJcbiAgXHRcdFx0XHRcdHdoaWxlIChjdXJQb3MgPCBudW1Hcm91cHMgJiYgbmV3T3JkZXJbY3VyUG9zXSA9PSBvcmlnT3JkZXJbY3VyUG9zXSkge1xuICBcdFx0XHRcdFx0ICAgIGN1clBvcysrO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XG4gIFx0XHRcdFx0XHQvLyBhbGwgb2tcbiAgXHRcdFx0XHRcdGlmIChjdXJQb3MgPj0gbnVtR3JvdXBzKSB7XG4gIFx0XHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XG4gIFx0XHRcdFx0XHQvLyBmb3VuZCBhIGdyb3VwIHRoYXQgaGFzIHRoZSB3cm9uZyBwb3NpdGlvbiAtPiBzd2l0Y2ggd2l0aCB0aGUgXG4gIFx0XHRcdFx0XHQvLyBncm91cCBhdCB0aGUgcG9zaXRpb24gd2hlcmUgb3RoZXIgb25lIHNob3VsZCBiZSwgZml4IGluZGV4IGFycmF5cyBhbmQgY29udGludWVcbiAgXHRcdFx0XHRcdHZhciBzbGlwcGVkUG9zaXRpb24gPSBuZXdPcmRlci5pbmRleE9mKG9yaWdPcmRlcltjdXJQb3NdKVxuICBcdFx0XHRcdFx0dmFyIHN3aXRjaEdyb3VwID0gZGF0YXNldC5nZXQobmV3T3JkZXJbY3VyUG9zXSk7XG4gIFx0XHRcdFx0XHR2YXIgc2hvdWxkQmVHcm91cCA9IGRhdGFzZXQuZ2V0KG9yaWdPcmRlcltjdXJQb3NdKTtcbiAgXHRcdFx0XHRcdG1lLm9wdGlvbnMuZ3JvdXBPcmRlclN3YXAoc3dpdGNoR3JvdXAsIHNob3VsZEJlR3JvdXAsIGRhdGFzZXQpO1xuICBcdFx0XHRcdFx0Z3JvdXBzRGF0YS51cGRhdGUoc3dpdGNoR3JvdXApO1xuXHRcdFx0XHRcdGdyb3Vwc0RhdGEudXBkYXRlKHNob3VsZEJlR3JvdXApO1xuICBcdFx0XHRcdFx0XHRcbiAgXHRcdFx0XHRcdHZhciBzd2l0Y2hHcm91cElkID0gbmV3T3JkZXJbY3VyUG9zXTtcbiAgXHRcdFx0XHRcdG5ld09yZGVyW2N1clBvc10gPSBvcmlnT3JkZXJbY3VyUG9zXTtcbiAgXHRcdFx0XHRcdG5ld09yZGVyW3NsaXBwZWRQb3NpdGlvbl0gPSBzd2l0Y2hHcm91cElkO1xuICBcdFx0XHRcdFx0XHRcbiAgXHRcdFx0XHRcdGN1clBvcysrO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIG1lLmJvZHkuZW1pdHRlci5lbWl0KCdncm91cERyYWdnZWQnLCB7IGdyb3VwSWQ6IGlkIH0pO1xuXHR9XG59XG5cbi8qKlxuICogSGFuZGxlIHNlbGVjdGluZy9kZXNlbGVjdGluZyBhbiBpdGVtIHdoZW4gdGFwcGluZyBpdFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vblNlbGVjdEl0ZW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSkgcmV0dXJuO1xuXG4gIHZhciBjdHJsS2V5ICA9IGV2ZW50LnNyY0V2ZW50ICYmIChldmVudC5zcmNFdmVudC5jdHJsS2V5IHx8IGV2ZW50LnNyY0V2ZW50Lm1ldGFLZXkpO1xuICB2YXIgc2hpZnRLZXkgPSBldmVudC5zcmNFdmVudCAmJiBldmVudC5zcmNFdmVudC5zaGlmdEtleTtcbiAgaWYgKGN0cmxLZXkgfHwgc2hpZnRLZXkpIHtcbiAgICB0aGlzLl9vbk11bHRpU2VsZWN0SXRlbShldmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9sZFNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1Gcm9tVGFyZ2V0KGV2ZW50KTtcbiAgdmFyIHNlbGVjdGlvbiA9IGl0ZW0gPyBbaXRlbS5pZF0gOiBbXTtcbiAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcblxuICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuICAvLyBlbWl0IGEgc2VsZWN0IGV2ZW50LFxuICAvLyBleGNlcHQgd2hlbiBvbGQgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBuZXcgc2VsZWN0aW9uIGlzIHN0aWxsIGVtcHR5XG4gIGlmIChuZXdTZWxlY3Rpb24ubGVuZ3RoID4gMCB8fCBvbGRTZWxlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoJ3NlbGVjdCcsIHtcbiAgICAgIGl0ZW1zOiBuZXdTZWxlY3Rpb24sXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgY3JlYXRpb24gYW5kIHVwZGF0ZXMgb2YgYW4gaXRlbSBvbiBkb3VibGUgdGFwXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLl9vbkFkZEl0ZW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSkgcmV0dXJuO1xuICBpZiAoIXRoaXMub3B0aW9ucy5lZGl0YWJsZS5hZGQpIHJldHVybjtcblxuICB2YXIgbWUgPSB0aGlzO1xuICB2YXIgc25hcCA9IHRoaXMub3B0aW9ucy5zbmFwIHx8IG51bGw7XG4gIHZhciBpdGVtID0gdGhpcy5pdGVtRnJvbVRhcmdldChldmVudCk7XG5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgaWYgKGl0ZW0pIHtcbiAgICAvLyB1cGRhdGUgaXRlbVxuXG4gICAgLy8gZXhlY3V0ZSBhc3luYyBoYW5kbGVyIHRvIHVwZGF0ZSB0aGUgaXRlbSAob3IgY2FuY2VsIGl0KVxuICAgIHZhciBpdGVtRGF0YSA9IG1lLml0ZW1zRGF0YS5nZXQoaXRlbS5pZCk7IC8vIGdldCBhIGNsb25lIG9mIHRoZSBkYXRhIGZyb20gdGhlIGRhdGFzZXRcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoaXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtRGF0YSkge1xuICAgICAgaWYgKGl0ZW1EYXRhKSB7XG4gICAgICAgIG1lLml0ZW1zRGF0YS5nZXREYXRhU2V0KCkudXBkYXRlKGl0ZW1EYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBhZGQgaXRlbVxuICAgIHZhciB4QWJzID0gdXRpbC5nZXRBYnNvbHV0ZUxlZnQodGhpcy5kb20uZnJhbWUpO1xuICAgIHZhciB4ID0gZXZlbnQuY2VudGVyLnggLSB4QWJzO1xuICAgIHZhciBzdGFydCA9IHRoaXMuYm9keS51dGlsLnRvVGltZSh4KTtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLmJvZHkudXRpbC5nZXRTY2FsZSgpO1xuICAgIHZhciBzdGVwID0gdGhpcy5ib2R5LnV0aWwuZ2V0U3RlcCgpO1xuXG4gICAgdmFyIG5ld0l0ZW1EYXRhID0ge1xuICAgICAgc3RhcnQ6IHNuYXAgPyBzbmFwKHN0YXJ0LCBzY2FsZSwgc3RlcCkgOiBzdGFydCxcbiAgICAgIGNvbnRlbnQ6ICduZXcgaXRlbSdcbiAgICB9O1xuXG4gICAgLy8gd2hlbiBkZWZhdWx0IHR5cGUgaXMgYSByYW5nZSwgYWRkIGEgZGVmYXVsdCBlbmQgZGF0ZSB0byB0aGUgbmV3IGl0ZW1cbiAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09ICdyYW5nZScpIHtcbiAgICAgIHZhciBlbmQgPSB0aGlzLmJvZHkudXRpbC50b1RpbWUoeCArIHRoaXMucHJvcHMud2lkdGggLyA1KTtcbiAgICAgIG5ld0l0ZW1EYXRhLmVuZCA9IHNuYXAgPyBzbmFwKGVuZCwgc2NhbGUsIHN0ZXApIDogZW5kO1xuICAgIH1cblxuICAgIG5ld0l0ZW1EYXRhW3RoaXMuaXRlbXNEYXRhLl9maWVsZElkXSA9IHV0aWwucmFuZG9tVVVJRCgpO1xuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cEZyb21UYXJnZXQoZXZlbnQpO1xuICAgIGlmIChncm91cCkge1xuICAgICAgbmV3SXRlbURhdGEuZ3JvdXAgPSBncm91cC5ncm91cElkO1xuICAgIH1cblxuICAgIC8vIGV4ZWN1dGUgYXN5bmMgaGFuZGxlciB0byBjdXN0b21pemUgKG9yIGNhbmNlbCkgYWRkaW5nIGFuIGl0ZW1cbiAgICBuZXdJdGVtRGF0YSA9IHRoaXMuX2Nsb25lSXRlbURhdGEobmV3SXRlbURhdGEpOyAgICAgLy8gY29udmVydCBzdGFydCBhbmQgZW5kIHRvIHRoZSBjb3JyZWN0IHR5cGVcbiAgICB0aGlzLm9wdGlvbnMub25BZGQobmV3SXRlbURhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICBtZS5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpLmFkZChpdGVtKTtcbiAgICAgICAgLy8gVE9ETzogbmVlZCB0byB0cmlnZ2VyIGEgcmVkcmF3P1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZSBzZWxlY3RpbmcvZGVzZWxlY3RpbmcgbXVsdGlwbGUgaXRlbXMgd2hlbiBob2xkaW5nIGFuIGl0ZW1cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5fb25NdWx0aVNlbGVjdEl0ZW0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSkgcmV0dXJuO1xuXG4gIHZhciBpdGVtID0gdGhpcy5pdGVtRnJvbVRhcmdldChldmVudCk7XG5cbiAgaWYgKGl0ZW0pIHtcbiAgICAvLyBtdWx0aSBzZWxlY3QgaXRlbXMgKGlmIGFsbG93ZWQpXG5cbiAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5vcHRpb25zLm11bHRpc2VsZWN0XG4gICAgICA/IHRoaXMuZ2V0U2VsZWN0aW9uKCkgLy8gdGFrZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgOiBbXTsgICAgICAgICAgICAgICAgIC8vIGRlc2VsZWN0IGN1cnJlbnQgc2VsZWN0aW9uXG5cbiAgICB2YXIgc2hpZnRLZXkgPSBldmVudC5zcmNFdmVudCAmJiBldmVudC5zcmNFdmVudC5zaGlmdEtleSB8fCBmYWxzZTtcblxuICAgIGlmIChzaGlmdEtleSAmJiB0aGlzLm9wdGlvbnMubXVsdGlzZWxlY3QpIHtcbiAgICAgIC8vIHNlbGVjdCBhbGwgaXRlbXMgYmV0d2VlbiB0aGUgb2xkIHNlbGVjdGlvbiBhbmQgdGhlIHRhcHBlZCBpdGVtXG5cbiAgICAgIC8vIGRldGVybWluZSB0aGUgc2VsZWN0aW9uIHJhbmdlXG4gICAgICBzZWxlY3Rpb24ucHVzaChpdGVtLmlkKTtcbiAgICAgIHZhciByYW5nZSA9IEl0ZW1TZXQuX2dldEl0ZW1SYW5nZSh0aGlzLml0ZW1zRGF0YS5nZXQoc2VsZWN0aW9uLCB0aGlzLml0ZW1PcHRpb25zKSk7XG5cbiAgICAgIC8vIHNlbGVjdCBhbGwgaXRlbXMgd2l0aGluIHRoZSBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgIHNlbGVjdGlvbiA9IFtdO1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5pdGVtcykge1xuICAgICAgICBpZiAodGhpcy5pdGVtcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICB2YXIgX2l0ZW0gPSB0aGlzLml0ZW1zW2lkXTtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBfaXRlbS5kYXRhLnN0YXJ0O1xuICAgICAgICAgIHZhciBlbmQgPSAoX2l0ZW0uZGF0YS5lbmQgIT09IHVuZGVmaW5lZCkgPyBfaXRlbS5kYXRhLmVuZCA6IHN0YXJ0O1xuXG4gICAgICAgICAgaWYgKHN0YXJ0ID49IHJhbmdlLm1pbiAmJlxuICAgICAgICAgICAgICBlbmQgPD0gcmFuZ2UubWF4ICYmXG4gICAgICAgICAgICAgICEoX2l0ZW0gaW5zdGFuY2VvZiBCYWNrZ3JvdW5kSXRlbSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5wdXNoKF9pdGVtLmlkKTsgLy8gZG8gbm90IHVzZSBpZCBidXQgaXRlbS5pZCwgaWQgaXRzZWxmIGlzIHN0cmluZ2lmaWVkXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gYWRkL3JlbW92ZSB0aGlzIGl0ZW0gZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgIHZhciBpbmRleCA9IHNlbGVjdGlvbi5pbmRleE9mKGl0ZW0uaWQpO1xuICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgIC8vIGl0ZW0gaXMgbm90IHlldCBzZWxlY3RlZCAtPiBzZWxlY3QgaXRcbiAgICAgICAgc2VsZWN0aW9uLnB1c2goaXRlbS5pZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaXRlbSBpcyBhbHJlYWR5IHNlbGVjdGVkIC0+IGRlc2VsZWN0IGl0XG4gICAgICAgIHNlbGVjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KCdzZWxlY3QnLCB7XG4gICAgICBpdGVtczogdGhpcy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgdGltZSByYW5nZSBvZiBhIGxpc3Qgb2YgaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGl0ZW1zRGF0YVxuICogQHJldHVybiB7e21pbjogRGF0ZSwgbWF4OiBEYXRlfX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgdGhlIHByb3ZpZGVkIGl0ZW1zXG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtU2V0Ll9nZXRJdGVtUmFuZ2UgPSBmdW5jdGlvbihpdGVtc0RhdGEpIHtcbiAgdmFyIG1heCA9IG51bGw7XG4gIHZhciBtaW4gPSBudWxsO1xuXG4gIGl0ZW1zRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKG1pbiA9PSBudWxsIHx8IGRhdGEuc3RhcnQgPCBtaW4pIHtcbiAgICAgIG1pbiA9IGRhdGEuc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuZW5kICE9IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG1heCA9PSBudWxsIHx8IGRhdGEuZW5kID4gbWF4KSB7XG4gICAgICAgIG1heCA9IGRhdGEuZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChtYXggPT0gbnVsbCB8fCBkYXRhLnN0YXJ0ID4gbWF4KSB7XG4gICAgICAgIG1heCA9IGRhdGEuc3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4XG4gIH1cbn07XG5cbi8qKlxuICogRmluZCBhbiBpdGVtIGZyb20gYW4gZXZlbnQgdGFyZ2V0OlxuICogc2VhcmNoZXMgZm9yIHRoZSBhdHRyaWJ1dGUgJ3RpbWVsaW5lLWl0ZW0nIGluIHRoZSBldmVudCB0YXJnZXQncyBlbGVtZW50IHRyZWVcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtJdGVtIHwgbnVsbH0gaXRlbVxuICovXG5JdGVtU2V0LnByb3RvdHlwZS5pdGVtRnJvbVRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCd0aW1lbGluZS1pdGVtJykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRbJ3RpbWVsaW5lLWl0ZW0nXTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogRmluZCB0aGUgR3JvdXAgZnJvbSBhbiBldmVudCB0YXJnZXQ6XG4gKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAndGltZWxpbmUtZ3JvdXAnIGluIHRoZSBldmVudCB0YXJnZXQncyBlbGVtZW50IHRyZWVcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtHcm91cCB8IG51bGx9IGdyb3VwXG4gKi9cbkl0ZW1TZXQucHJvdG90eXBlLmdyb3VwRnJvbVRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciBjbGllbnRZID0gZXZlbnQuY2VudGVyID8gZXZlbnQuY2VudGVyLnkgOiBldmVudC5jbGllbnRZO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ3JvdXBJZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JvdXBJZCA9IHRoaXMuZ3JvdXBJZHNbaV07XG4gICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHNbZ3JvdXBJZF07XG4gICAgdmFyIGZvcmVncm91bmQgPSBncm91cC5kb20uZm9yZWdyb3VuZDtcbiAgICB2YXIgdG9wID0gdXRpbC5nZXRBYnNvbHV0ZVRvcChmb3JlZ3JvdW5kKTtcbiAgICBpZiAoY2xpZW50WSA+IHRvcCAmJiBjbGllbnRZIDwgdG9wICsgZm9yZWdyb3VuZC5vZmZzZXRIZWlnaHQpIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW0gPT09ICd0b3AnKSB7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5ncm91cElkcy5sZW5ndGggLSAxICYmIGNsaWVudFkgPiB0b3ApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChpID09PSAwICYmIGNsaWVudFkgPCB0b3AgKyBmb3JlZ3JvdW5kLm9mZnNldCkge1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIEl0ZW1TZXQgZnJvbSBhbiBldmVudCB0YXJnZXQ6XG4gKiBzZWFyY2hlcyBmb3IgdGhlIGF0dHJpYnV0ZSAndGltZWxpbmUtaXRlbXNldCcgaW4gdGhlIGV2ZW50IHRhcmdldCdzIGVsZW1lbnQgdHJlZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge0l0ZW1TZXQgfCBudWxsfSBpdGVtXG4gKi9cbkl0ZW1TZXQuaXRlbVNldEZyb21UYXJnZXQgPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICB3aGlsZSAodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgndGltZWxpbmUtaXRlbXNldCcpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Wyd0aW1lbGluZS1pdGVtc2V0J107XG4gICAgfVxuICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsb25lIHRoZSBkYXRhIG9mIGFuIGl0ZW0sIGFuZCBcIm5vcm1hbGl6ZVwiIGl0OiBjb252ZXJ0IHRoZSBzdGFydCBhbmQgZW5kIGRhdGVcbiAqIHRvIHRoZSB0eXBlIChEYXRlLCBNb21lbnQsIC4uLikgY29uZmlndXJlZCBpbiB0aGUgRGF0YVNldC4gSWYgbm90IGNvbmZpZ3VyZWQsXG4gKiBzdGFydCBhbmQgZW5kIGFyZSBjb252ZXJ0ZWQgdG8gRGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRGF0YSwgdHlwaWNhbGx5IGBpdGVtLmRhdGFgXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdICBPcHRpb25hbCBEYXRlIHR5cGUuIElmIG5vdCBwcm92aWRlZCwgdGhlIHR5cGUgZnJvbSB0aGUgRGF0YVNldCBpcyB0YWtlblxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmVkIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuSXRlbVNldC5wcm90b3R5cGUuX2Nsb25lSXRlbURhdGEgPSBmdW5jdGlvbiAoaXRlbURhdGEsIHR5cGUpIHtcbiAgdmFyIGNsb25lID0gdXRpbC5leHRlbmQoe30sIGl0ZW1EYXRhKTtcblxuICBpZiAoIXR5cGUpIHtcbiAgICAvLyBjb252ZXJ0IHN0YXJ0IGFuZCBlbmQgZGF0ZSB0byB0aGUgdHlwZSAoRGF0ZSwgTW9tZW50LCAuLi4pIGNvbmZpZ3VyZWQgaW4gdGhlIERhdGFTZXRcbiAgICB0eXBlID0gdGhpcy5pdGVtc0RhdGEuZ2V0RGF0YVNldCgpLl9vcHRpb25zLnR5cGU7XG4gIH1cblxuICBpZiAoY2xvbmUuc3RhcnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvbmUuc3RhcnQgPSB1dGlsLmNvbnZlcnQoY2xvbmUuc3RhcnQsIHR5cGUgJiYgdHlwZS5zdGFydCB8fCAnRGF0ZScpO1xuICB9XG4gIGlmIChjbG9uZS5lbmQgIT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvbmUuZW5kID0gdXRpbC5jb252ZXJ0KGNsb25lLmVuZCAsIHR5cGUgJiYgdHlwZS5lbmQgfHwgJ0RhdGUnKTtcbiAgfVxuXG4gIHJldHVybiBjbG9uZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSXRlbVNldDtcbiJdfQ==
},{"../../DataSet":15,"../../DataView":16,"../../module/hammer":19,"../../util":46,"../TimeStep":30,"./BackgroundGroup":32,"./Component":33,"./Group":36,"./item/BackgroundItem":39,"./item/BoxItem":40,"./item/PointItem":42,"./item/RangeItem":43}],38:[function(require,module,exports){
'use strict';

var util = require('../../util');
var Component = require('./Component');
var TimeStep = require('../TimeStep');
var DateUtil = require('../DateUtil');
var moment = require('../../module/moment');

/**
 * A horizontal time axis
 * @param {{dom: Object, domProps: Object, emitter: Emitter, range: Range}} body
 * @param {Object} [options]        See TimeAxis.setOptions for the available
 *                                  options.
 * @constructor TimeAxis
 * @extends Component
 */
function TimeAxis(body, options) {
  this.dom = {
    foreground: null,
    lines: [],
    majorTexts: [],
    minorTexts: [],
    redundant: {
      lines: [],
      majorTexts: [],
      minorTexts: []
    }
  };
  this.props = {
    range: {
      start: 0,
      end: 0,
      minimumStep: 0
    },
    lineTop: 0
  };

  this.defaultOptions = {
    orientation: {
      axis: 'bottom'
    }, // axis orientation: 'top' or 'bottom'
    showMinorLabels: true,
    showMajorLabels: true,
    format: TimeStep.FORMAT,
    moment: moment,
    timeAxis: null
  };
  this.options = util.extend({}, this.defaultOptions);

  this.body = body;

  // create the HTML DOM
  this._create();

  this.setOptions(options);
}

TimeAxis.prototype = new Component();

/**
 * Set options for the TimeAxis.
 * Parameters will be merged in current options.
 * @param {Object} options  Available options:
 *                          {string} [orientation.axis]
 *                          {boolean} [showMinorLabels]
 *                          {boolean} [showMajorLabels]
 */
TimeAxis.prototype.setOptions = function (options) {
  if (options) {
    // copy all options that we know
    util.selectiveExtend(['showMinorLabels', 'showMajorLabels', 'hiddenDates', 'timeAxis', 'moment'], this.options, options);

    // deep copy the format options
    util.selectiveDeepExtend(['format'], this.options, options);

    if ('orientation' in options) {
      if (typeof options.orientation === 'string') {
        this.options.orientation.axis = options.orientation;
      } else if (typeof options.orientation === 'object' && 'axis' in options.orientation) {
        this.options.orientation.axis = options.orientation.axis;
      }
    }

    // apply locale to moment.js
    // TODO: not so nice, this is applied globally to moment.js
    if ('locale' in options) {
      if (typeof moment.locale === 'function') {
        // moment.js 2.8.1+
        moment.locale(options.locale);
      } else {
        moment.lang(options.locale);
      }
    }
  }
};

/**
 * Create the HTML DOM for the TimeAxis
 */
TimeAxis.prototype._create = function () {
  this.dom.foreground = document.createElement('div');
  this.dom.background = document.createElement('div');

  this.dom.foreground.className = 'vis-time-axis vis-foreground';
  this.dom.background.className = 'vis-time-axis vis-background';
};

/**
 * Destroy the TimeAxis
 */
TimeAxis.prototype.destroy = function () {
  // remove from DOM
  if (this.dom.foreground.parentNode) {
    this.dom.foreground.parentNode.removeChild(this.dom.foreground);
  }
  if (this.dom.background.parentNode) {
    this.dom.background.parentNode.removeChild(this.dom.background);
  }

  this.body = null;
};

/**
 * Repaint the component
 * @return {boolean} Returns true if the component is resized
 */
TimeAxis.prototype.redraw = function () {
  var props = this.props;
  var foreground = this.dom.foreground;
  var background = this.dom.background;

  // determine the correct parent DOM element (depending on option orientation)
  var parent = this.options.orientation.axis == 'top' ? this.body.dom.top : this.body.dom.bottom;
  var parentChanged = foreground.parentNode !== parent;

  // calculate character width and height
  this._calculateCharSize();

  // TODO: recalculate sizes only needed when parent is resized or options is changed
  var showMinorLabels = this.options.showMinorLabels && this.options.orientation.axis !== 'none';
  var showMajorLabels = this.options.showMajorLabels && this.options.orientation.axis !== 'none';

  // determine the width and height of the elemens for the axis
  props.minorLabelHeight = showMinorLabels ? props.minorCharHeight : 0;
  props.majorLabelHeight = showMajorLabels ? props.majorCharHeight : 0;
  props.height = props.minorLabelHeight + props.majorLabelHeight;
  props.width = foreground.offsetWidth;

  props.minorLineHeight = this.body.domProps.root.height - props.majorLabelHeight - (this.options.orientation.axis == 'top' ? this.body.domProps.bottom.height : this.body.domProps.top.height);
  props.minorLineWidth = 1; // TODO: really calculate width
  props.majorLineHeight = props.minorLineHeight + props.majorLabelHeight;
  props.majorLineWidth = 1; // TODO: really calculate width

  //  take foreground and background offline while updating (is almost twice as fast)
  var foregroundNextSibling = foreground.nextSibling;
  var backgroundNextSibling = background.nextSibling;
  foreground.parentNode && foreground.parentNode.removeChild(foreground);
  background.parentNode && background.parentNode.removeChild(background);

  foreground.style.height = this.props.height + 'px';

  this._repaintLabels();

  // put DOM online again (at the same place)
  if (foregroundNextSibling) {
    parent.insertBefore(foreground, foregroundNextSibling);
  } else {
    parent.appendChild(foreground);
  }
  if (backgroundNextSibling) {
    this.body.dom.backgroundVertical.insertBefore(background, backgroundNextSibling);
  } else {
    this.body.dom.backgroundVertical.appendChild(background);
  }

  return this._isResized() || parentChanged;
};

/**
 * Repaint major and minor text labels and vertical grid lines
 * @private
 */
TimeAxis.prototype._repaintLabels = function () {
  var orientation = this.options.orientation.axis;

  // calculate range and step (step such that we have space for 7 characters per label)
  var start = util.convert(this.body.range.start, 'Number');
  var end = util.convert(this.body.range.end, 'Number');
  var timeLabelsize = this.body.util.toTime((this.props.minorCharWidth || 10) * 7).valueOf();
  var minimumStep = timeLabelsize - DateUtil.getHiddenDurationBefore(this.options.moment, this.body.hiddenDates, this.body.range, timeLabelsize);
  minimumStep -= this.body.util.toTime(0).valueOf();

  var step = new TimeStep(new Date(start), new Date(end), minimumStep, this.body.hiddenDates);
  step.setMoment(this.options.moment);
  if (this.options.format) {
    step.setFormat(this.options.format);
  }
  if (this.options.timeAxis) {
    step.setScale(this.options.timeAxis);
  }
  this.step = step;

  // Move all DOM elements to a "redundant" list, where they
  // can be picked for re-use, and clear the lists with lines and texts.
  // At the end of the function _repaintLabels, left over elements will be cleaned up
  var dom = this.dom;
  dom.redundant.lines = dom.lines;
  dom.redundant.majorTexts = dom.majorTexts;
  dom.redundant.minorTexts = dom.minorTexts;
  dom.lines = [];
  dom.majorTexts = [];
  dom.minorTexts = [];

  var current;
  var next;
  var x;
  var xNext;
  var isMajor;
  var width;
  var line;
  var labelMinor;
  var xFirstMajorLabel = undefined;
  var max = 0;
  var className;

  step.start();
  next = step.getCurrent();
  xNext = this.body.util.toScreen(next);
  while (step.hasNext() && max < 1000) {
    max++;

    isMajor = step.isMajor();
    className = step.getClassName();
    labelMinor = step.getLabelMinor();

    current = next;
    x = xNext;

    step.next();
    next = step.getCurrent();
    xNext = this.body.util.toScreen(next);

    width = xNext - x;
    var labelFits = (labelMinor.length + 1) * this.props.minorCharWidth < width;

    if (this.options.showMinorLabels && labelFits) {
      this._repaintMinorText(x, labelMinor, orientation, className);
    }

    if (isMajor && this.options.showMajorLabels) {
      if (x > 0) {
        if (xFirstMajorLabel == undefined) {
          xFirstMajorLabel = x;
        }
        this._repaintMajorText(x, step.getLabelMajor(), orientation, className);
      }
      line = this._repaintMajorLine(x, width, orientation, className);
    } else {
      if (labelFits) {
        line = this._repaintMinorLine(x, width, orientation, className);
      } else {
        if (line) {
          line.style.width = parseInt(line.style.width) + width + 'px';
        }
      }
    }
  }

  // create a major label on the left when needed
  if (this.options.showMajorLabels) {
    var leftTime = this.body.util.toTime(0),
        leftText = step.getLabelMajor(leftTime),
        widthText = leftText.length * (this.props.majorCharWidth || 10) + 10; // upper bound estimation

    if (xFirstMajorLabel == undefined || widthText < xFirstMajorLabel) {
      this._repaintMajorText(0, leftText, orientation, className);
    }
  }

  // Cleanup leftover DOM elements from the redundant list
  util.forEach(this.dom.redundant, function (arr) {
    while (arr.length) {
      var elem = arr.pop();
      if (elem && elem.parentNode) {
        elem.parentNode.removeChild(elem);
      }
    }
  });
};

/**
 * Create a minor label for the axis at position x
 * @param {Number} x
 * @param {String} text
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the HTML element of the created label
 * @private
 */
TimeAxis.prototype._repaintMinorText = function (x, text, orientation, className) {
  // reuse redundant label
  var label = this.dom.redundant.minorTexts.shift();

  if (!label) {
    // create new label
    var content = document.createTextNode('');
    label = document.createElement('div');
    label.appendChild(content);
    this.dom.foreground.appendChild(label);
  }
  this.dom.minorTexts.push(label);

  label.childNodes[0].nodeValue = text;

  label.style.top = orientation == 'top' ? this.props.majorLabelHeight + 'px' : '0';
  label.style.left = x + 'px';
  label.className = 'vis-text vis-minor ' + className;
  //label.title = title;  // TODO: this is a heavy operation

  return label;
};

/**
 * Create a Major label for the axis at position x
 * @param {Number} x
 * @param {String} text
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the HTML element of the created label
 * @private
 */
TimeAxis.prototype._repaintMajorText = function (x, text, orientation, className) {
  // reuse redundant label
  var label = this.dom.redundant.majorTexts.shift();

  if (!label) {
    // create label
    var content = document.createTextNode(text);
    label = document.createElement('div');
    label.appendChild(content);
    this.dom.foreground.appendChild(label);
  }
  this.dom.majorTexts.push(label);

  label.childNodes[0].nodeValue = text;
  label.className = 'vis-text vis-major ' + className;
  //label.title = title; // TODO: this is a heavy operation

  label.style.top = orientation == 'top' ? '0' : this.props.minorLabelHeight + 'px';
  label.style.left = x + 'px';

  return label;
};

/**
 * Create a minor line for the axis at position x
 * @param {Number} x
 * @param {Number} width
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the created line
 * @private
 */
TimeAxis.prototype._repaintMinorLine = function (x, width, orientation, className) {
  // reuse redundant line
  var line = this.dom.redundant.lines.shift();
  if (!line) {
    // create vertical line
    line = document.createElement('div');
    this.dom.background.appendChild(line);
  }
  this.dom.lines.push(line);

  var props = this.props;
  if (orientation == 'top') {
    line.style.top = props.majorLabelHeight + 'px';
  } else {
    line.style.top = this.body.domProps.top.height + 'px';
  }
  line.style.height = props.minorLineHeight + 'px';
  line.style.left = x - props.minorLineWidth / 2 + 'px';
  line.style.width = width + 'px';

  line.className = 'vis-grid vis-vertical vis-minor ' + className;

  return line;
};

/**
 * Create a Major line for the axis at position x
 * @param {Number} x
 * @param {Number} width
 * @param {String} orientation   "top" or "bottom" (default)
 * @param {String} className
 * @return {Element} Returns the created line
 * @private
 */
TimeAxis.prototype._repaintMajorLine = function (x, width, orientation, className) {
  // reuse redundant line
  var line = this.dom.redundant.lines.shift();
  if (!line) {
    // create vertical line
    line = document.createElement('div');
    this.dom.background.appendChild(line);
  }
  this.dom.lines.push(line);

  var props = this.props;
  if (orientation == 'top') {
    line.style.top = '0';
  } else {
    line.style.top = this.body.domProps.top.height + 'px';
  }
  line.style.left = x - props.majorLineWidth / 2 + 'px';
  line.style.height = props.majorLineHeight + 'px';
  line.style.width = width + 'px';

  line.className = 'vis-grid vis-vertical vis-major ' + className;

  return line;
};

/**
 * Determine the size of text on the axis (both major and minor axis).
 * The size is calculated only once and then cached in this.props.
 * @private
 */
TimeAxis.prototype._calculateCharSize = function () {
  // Note: We calculate char size with every redraw. Size may change, for
  // example when any of the timelines parents had display:none for example.

  // determine the char width and height on the minor axis
  if (!this.dom.measureCharMinor) {
    this.dom.measureCharMinor = document.createElement('DIV');
    this.dom.measureCharMinor.className = 'vis-text vis-minor vis-measure';
    this.dom.measureCharMinor.style.position = 'absolute';

    this.dom.measureCharMinor.appendChild(document.createTextNode('0'));
    this.dom.foreground.appendChild(this.dom.measureCharMinor);
  }
  this.props.minorCharHeight = this.dom.measureCharMinor.clientHeight;
  this.props.minorCharWidth = this.dom.measureCharMinor.clientWidth;

  // determine the char width and height on the major axis
  if (!this.dom.measureCharMajor) {
    this.dom.measureCharMajor = document.createElement('DIV');
    this.dom.measureCharMajor.className = 'vis-text vis-major vis-measure';
    this.dom.measureCharMajor.style.position = 'absolute';

    this.dom.measureCharMajor.appendChild(document.createTextNode('0'));
    this.dom.foreground.appendChild(this.dom.measureCharMajor);
  }
  this.props.majorCharHeight = this.dom.measureCharMajor.clientHeight;
  this.props.majorCharWidth = this.dom.measureCharMajor.clientWidth;
};

module.exports = TimeAxis;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvVGltZUF4aXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDakMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3ZDLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN0QyxJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDdEMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7Ozs7Ozs7Ozs7QUFVNUMsU0FBUyxRQUFRLENBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtBQUNoQyxNQUFJLENBQUMsR0FBRyxHQUFHO0FBQ1QsY0FBVSxFQUFFLElBQUk7QUFDaEIsU0FBSyxFQUFFLEVBQUU7QUFDVCxjQUFVLEVBQUUsRUFBRTtBQUNkLGNBQVUsRUFBRSxFQUFFO0FBQ2QsYUFBUyxFQUFFO0FBQ1QsV0FBSyxFQUFFLEVBQUU7QUFDVCxnQkFBVSxFQUFFLEVBQUU7QUFDZCxnQkFBVSxFQUFFLEVBQUU7S0FDZjtHQUNGLENBQUM7QUFDRixNQUFJLENBQUMsS0FBSyxHQUFHO0FBQ1gsU0FBSyxFQUFFO0FBQ0wsV0FBSyxFQUFFLENBQUM7QUFDUixTQUFHLEVBQUUsQ0FBQztBQUNOLGlCQUFXLEVBQUUsQ0FBQztLQUNmO0FBQ0QsV0FBTyxFQUFFLENBQUM7R0FDWCxDQUFDOztBQUVGLE1BQUksQ0FBQyxjQUFjLEdBQUc7QUFDcEIsZUFBVyxFQUFFO0FBQ1gsVUFBSSxFQUFFLFFBQVE7S0FDZjtBQUNELG1CQUFlLEVBQUUsSUFBSTtBQUNyQixtQkFBZSxFQUFFLElBQUk7QUFDckIsVUFBTSxFQUFFLFFBQVEsQ0FBQyxNQUFNO0FBQ3ZCLFVBQU0sRUFBRSxNQUFNO0FBQ2Qs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QUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzFELFFBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxHQUFHLGdDQUFnQyxDQUFDO0FBQ3ZFLFFBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7O0FBRXRELFFBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNwRSxRQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0dBQzVEO0FBQ0QsTUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUM7QUFDcEUsTUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUM7Q0FDbkUsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyIsImZpbGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L1RpbWVBeGlzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9Db21wb25lbnQnKTtcbnZhciBUaW1lU3RlcCA9IHJlcXVpcmUoJy4uL1RpbWVTdGVwJyk7XG52YXIgRGF0ZVV0aWwgPSByZXF1aXJlKCcuLi9EYXRlVXRpbCcpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZS9tb21lbnQnKTtcblxuLyoqXG4gKiBBIGhvcml6b250YWwgdGltZSBheGlzXG4gKiBAcGFyYW0ge3tkb206IE9iamVjdCwgZG9tUHJvcHM6IE9iamVjdCwgZW1pdHRlcjogRW1pdHRlciwgcmFuZ2U6IFJhbmdlfX0gYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgU2VlIFRpbWVBeGlzLnNldE9wdGlvbnMgZm9yIHRoZSBhdmFpbGFibGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuXG4gKiBAY29uc3RydWN0b3IgVGltZUF4aXNcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5mdW5jdGlvbiBUaW1lQXhpcyAoYm9keSwgb3B0aW9ucykge1xuICB0aGlzLmRvbSA9IHtcbiAgICBmb3JlZ3JvdW5kOiBudWxsLFxuICAgIGxpbmVzOiBbXSxcbiAgICBtYWpvclRleHRzOiBbXSxcbiAgICBtaW5vclRleHRzOiBbXSxcbiAgICByZWR1bmRhbnQ6IHtcbiAgICAgIGxpbmVzOiBbXSxcbiAgICAgIG1ham9yVGV4dHM6IFtdLFxuICAgICAgbWlub3JUZXh0czogW11cbiAgICB9XG4gIH07XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgcmFuZ2U6IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAwLFxuICAgICAgbWluaW11bVN0ZXA6IDBcbiAgICB9LFxuICAgIGxpbmVUb3A6IDBcbiAgfTtcblxuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIG9yaWVudGF0aW9uOiB7XG4gICAgICBheGlzOiAnYm90dG9tJ1xuICAgIH0sICAvLyBheGlzIG9yaWVudGF0aW9uOiAndG9wJyBvciAnYm90dG9tJ1xuICAgIHNob3dNaW5vckxhYmVsczogdHJ1ZSxcbiAgICBzaG93TWFqb3JMYWJlbHM6IHRydWUsXG4gICAgZm9ybWF0OiBUaW1lU3RlcC5GT1JNQVQsXG4gICAgbW9tZW50OiBtb21lbnQsXG4gICAgdGltZUF4aXM6IG51bGxcbiAgfTtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuXG4gIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgLy8gY3JlYXRlIHRoZSBIVE1MIERPTVxuICB0aGlzLl9jcmVhdGUoKTtcblxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG59XG5cblRpbWVBeGlzLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBTZXQgb3B0aW9ucyBmb3IgdGhlIFRpbWVBeGlzLlxuICogUGFyYW1ldGVycyB3aWxsIGJlIG1lcmdlZCBpbiBjdXJyZW50IG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgQXZhaWxhYmxlIG9wdGlvbnM6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gW29yaWVudGF0aW9uLmF4aXNdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93TWlub3JMYWJlbHNdXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFtzaG93TWFqb3JMYWJlbHNdXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucykge1xuICAgIC8vIGNvcHkgYWxsIG9wdGlvbnMgdGhhdCB3ZSBrbm93XG4gICAgdXRpbC5zZWxlY3RpdmVFeHRlbmQoW1xuICAgICAgJ3Nob3dNaW5vckxhYmVscycsXG4gICAgICAnc2hvd01ham9yTGFiZWxzJyxcbiAgICAgICdoaWRkZW5EYXRlcycsXG4gICAgICAndGltZUF4aXMnLFxuICAgICAgJ21vbWVudCdcbiAgICBdLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgLy8gZGVlcCBjb3B5IHRoZSBmb3JtYXQgb3B0aW9uc1xuICAgIHV0aWwuc2VsZWN0aXZlRGVlcEV4dGVuZChbJ2Zvcm1hdCddLCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdvcmllbnRhdGlvbicgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9yaWVudGF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyA9IG9wdGlvbnMub3JpZW50YXRpb247XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gJ29iamVjdCcgJiYgJ2F4aXMnIGluIG9wdGlvbnMub3JpZW50YXRpb24pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLmF4aXMgPSBvcHRpb25zLm9yaWVudGF0aW9uLmF4aXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgbG9jYWxlIHRvIG1vbWVudC5qc1xuICAgIC8vIFRPRE86IG5vdCBzbyBuaWNlLCB0aGlzIGlzIGFwcGxpZWQgZ2xvYmFsbHkgdG8gbW9tZW50LmpzXG4gICAgaWYgKCdsb2NhbGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgbW9tZW50LmxvY2FsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBtb21lbnQuanMgMi44LjErXG4gICAgICAgIG1vbWVudC5sb2NhbGUob3B0aW9ucy5sb2NhbGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1vbWVudC5sYW5nKG9wdGlvbnMubG9jYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBIVE1MIERPTSBmb3IgdGhlIFRpbWVBeGlzXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZG9tLmZvcmVncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy5kb20uYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIHRoaXMuZG9tLmZvcmVncm91bmQuY2xhc3NOYW1lID0gJ3Zpcy10aW1lLWF4aXMgdmlzLWZvcmVncm91bmQnO1xuICB0aGlzLmRvbS5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9ICd2aXMtdGltZS1heGlzIHZpcy1iYWNrZ3JvdW5kJztcbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgVGltZUF4aXNcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmVtb3ZlIGZyb20gRE9NXG4gIGlmICh0aGlzLmRvbS5mb3JlZ3JvdW5kLnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZm9yZWdyb3VuZCk7XG4gIH1cbiAgaWYgKHRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5iYWNrZ3JvdW5kKTtcbiAgfVxuXG4gIHRoaXMuYm9keSA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVzaXplZFxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMuZG9tLmZvcmVncm91bmQ7XG4gIHZhciBiYWNrZ3JvdW5kID0gdGhpcy5kb20uYmFja2dyb3VuZDtcblxuICAvLyBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgcGFyZW50IERPTSBlbGVtZW50IChkZXBlbmRpbmcgb24gb3B0aW9uIG9yaWVudGF0aW9uKVxuICB2YXIgcGFyZW50ID0gKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID09ICd0b3AnKSA/IHRoaXMuYm9keS5kb20udG9wIDogdGhpcy5ib2R5LmRvbS5ib3R0b207XG4gIHZhciBwYXJlbnRDaGFuZ2VkID0gKGZvcmVncm91bmQucGFyZW50Tm9kZSAhPT0gcGFyZW50KTtcblxuICAvLyBjYWxjdWxhdGUgY2hhcmFjdGVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgdGhpcy5fY2FsY3VsYXRlQ2hhclNpemUoKTtcblxuICAvLyBUT0RPOiByZWNhbGN1bGF0ZSBzaXplcyBvbmx5IG5lZWRlZCB3aGVuIHBhcmVudCBpcyByZXNpemVkIG9yIG9wdGlvbnMgaXMgY2hhbmdlZFxuICB2YXIgc2hvd01pbm9yTGFiZWxzID0gdGhpcy5vcHRpb25zLnNob3dNaW5vckxhYmVscyAmJiB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyAhPT0gJ25vbmUnO1xuICB2YXIgc2hvd01ham9yTGFiZWxzID0gdGhpcy5vcHRpb25zLnNob3dNYWpvckxhYmVscyAmJiB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcyAhPT0gJ25vbmUnO1xuXG4gIC8vIGRldGVybWluZSB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZWxlbWVucyBmb3IgdGhlIGF4aXNcbiAgcHJvcHMubWlub3JMYWJlbEhlaWdodCA9IHNob3dNaW5vckxhYmVscyA/IHByb3BzLm1pbm9yQ2hhckhlaWdodCA6IDA7XG4gIHByb3BzLm1ham9yTGFiZWxIZWlnaHQgPSBzaG93TWFqb3JMYWJlbHMgPyBwcm9wcy5tYWpvckNoYXJIZWlnaHQgOiAwO1xuICBwcm9wcy5oZWlnaHQgPSBwcm9wcy5taW5vckxhYmVsSGVpZ2h0ICsgcHJvcHMubWFqb3JMYWJlbEhlaWdodDtcbiAgcHJvcHMud2lkdGggPSBmb3JlZ3JvdW5kLm9mZnNldFdpZHRoO1xuXG4gIHByb3BzLm1pbm9yTGluZUhlaWdodCA9IHRoaXMuYm9keS5kb21Qcm9wcy5yb290LmhlaWdodCAtIHByb3BzLm1ham9yTGFiZWxIZWlnaHQgLVxuICAgICAgKHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5heGlzID09ICd0b3AnID8gdGhpcy5ib2R5LmRvbVByb3BzLmJvdHRvbS5oZWlnaHQgOiB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCk7XG4gIHByb3BzLm1pbm9yTGluZVdpZHRoID0gMTsgLy8gVE9ETzogcmVhbGx5IGNhbGN1bGF0ZSB3aWR0aFxuICBwcm9wcy5tYWpvckxpbmVIZWlnaHQgPSBwcm9wcy5taW5vckxpbmVIZWlnaHQgKyBwcm9wcy5tYWpvckxhYmVsSGVpZ2h0O1xuICBwcm9wcy5tYWpvckxpbmVXaWR0aCA9IDE7IC8vIFRPRE86IHJlYWxseSBjYWxjdWxhdGUgd2lkdGhcblxuICAvLyAgdGFrZSBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIG9mZmxpbmUgd2hpbGUgdXBkYXRpbmcgKGlzIGFsbW9zdCB0d2ljZSBhcyBmYXN0KVxuICB2YXIgZm9yZWdyb3VuZE5leHRTaWJsaW5nID0gZm9yZWdyb3VuZC5uZXh0U2libGluZztcbiAgdmFyIGJhY2tncm91bmROZXh0U2libGluZyA9IGJhY2tncm91bmQubmV4dFNpYmxpbmc7XG4gIGZvcmVncm91bmQucGFyZW50Tm9kZSAmJiBmb3JlZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZm9yZWdyb3VuZCk7XG4gIGJhY2tncm91bmQucGFyZW50Tm9kZSAmJiBiYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFja2dyb3VuZCk7XG5cbiAgZm9yZWdyb3VuZC5zdHlsZS5oZWlnaHQgPSB0aGlzLnByb3BzLmhlaWdodCArICdweCc7XG5cbiAgdGhpcy5fcmVwYWludExhYmVscygpO1xuXG4gIC8vIHB1dCBET00gb25saW5lIGFnYWluIChhdCB0aGUgc2FtZSBwbGFjZSlcbiAgaWYgKGZvcmVncm91bmROZXh0U2libGluZykge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZm9yZWdyb3VuZCwgZm9yZWdyb3VuZE5leHRTaWJsaW5nKTtcbiAgfVxuICBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZm9yZWdyb3VuZClcbiAgfVxuICBpZiAoYmFja2dyb3VuZE5leHRTaWJsaW5nKSB7XG4gICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuaW5zZXJ0QmVmb3JlKGJhY2tncm91bmQsIGJhY2tncm91bmROZXh0U2libGluZyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5ib2R5LmRvbS5iYWNrZ3JvdW5kVmVydGljYWwuYXBwZW5kQ2hpbGQoYmFja2dyb3VuZClcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9pc1Jlc2l6ZWQoKSB8fCBwYXJlbnRDaGFuZ2VkO1xufTtcblxuLyoqXG4gKiBSZXBhaW50IG1ham9yIGFuZCBtaW5vciB0ZXh0IGxhYmVscyBhbmQgdmVydGljYWwgZ3JpZCBsaW5lc1xuICogQHByaXZhdGVcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3JpZW50YXRpb24gPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uYXhpcztcblxuICAvLyBjYWxjdWxhdGUgcmFuZ2UgYW5kIHN0ZXAgKHN0ZXAgc3VjaCB0aGF0IHdlIGhhdmUgc3BhY2UgZm9yIDcgY2hhcmFjdGVycyBwZXIgbGFiZWwpXG4gIHZhciBzdGFydCA9IHV0aWwuY29udmVydCh0aGlzLmJvZHkucmFuZ2Uuc3RhcnQsICdOdW1iZXInKTtcbiAgdmFyIGVuZCA9IHV0aWwuY29udmVydCh0aGlzLmJvZHkucmFuZ2UuZW5kLCAnTnVtYmVyJyk7XG4gIHZhciB0aW1lTGFiZWxzaXplID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKCh0aGlzLnByb3BzLm1pbm9yQ2hhcldpZHRoIHx8IDEwKSAqIDcpLnZhbHVlT2YoKTtcbiAgdmFyIG1pbmltdW1TdGVwID0gdGltZUxhYmVsc2l6ZSAtIERhdGVVdGlsLmdldEhpZGRlbkR1cmF0aW9uQmVmb3JlKHRoaXMub3B0aW9ucy5tb21lbnQsIHRoaXMuYm9keS5oaWRkZW5EYXRlcywgdGhpcy5ib2R5LnJhbmdlLCB0aW1lTGFiZWxzaXplKTtcbiAgbWluaW11bVN0ZXAgLT0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKDApLnZhbHVlT2YoKTtcblxuICB2YXIgc3RlcCA9IG5ldyBUaW1lU3RlcChuZXcgRGF0ZShzdGFydCksIG5ldyBEYXRlKGVuZCksIG1pbmltdW1TdGVwLCB0aGlzLmJvZHkuaGlkZGVuRGF0ZXMpO1xuICBzdGVwLnNldE1vbWVudCh0aGlzLm9wdGlvbnMubW9tZW50KTtcbiAgaWYgKHRoaXMub3B0aW9ucy5mb3JtYXQpIHtcbiAgICBzdGVwLnNldEZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0KTtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLnRpbWVBeGlzKSB7XG4gICAgc3RlcC5zZXRTY2FsZSh0aGlzLm9wdGlvbnMudGltZUF4aXMpO1xuICB9XG4gIHRoaXMuc3RlcCA9IHN0ZXA7XG5cbiAgLy8gTW92ZSBhbGwgRE9NIGVsZW1lbnRzIHRvIGEgXCJyZWR1bmRhbnRcIiBsaXN0LCB3aGVyZSB0aGV5XG4gIC8vIGNhbiBiZSBwaWNrZWQgZm9yIHJlLXVzZSwgYW5kIGNsZWFyIHRoZSBsaXN0cyB3aXRoIGxpbmVzIGFuZCB0ZXh0cy5cbiAgLy8gQXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24gX3JlcGFpbnRMYWJlbHMsIGxlZnQgb3ZlciBlbGVtZW50cyB3aWxsIGJlIGNsZWFuZWQgdXBcbiAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICBkb20ucmVkdW5kYW50LmxpbmVzID0gZG9tLmxpbmVzO1xuICBkb20ucmVkdW5kYW50Lm1ham9yVGV4dHMgPSBkb20ubWFqb3JUZXh0cztcbiAgZG9tLnJlZHVuZGFudC5taW5vclRleHRzID0gZG9tLm1pbm9yVGV4dHM7XG4gIGRvbS5saW5lcyA9IFtdO1xuICBkb20ubWFqb3JUZXh0cyA9IFtdO1xuICBkb20ubWlub3JUZXh0cyA9IFtdO1xuXG4gIHZhciBjdXJyZW50O1xuICB2YXIgbmV4dDtcbiAgdmFyIHg7XG4gIHZhciB4TmV4dDtcbiAgdmFyIGlzTWFqb3I7XG4gIHZhciB3aWR0aDtcbiAgdmFyIGxpbmU7XG4gIHZhciBsYWJlbE1pbm9yO1xuICB2YXIgeEZpcnN0TWFqb3JMYWJlbCA9IHVuZGVmaW5lZDtcbiAgdmFyIG1heCA9IDA7XG4gIHZhciBjbGFzc05hbWU7XG5cbiAgc3RlcC5zdGFydCgpO1xuICBuZXh0ID0gc3RlcC5nZXRDdXJyZW50KCk7XG4gIHhOZXh0ID0gdGhpcy5ib2R5LnV0aWwudG9TY3JlZW4obmV4dCk7XG4gIHdoaWxlIChzdGVwLmhhc05leHQoKSAmJiBtYXggPCAxMDAwKSB7XG4gICAgbWF4Kys7XG5cbiAgICBpc01ham9yID0gc3RlcC5pc01ham9yKCk7XG4gICAgY2xhc3NOYW1lID0gc3RlcC5nZXRDbGFzc05hbWUoKTtcbiAgICBsYWJlbE1pbm9yID0gc3RlcC5nZXRMYWJlbE1pbm9yKCk7XG5cbiAgICBjdXJyZW50ID0gbmV4dDtcbiAgICB4ID0geE5leHQ7XG5cbiAgICBzdGVwLm5leHQoKTtcbiAgICBuZXh0ID0gc3RlcC5nZXRDdXJyZW50KCk7XG4gICAgeE5leHQgPSB0aGlzLmJvZHkudXRpbC50b1NjcmVlbihuZXh0KTtcblxuICAgIHdpZHRoID0geE5leHQgLSB4O1xuICAgIHZhciBsYWJlbEZpdHMgPSAobGFiZWxNaW5vci5sZW5ndGggKyAxKSAqIHRoaXMucHJvcHMubWlub3JDaGFyV2lkdGggPCB3aWR0aDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd01pbm9yTGFiZWxzICYmIGxhYmVsRml0cykge1xuICAgICAgdGhpcy5fcmVwYWludE1pbm9yVGV4dCh4LCBsYWJlbE1pbm9yLCBvcmllbnRhdGlvbiwgY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNNYWpvciAmJiB0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzKSB7XG4gICAgICBpZiAoeCA+IDApIHtcbiAgICAgICAgaWYgKHhGaXJzdE1ham9yTGFiZWwgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgeEZpcnN0TWFqb3JMYWJlbCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVwYWludE1ham9yVGV4dCh4LCBzdGVwLmdldExhYmVsTWFqb3IoKSwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICBsaW5lID0gdGhpcy5fcmVwYWludE1ham9yTGluZSh4LCB3aWR0aCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGxhYmVsRml0cykge1xuICAgICAgICBsaW5lID0gdGhpcy5fcmVwYWludE1pbm9yTGluZSh4LCB3aWR0aCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICBsaW5lLnN0eWxlLndpZHRoID0gKHBhcnNlSW50IChsaW5lLnN0eWxlLndpZHRoKSArIHdpZHRoKSArICdweCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNyZWF0ZSBhIG1ham9yIGxhYmVsIG9uIHRoZSBsZWZ0IHdoZW4gbmVlZGVkXG4gIGlmICh0aGlzLm9wdGlvbnMuc2hvd01ham9yTGFiZWxzKSB7XG4gICAgdmFyIGxlZnRUaW1lID0gdGhpcy5ib2R5LnV0aWwudG9UaW1lKDApLFxuICAgICAgICBsZWZ0VGV4dCA9IHN0ZXAuZ2V0TGFiZWxNYWpvcihsZWZ0VGltZSksXG4gICAgICAgIHdpZHRoVGV4dCA9IGxlZnRUZXh0Lmxlbmd0aCAqICh0aGlzLnByb3BzLm1ham9yQ2hhcldpZHRoIHx8IDEwKSArIDEwOyAvLyB1cHBlciBib3VuZCBlc3RpbWF0aW9uXG5cbiAgICBpZiAoeEZpcnN0TWFqb3JMYWJlbCA9PSB1bmRlZmluZWQgfHwgd2lkdGhUZXh0IDwgeEZpcnN0TWFqb3JMYWJlbCkge1xuICAgICAgdGhpcy5fcmVwYWludE1ham9yVGV4dCgwLCBsZWZ0VGV4dCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW51cCBsZWZ0b3ZlciBET00gZWxlbWVudHMgZnJvbSB0aGUgcmVkdW5kYW50IGxpc3RcbiAgdXRpbC5mb3JFYWNoKHRoaXMuZG9tLnJlZHVuZGFudCwgZnVuY3Rpb24gKGFycikge1xuICAgIHdoaWxlIChhcnIubGVuZ3RoKSB7XG4gICAgICB2YXIgZWxlbSA9IGFyci5wb3AoKTtcbiAgICAgIGlmIChlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbWlub3IgbGFiZWwgZm9yIHRoZSBheGlzIGF0IHBvc2l0aW9uIHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgSFRNTCBlbGVtZW50IG9mIHRoZSBjcmVhdGVkIGxhYmVsXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNaW5vclRleHQgPSBmdW5jdGlvbiAoeCwgdGV4dCwgb3JpZW50YXRpb24sIGNsYXNzTmFtZSkge1xuICAvLyByZXVzZSByZWR1bmRhbnQgbGFiZWxcbiAgdmFyIGxhYmVsID0gdGhpcy5kb20ucmVkdW5kYW50Lm1pbm9yVGV4dHMuc2hpZnQoKTtcblxuICBpZiAoIWxhYmVsKSB7XG4gICAgLy8gY3JlYXRlIG5ldyBsYWJlbFxuICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbGFiZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgdGhpcy5kb20uZm9yZWdyb3VuZC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gIH1cbiAgdGhpcy5kb20ubWlub3JUZXh0cy5wdXNoKGxhYmVsKTtcblxuICBsYWJlbC5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA9IHRleHQ7XG5cbiAgbGFiZWwuc3R5bGUudG9wID0gKG9yaWVudGF0aW9uID09ICd0b3AnKSA/ICh0aGlzLnByb3BzLm1ham9yTGFiZWxIZWlnaHQgKyAncHgnKSA6ICcwJztcbiAgbGFiZWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuICBsYWJlbC5jbGFzc05hbWUgPSAndmlzLXRleHQgdmlzLW1pbm9yICcgKyBjbGFzc05hbWU7XG4gIC8vbGFiZWwudGl0bGUgPSB0aXRsZTsgIC8vIFRPRE86IHRoaXMgaXMgYSBoZWF2eSBvcGVyYXRpb25cblxuICByZXR1cm4gbGFiZWw7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIE1ham9yIGxhYmVsIGZvciB0aGUgYXhpcyBhdCBwb3NpdGlvbiB4XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcmllbnRhdGlvbiAgIFwidG9wXCIgb3IgXCJib3R0b21cIiAoZGVmYXVsdClcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCBvZiB0aGUgY3JlYXRlZCBsYWJlbFxuICogQHByaXZhdGVcbiAqL1xuVGltZUF4aXMucHJvdG90eXBlLl9yZXBhaW50TWFqb3JUZXh0ID0gZnVuY3Rpb24gKHgsIHRleHQsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpIHtcbiAgLy8gcmV1c2UgcmVkdW5kYW50IGxhYmVsXG4gIHZhciBsYWJlbCA9IHRoaXMuZG9tLnJlZHVuZGFudC5tYWpvclRleHRzLnNoaWZ0KCk7XG5cbiAgaWYgKCFsYWJlbCkge1xuICAgIC8vIGNyZWF0ZSBsYWJlbFxuICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsYWJlbC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB0aGlzLmRvbS5mb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgfVxuICB0aGlzLmRvbS5tYWpvclRleHRzLnB1c2gobGFiZWwpO1xuXG4gIGxhYmVsLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlID0gdGV4dDtcbiAgbGFiZWwuY2xhc3NOYW1lID0gJ3Zpcy10ZXh0IHZpcy1tYWpvciAnICsgY2xhc3NOYW1lO1xuICAvL2xhYmVsLnRpdGxlID0gdGl0bGU7IC8vIFRPRE86IHRoaXMgaXMgYSBoZWF2eSBvcGVyYXRpb25cblxuICBsYWJlbC5zdHlsZS50b3AgPSAob3JpZW50YXRpb24gPT0gJ3RvcCcpID8gJzAnIDogKHRoaXMucHJvcHMubWlub3JMYWJlbEhlaWdodCAgKyAncHgnKTtcbiAgbGFiZWwuc3R5bGUubGVmdCA9IHggKyAncHgnO1xuXG4gIHJldHVybiBsYWJlbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbWlub3IgbGluZSBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgY3JlYXRlZCBsaW5lXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNaW5vckxpbmUgPSBmdW5jdGlvbiAoeCwgd2lkdGgsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpIHtcbiAgLy8gcmV1c2UgcmVkdW5kYW50IGxpbmVcbiAgdmFyIGxpbmUgPSB0aGlzLmRvbS5yZWR1bmRhbnQubGluZXMuc2hpZnQoKTtcbiAgaWYgKCFsaW5lKSB7XG4gICAgLy8gY3JlYXRlIHZlcnRpY2FsIGxpbmVcbiAgICBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZChsaW5lKTtcbiAgfVxuICB0aGlzLmRvbS5saW5lcy5wdXNoKGxpbmUpO1xuXG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgIGxpbmUuc3R5bGUudG9wID0gcHJvcHMubWFqb3JMYWJlbEhlaWdodCArICdweCc7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGluZS5zdHlsZS50b3AgPSB0aGlzLmJvZHkuZG9tUHJvcHMudG9wLmhlaWdodCArICdweCc7XG4gIH1cbiAgbGluZS5zdHlsZS5oZWlnaHQgPSBwcm9wcy5taW5vckxpbmVIZWlnaHQgKyAncHgnO1xuICBsaW5lLnN0eWxlLmxlZnQgPSAoeCAtIHByb3BzLm1pbm9yTGluZVdpZHRoIC8gMikgKyAncHgnO1xuICBsaW5lLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXG4gIGxpbmUuY2xhc3NOYW1lID0gJ3Zpcy1ncmlkIHZpcy12ZXJ0aWNhbCB2aXMtbWlub3IgJyArIGNsYXNzTmFtZTtcblxuICByZXR1cm4gbGluZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgTWFqb3IgbGluZSBmb3IgdGhlIGF4aXMgYXQgcG9zaXRpb24geFxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtTdHJpbmd9IG9yaWVudGF0aW9uICAgXCJ0b3BcIiBvciBcImJvdHRvbVwiIChkZWZhdWx0KVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgY3JlYXRlZCBsaW5lXG4gKiBAcHJpdmF0ZVxuICovXG5UaW1lQXhpcy5wcm90b3R5cGUuX3JlcGFpbnRNYWpvckxpbmUgPSBmdW5jdGlvbiAoeCwgd2lkdGgsIG9yaWVudGF0aW9uLCBjbGFzc05hbWUpIHtcbiAgLy8gcmV1c2UgcmVkdW5kYW50IGxpbmVcbiAgdmFyIGxpbmUgPSB0aGlzLmRvbS5yZWR1bmRhbnQubGluZXMuc2hpZnQoKTtcbiAgaWYgKCFsaW5lKSB7XG4gICAgLy8gY3JlYXRlIHZlcnRpY2FsIGxpbmVcbiAgICBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5kb20uYmFja2dyb3VuZC5hcHBlbmRDaGlsZChsaW5lKTtcbiAgfVxuICB0aGlzLmRvbS5saW5lcy5wdXNoKGxpbmUpO1xuXG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgIGxpbmUuc3R5bGUudG9wID0gJzAnO1xuICB9XG4gIGVsc2Uge1xuICAgIGxpbmUuc3R5bGUudG9wID0gdGhpcy5ib2R5LmRvbVByb3BzLnRvcC5oZWlnaHQgKyAncHgnO1xuICB9XG4gIGxpbmUuc3R5bGUubGVmdCA9ICh4IC0gcHJvcHMubWFqb3JMaW5lV2lkdGggLyAyKSArICdweCc7XG4gIGxpbmUuc3R5bGUuaGVpZ2h0ID0gcHJvcHMubWFqb3JMaW5lSGVpZ2h0ICsgJ3B4JztcbiAgbGluZS5zdHlsZS53aWR0aCA9IHdpZHRoICArICdweCc7XG5cbiAgbGluZS5jbGFzc05hbWUgPSAndmlzLWdyaWQgdmlzLXZlcnRpY2FsIHZpcy1tYWpvciAnICsgY2xhc3NOYW1lO1xuXG4gIHJldHVybiBsaW5lO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGV4dCBvbiB0aGUgYXhpcyAoYm90aCBtYWpvciBhbmQgbWlub3IgYXhpcykuXG4gKiBUaGUgc2l6ZSBpcyBjYWxjdWxhdGVkIG9ubHkgb25jZSBhbmQgdGhlbiBjYWNoZWQgaW4gdGhpcy5wcm9wcy5cbiAqIEBwcml2YXRlXG4gKi9cblRpbWVBeGlzLnByb3RvdHlwZS5fY2FsY3VsYXRlQ2hhclNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE5vdGU6IFdlIGNhbGN1bGF0ZSBjaGFyIHNpemUgd2l0aCBldmVyeSByZWRyYXcuIFNpemUgbWF5IGNoYW5nZSwgZm9yXG4gIC8vIGV4YW1wbGUgd2hlbiBhbnkgb2YgdGhlIHRpbWVsaW5lcyBwYXJlbnRzIGhhZCBkaXNwbGF5Om5vbmUgZm9yIGV4YW1wbGUuXG5cbiAgLy8gZGV0ZXJtaW5lIHRoZSBjaGFyIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG1pbm9yIGF4aXNcbiAgaWYgKCF0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yKSB7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuY2xhc3NOYW1lID0gJ3Zpcy10ZXh0IHZpcy1taW5vciB2aXMtbWVhc3VyZSc7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcwJykpO1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubWVhc3VyZUNoYXJNaW5vcik7XG4gIH1cbiAgdGhpcy5wcm9wcy5taW5vckNoYXJIZWlnaHQgPSB0aGlzLmRvbS5tZWFzdXJlQ2hhck1pbm9yLmNsaWVudEhlaWdodDtcbiAgdGhpcy5wcm9wcy5taW5vckNoYXJXaWR0aCA9IHRoaXMuZG9tLm1lYXN1cmVDaGFyTWlub3IuY2xpZW50V2lkdGg7XG5cbiAgLy8gZGV0ZXJtaW5lIHRoZSBjaGFyIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG1ham9yIGF4aXNcbiAgaWYgKCF0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yKSB7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IuY2xhc3NOYW1lID0gJ3Zpcy10ZXh0IHZpcy1tYWpvciB2aXMtbWVhc3VyZSc7XG4gICAgdGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcwJykpO1xuICAgIHRoaXMuZG9tLmZvcmVncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5kb20ubWVhc3VyZUNoYXJNYWpvcik7XG4gIH1cbiAgdGhpcy5wcm9wcy5tYWpvckNoYXJIZWlnaHQgPSB0aGlzLmRvbS5tZWFzdXJlQ2hhck1ham9yLmNsaWVudEhlaWdodDtcbiAgdGhpcy5wcm9wcy5tYWpvckNoYXJXaWR0aCA9IHRoaXMuZG9tLm1lYXN1cmVDaGFyTWFqb3IuY2xpZW50V2lkdGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVBeGlzO1xuIl19
},{"../../module/moment":20,"../../util":46,"../DateUtil":27,"../TimeStep":30,"./Component":33}],39:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var Item = require('./Item');
var BackgroundGroup = require('../BackgroundGroup');
var RangeItem = require('./RangeItem');

/**
 * @constructor BackgroundItem
 * @extends Item
 * @param {Object} data             Object containing parameters start, end
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe options
 */
// TODO: implement support for the BackgroundItem just having a start, then being displayed as a sort of an annotation
function BackgroundItem(data, conversion, options) {
  this.props = {
    content: {
      width: 0
    }
  };
  this.overflow = false; // if contents can overflow (css styling), this flag is set to true

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data.id);
    }
    if (data.end == undefined) {
      throw new Error('Property "end" missing in item ' + data.id);
    }
  }

  Item.call(this, data, conversion, options);
}

BackgroundItem.prototype = new Item(null, null, null);

BackgroundItem.prototype.baseClassName = 'vis-item vis-background';
BackgroundItem.prototype.stack = false;

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
BackgroundItem.prototype.isVisible = function (range) {
  // determine visibility
  return this.data.start < range.end && this.data.end > range.start;
};

/**
 * Repaint the item
 */
BackgroundItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.box = document.createElement('div');
    // className is updated in redraw()

    // frame box (to prevent the item contents from overflowing
    dom.frame = document.createElement('div');
    dom.frame.className = 'vis-item-overflow';
    dom.box.appendChild(dom.frame);

    // contents box
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.frame.appendChild(dom.content);

    // Note: we do NOT attach this item as attribute to the DOM,
    //       such that background items cannot be selected
    //dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var background = this.parent.dom.background;
    if (!background) {
      throw new Error('Cannot redraw item: parent has no background container element');
    }
    background.appendChild(dom.box);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.content);
    this._updateDataAttributes(this.dom.content);
    this._updateStyle(this.dom.box);

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '');
    dom.box.className = this.baseClassName + className;

    // determine from css whether this box has overflow
    this.overflow = window.getComputedStyle(dom.content).overflow !== 'hidden';

    // recalculate size
    this.props.content.width = this.dom.content.offsetWidth;
    this.height = 0; // set height zero, so this item will be ignored when stacking items

    this.dirty = false;
  }
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
BackgroundItem.prototype.show = RangeItem.prototype.show;

/**
 * Hide the item from the DOM (when visible)
 * @return {Boolean} changed
 */
BackgroundItem.prototype.hide = RangeItem.prototype.hide;

/**
 * Reposition the item horizontally
 * @Override
 */
BackgroundItem.prototype.repositionX = RangeItem.prototype.repositionX;

/**
 * Reposition the item vertically
 * @Override
 */
BackgroundItem.prototype.repositionY = function (margin) {
  var onTop = this.options.orientation.item === 'top';
  this.dom.content.style.top = onTop ? '' : '0';
  this.dom.content.style.bottom = onTop ? '0' : '';
  var height;

  // special positioning for subgroups
  if (this.data.subgroup !== undefined) {
    // TODO: instead of calculating the top position of the subgroups here for every BackgroundItem, calculate the top of the subgroup once in Itemset

    var itemSubgroup = this.data.subgroup;
    var subgroups = this.parent.subgroups;
    var subgroupIndex = subgroups[itemSubgroup].index;
    // if the orientation is top, we need to take the difference in height into account.
    if (onTop == true) {
      // the first subgroup will have to account for the distance from the top to the first item.
      height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
      height += subgroupIndex == 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
      var newTop = this.parent.top;
      for (var subgroup in subgroups) {
        if (subgroups.hasOwnProperty(subgroup)) {
          if (subgroups[subgroup].visible == true && subgroups[subgroup].index < subgroupIndex) {
            newTop += subgroups[subgroup].height + margin.item.vertical;
          }
        }
      }

      // the others will have to be offset downwards with this same distance.
      newTop += subgroupIndex != 0 ? margin.axis - 0.5 * margin.item.vertical : 0;
      this.dom.box.style.top = newTop + 'px';
      this.dom.box.style.bottom = '';
    }
    // and when the orientation is bottom:
    else {
        var newTop = this.parent.top;
        var totalHeight = 0;
        for (var subgroup in subgroups) {
          if (subgroups.hasOwnProperty(subgroup)) {
            if (subgroups[subgroup].visible == true) {
              var newHeight = subgroups[subgroup].height + margin.item.vertical;
              totalHeight += newHeight;
              if (subgroups[subgroup].index > subgroupIndex) {
                newTop += newHeight;
              }
            }
          }
        }
        height = this.parent.subgroups[itemSubgroup].height + margin.item.vertical;
        this.dom.box.style.top = this.parent.height - totalHeight + newTop + 'px';
        this.dom.box.style.bottom = '';
      }
  }
  // and in the case of no subgroups:
  else {
      // we want backgrounds with groups to only show in groups.
      if (this.parent instanceof BackgroundGroup) {
        // if the item is not in a group:
        height = Math.max(this.parent.height, this.parent.itemSet.body.domProps.center.height, this.parent.itemSet.body.domProps.centerContainer.height);
        this.dom.box.style.top = onTop ? '0' : '';
        this.dom.box.style.bottom = onTop ? '' : '0';
      } else {
        height = this.parent.height;
        // same alignment for items when orientation is top or bottom
        this.dom.box.style.top = this.parent.top + 'px';
        this.dom.box.style.bottom = '';
      }
    }
  this.dom.box.style.height = height + 'px';
};

module.exports = BackgroundItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9CYWNrZ3JvdW5kSXRlbS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0FBQy9DLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUM3QixJQUFJLGVBQWUsR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUNwRCxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7QUFhdkMsU0FBUyxjQUFjLENBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUU7QUFDbEQsTUFBSSxDQUFDLEtBQUssR0FBRztBQUNYLFdBQU8sRUFBRTtBQUNQLFdBQUssRUFBRSxDQUFDO0tBQ1Q7R0FDRixDQUFDO0FBQ0YsTUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7OztBQUd0QixNQUFJLElBQUksRUFBRTtBQUNSLFFBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxTQUFTLEVBQUU7QUFDM0IsWUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDaEU7QUFDRCxRQUFJLElBQUksQ0FBQyxHQUFHLElBQUksU0FBUyxFQUFFO0FBQ3pCLFlBQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQzlEO0dBQ0Y7O0FBRUQsTUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztDQUM1Qzs7QUFFRCxjQUFjLENBQUMsU0FBUyxHQUFHLElBQUksSUFBSSxDQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7O0FBRXZELGNBQWMsQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLHlCQUF5QixDQUFDO0FBQ25FLGNBQWMsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzs7Ozs7OztBQU92QyxjQUFjLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFTLEtBQUssRUFBRTs7QUFFbkQsU0FBTyxBQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLElBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEtBQUssQUFBQyxDQUFDO0NBQ3ZFLENBQUM7Ozs7O0FBS0YsY0FBYyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsWUFBVztBQUMzQyxNQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO0FBQ25CLE1BQUksQ0FBQyxHQUFHLEVBQUU7O0FBRVIsUUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDZCxPQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQzs7O0FBR2YsT0FBRyxDQUFDLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDOzs7O0FBSXhDLE9BQUcsQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxQyxPQUFHLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQztBQUMxQyxPQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7OztBQUcvQixPQUFHLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDNUMsT0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsa0JBQWtCLENBQUM7QUFDM0MsT0FBRyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDOzs7Ozs7QUFNbkMsUUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7R0FDbkI7OztBQUdELE1BQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ2hCLFVBQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQztHQUMzRDtBQUNELE1BQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRTtBQUN2QixRQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7QUFDNUMsUUFBSSxDQUFDLFVBQVUsRUFBRTtBQUNmLFlBQU0sSUFBSSxLQUFLLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztLQUNuRjtBQUNELGNBQVUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0dBQ2pDO0FBQ0QsTUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7Ozs7OztBQU10QixNQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7QUFDZCxRQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdkMsUUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3BDLFFBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdDLFFBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7O0FBR2hDLFFBQUksU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFJLEVBQUUsQ0FBQSxJQUNsRSxJQUFJLENBQUMsUUFBUSxHQUFHLGVBQWUsR0FBRyxFQUFFLENBQUEsQUFBQyxDQUFDO0FBQzNDLE9BQUcsQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhLEdBQUcsU0FBUyxDQUFDOzs7QUFHbkQsUUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsS0FBSyxRQUFRLENBQUM7OztBQUczRSxRQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDO0FBQ3hELFFBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDOztBQUVoQixRQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztHQUNwQjtDQUNGLENBQUM7Ozs7OztBQU1GLGNBQWMsQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDOzs7Ozs7QUFNekQsY0FBYyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7Ozs7OztBQU16RCxjQUFjLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQzs7Ozs7O0FBTXZFLGNBQWMsQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLFVBQVMsTUFBTSxFQUFFO0FBQ3RELE1BQUksS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksS0FBSyxLQUFLLENBQUM7QUFDcEQsTUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHLEdBQUcsQ0FBQztBQUM5QyxNQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2pELE1BQUksTUFBTSxDQUFDOzs7QUFHWCxNQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxLQUFLLFNBQVMsRUFBRTs7O0FBR3BDLFFBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQ3RDLFFBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDO0FBQ3RDLFFBQUksYUFBYSxHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxLQUFLLENBQUM7O0FBRWxELFFBQUksS0FBSyxJQUFJLElBQUksRUFBRTs7QUFFakIsWUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztBQUMzRSxZQUFNLElBQUksYUFBYSxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFDMUUsVUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7QUFDN0IsV0FBSyxJQUFJLFFBQVEsSUFBSSxTQUFTLEVBQUU7QUFDOUIsWUFBSSxTQUFTLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxFQUFFO0FBQ3RDLGNBQUksU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sSUFBSSxJQUFJLElBQUksU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssR0FBRyxhQUFhLEVBQUU7QUFDcEYsa0JBQU0sSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1dBQzdEO1NBQ0Y7T0FDRjs7O0FBR0QsWUFBTSxJQUFJLGFBQWEsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FBQzVFLFVBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQztBQUN2QyxVQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztLQUNoQzs7U0FFSTtBQUNILFlBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDO0FBQzdCLFlBQUksV0FBVyxHQUFHLENBQUMsQ0FBQztBQUNwQixhQUFLLElBQUksUUFBUSxJQUFJLFNBQVMsRUFBRTtBQUM5QixjQUFJLFNBQVMsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7QUFDdEMsZ0JBQUksU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sSUFBSSxJQUFJLEVBQUU7QUFDdkMsa0JBQUksU0FBUyxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7QUFDbEUseUJBQVcsSUFBSSxTQUFTLENBQUM7QUFDekIsa0JBQUksU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssR0FBRyxhQUFhLEVBQUU7QUFDN0Msc0JBQU0sSUFBSSxTQUFTLENBQUM7ZUFDckI7YUFDRjtXQUNGO1NBQ0Y7QUFDRCxjQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQzNFLFlBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxXQUFXLEdBQUcsTUFBTSxHQUFJLElBQUksQ0FBQztBQUM1RSxZQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztPQUNoQztHQUNGOztPQUVJOztBQUVILFVBQUksSUFBSSxDQUFDLE1BQU0sWUFBWSxlQUFlLEVBQUU7O0FBRTFDLGNBQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQy9DLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzlELFlBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDMUMsWUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLLEdBQUcsRUFBRSxHQUFHLEdBQUcsQ0FBQztPQUM5QyxNQUNJO0FBQ0gsY0FBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDOztBQUU1QixZQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztBQUNoRCxZQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztPQUNoQztLQUNGO0FBQ0QsTUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDO0NBQzNDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxjQUFjLENBQUMiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL0JhY2tncm91bmRJdGVtLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhhbW1lciA9IHJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZS9oYW1tZXInKTtcbnZhciBJdGVtID0gcmVxdWlyZSgnLi9JdGVtJyk7XG52YXIgQmFja2dyb3VuZEdyb3VwID0gcmVxdWlyZSgnLi4vQmFja2dyb3VuZEdyb3VwJyk7XG52YXIgUmFuZ2VJdGVtID0gcmVxdWlyZSgnLi9SYW5nZUl0ZW0nKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgQmFja2dyb3VuZEl0ZW1cbiAqIEBleHRlbmRzIEl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgc3RhcnQsIGVuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCwgY2xhc3NOYW1lLlxuICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBvcHRpb25zXG4gKi9cbi8vIFRPRE86IGltcGxlbWVudCBzdXBwb3J0IGZvciB0aGUgQmFja2dyb3VuZEl0ZW0ganVzdCBoYXZpbmcgYSBzdGFydCwgdGhlbiBiZWluZyBkaXNwbGF5ZWQgYXMgYSBzb3J0IG9mIGFuIGFubm90YXRpb25cbmZ1bmN0aW9uIEJhY2tncm91bmRJdGVtIChkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgY29udGVudDoge1xuICAgICAgd2lkdGg6IDBcbiAgICB9XG4gIH07XG4gIHRoaXMub3ZlcmZsb3cgPSBmYWxzZTsgLy8gaWYgY29udGVudHMgY2FuIG92ZXJmbG93IChjc3Mgc3R5bGluZyksIHRoaXMgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuXG4gIC8vIHZhbGlkYXRlIGRhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgfVxuICAgIGlmIChkYXRhLmVuZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJlbmRcIiBtaXNzaW5nIGluIGl0ZW0gJyArIGRhdGEuaWQpO1xuICAgIH1cbiAgfVxuXG4gIEl0ZW0uY2FsbCh0aGlzLCBkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKTtcbn1cblxuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlID0gbmV3IEl0ZW0gKG51bGwsIG51bGwsIG51bGwpO1xuXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUuYmFzZUNsYXNzTmFtZSA9ICd2aXMtaXRlbSB2aXMtYmFja2dyb3VuZCc7XG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUuc3RhY2sgPSBmYWxzZTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAqL1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIC8vIGRldGVybWluZSB2aXNpYmlsaXR5XG4gIHJldHVybiAodGhpcy5kYXRhLnN0YXJ0IDwgcmFuZ2UuZW5kKSAmJiAodGhpcy5kYXRhLmVuZCA+IHJhbmdlLnN0YXJ0KTtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgaXRlbVxuICovXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgaWYgKCFkb20pIHtcbiAgICAvLyBjcmVhdGUgRE9NXG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICBkb20gPSB0aGlzLmRvbTtcblxuICAgIC8vIGJhY2tncm91bmQgYm94XG4gICAgZG9tLmJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vIGNsYXNzTmFtZSBpcyB1cGRhdGVkIGluIHJlZHJhdygpXG5cbiAgICAvLyBmcmFtZSBib3ggKHRvIHByZXZlbnQgdGhlIGl0ZW0gY29udGVudHMgZnJvbSBvdmVyZmxvd2luZ1xuICAgIGRvbS5mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5mcmFtZS5jbGFzc05hbWUgPSAndmlzLWl0ZW0tb3ZlcmZsb3cnO1xuICAgIGRvbS5ib3guYXBwZW5kQ2hpbGQoZG9tLmZyYW1lKTtcblxuICAgIC8vIGNvbnRlbnRzIGJveFxuICAgIGRvbS5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgIGRvbS5mcmFtZS5hcHBlbmRDaGlsZChkb20uY29udGVudCk7XG5cbiAgICAvLyBOb3RlOiB3ZSBkbyBOT1QgYXR0YWNoIHRoaXMgaXRlbSBhcyBhdHRyaWJ1dGUgdG8gdGhlIERPTSxcbiAgICAvLyAgICAgICBzdWNoIHRoYXQgYmFja2dyb3VuZCBpdGVtcyBjYW5ub3QgYmUgc2VsZWN0ZWRcbiAgICAvL2RvbS5ib3hbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IG5vIHBhcmVudCBhdHRhY2hlZCcpO1xuICB9XG4gIGlmICghZG9tLmJveC5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGJhY2tncm91bmQgPSB0aGlzLnBhcmVudC5kb20uYmFja2dyb3VuZDtcbiAgICBpZiAoIWJhY2tncm91bmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGJhY2tncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICB9XG4gICAgYmFja2dyb3VuZC5hcHBlbmRDaGlsZChkb20uYm94KTtcbiAgfVxuICB0aGlzLmRpc3BsYXllZCA9IHRydWU7XG5cbiAgLy8gVXBkYXRlIERPTSB3aGVuIGl0ZW0gaXMgbWFya2VkIGRpcnR5LiBBbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eSB3aGVuOlxuICAvLyAtIHRoZSBpdGVtIGlzIG5vdCB5ZXQgcmVuZGVyZWRcbiAgLy8gLSB0aGUgaXRlbSdzIGRhdGEgaXMgY2hhbmdlZFxuICAvLyAtIHRoZSBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICB0aGlzLl91cGRhdGVDb250ZW50cyh0aGlzLmRvbS5jb250ZW50KTtcbiAgICB0aGlzLl91cGRhdGVUaXRsZSh0aGlzLmRvbS5jb250ZW50KTtcbiAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5jb250ZW50KTtcbiAgICB0aGlzLl91cGRhdGVTdHlsZSh0aGlzLmRvbS5ib3gpO1xuXG4gICAgLy8gdXBkYXRlIGNsYXNzXG4gICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lID8gKCcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUpIDogJycpICtcbiAgICAgICAgKHRoaXMuc2VsZWN0ZWQgPyAnIHZpcy1zZWxlY3RlZCcgOiAnJyk7XG4gICAgZG9tLmJveC5jbGFzc05hbWUgPSB0aGlzLmJhc2VDbGFzc05hbWUgKyBjbGFzc05hbWU7XG5cbiAgICAvLyBkZXRlcm1pbmUgZnJvbSBjc3Mgd2hldGhlciB0aGlzIGJveCBoYXMgb3ZlcmZsb3dcbiAgICB0aGlzLm92ZXJmbG93ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tLmNvbnRlbnQpLm92ZXJmbG93ICE9PSAnaGlkZGVuJztcblxuICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGggPSB0aGlzLmRvbS5jb250ZW50Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDsgLy8gc2V0IGhlaWdodCB6ZXJvLCBzbyB0aGlzIGl0ZW0gd2lsbCBiZSBpZ25vcmVkIHdoZW4gc3RhY2tpbmcgaXRlbXNcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTaG93IHRoZSBpdGVtIGluIHRoZSBET00gKHdoZW4gbm90IGFscmVhZHkgdmlzaWJsZSkuIFRoZSBpdGVtcyBET00gd2lsbFxuICogYmUgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqL1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLnNob3cgPSBSYW5nZUl0ZW0ucHJvdG90eXBlLnNob3c7XG5cbi8qKlxuICogSGlkZSB0aGUgaXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAqL1xuQmFja2dyb3VuZEl0ZW0ucHJvdG90eXBlLmhpZGUgPSBSYW5nZUl0ZW0ucHJvdG90eXBlLmhpZGU7XG5cbi8qKlxuICogUmVwb3NpdGlvbiB0aGUgaXRlbSBob3Jpem9udGFsbHlcbiAqIEBPdmVycmlkZVxuICovXG5CYWNrZ3JvdW5kSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBSYW5nZUl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YO1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gdmVydGljYWxseVxuICogQE92ZXJyaWRlXG4gKi9cbkJhY2tncm91bmRJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWSA9IGZ1bmN0aW9uKG1hcmdpbikge1xuICB2YXIgb25Ub3AgPSB0aGlzLm9wdGlvbnMub3JpZW50YXRpb24uaXRlbSA9PT0gJ3RvcCc7XG4gIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUudG9wID0gb25Ub3AgPyAnJyA6ICcwJztcbiAgdGhpcy5kb20uY29udGVudC5zdHlsZS5ib3R0b20gPSBvblRvcCA/ICcwJyA6ICcnO1xuICB2YXIgaGVpZ2h0O1xuXG4gIC8vIHNwZWNpYWwgcG9zaXRpb25pbmcgZm9yIHN1Ymdyb3Vwc1xuICBpZiAodGhpcy5kYXRhLnN1Ymdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIGNhbGN1bGF0aW5nIHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIHN1Ymdyb3VwcyBoZXJlIGZvciBldmVyeSBCYWNrZ3JvdW5kSXRlbSwgY2FsY3VsYXRlIHRoZSB0b3Agb2YgdGhlIHN1Ymdyb3VwIG9uY2UgaW4gSXRlbXNldFxuXG4gICAgdmFyIGl0ZW1TdWJncm91cCA9IHRoaXMuZGF0YS5zdWJncm91cDtcbiAgICB2YXIgc3ViZ3JvdXBzID0gdGhpcy5wYXJlbnQuc3ViZ3JvdXBzO1xuICAgIHZhciBzdWJncm91cEluZGV4ID0gc3ViZ3JvdXBzW2l0ZW1TdWJncm91cF0uaW5kZXg7XG4gICAgLy8gaWYgdGhlIG9yaWVudGF0aW9uIGlzIHRvcCwgd2UgbmVlZCB0byB0YWtlIHRoZSBkaWZmZXJlbmNlIGluIGhlaWdodCBpbnRvIGFjY291bnQuXG4gICAgaWYgKG9uVG9wID09IHRydWUpIHtcbiAgICAgIC8vIHRoZSBmaXJzdCBzdWJncm91cCB3aWxsIGhhdmUgdG8gYWNjb3VudCBmb3IgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHRvcCB0byB0aGUgZmlyc3QgaXRlbS5cbiAgICAgIGhlaWdodCA9IHRoaXMucGFyZW50LnN1Ymdyb3Vwc1tpdGVtU3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgaGVpZ2h0ICs9IHN1Ymdyb3VwSW5kZXggPT0gMCA/IG1hcmdpbi5heGlzIC0gMC41Km1hcmdpbi5pdGVtLnZlcnRpY2FsIDogMDtcbiAgICAgIHZhciBuZXdUb3AgPSB0aGlzLnBhcmVudC50b3A7XG4gICAgICBmb3IgKHZhciBzdWJncm91cCBpbiBzdWJncm91cHMpIHtcbiAgICAgICAgaWYgKHN1Ymdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShzdWJncm91cCkpIHtcbiAgICAgICAgICBpZiAoc3ViZ3JvdXBzW3N1Ymdyb3VwXS52aXNpYmxlID09IHRydWUgJiYgc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pbmRleCA8IHN1Ymdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIG5ld1RvcCArPSBzdWJncm91cHNbc3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0aGUgb3RoZXJzIHdpbGwgaGF2ZSB0byBiZSBvZmZzZXQgZG93bndhcmRzIHdpdGggdGhpcyBzYW1lIGRpc3RhbmNlLlxuICAgICAgbmV3VG9wICs9IHN1Ymdyb3VwSW5kZXggIT0gMCA/IG1hcmdpbi5heGlzIC0gMC41ICogbWFyZ2luLml0ZW0udmVydGljYWwgOiAwO1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnRvcCA9IG5ld1RvcCArICdweCc7XG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUuYm90dG9tID0gJyc7XG4gICAgfVxuICAgIC8vIGFuZCB3aGVuIHRoZSBvcmllbnRhdGlvbiBpcyBib3R0b206XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VG9wID0gdGhpcy5wYXJlbnQudG9wO1xuICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIHN1Ymdyb3VwIGluIHN1Ymdyb3Vwcykge1xuICAgICAgICBpZiAoc3ViZ3JvdXBzLmhhc093blByb3BlcnR5KHN1Ymdyb3VwKSkge1xuICAgICAgICAgIGlmIChzdWJncm91cHNbc3ViZ3JvdXBdLnZpc2libGUgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IHN1Ymdyb3Vwc1tzdWJncm91cF0uaGVpZ2h0ICsgbWFyZ2luLml0ZW0udmVydGljYWw7XG4gICAgICAgICAgICB0b3RhbEhlaWdodCArPSBuZXdIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc3ViZ3JvdXBzW3N1Ymdyb3VwXS5pbmRleCA+IHN1Ymdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgICAgbmV3VG9wICs9IG5ld0hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhlaWdodCA9IHRoaXMucGFyZW50LnN1Ymdyb3Vwc1tpdGVtU3ViZ3JvdXBdLmhlaWdodCArIG1hcmdpbi5pdGVtLnZlcnRpY2FsO1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLnRvcCA9ICh0aGlzLnBhcmVudC5oZWlnaHQgLSB0b3RhbEhlaWdodCArIG5ld1RvcCkgKyAncHgnO1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIH1cbiAgfVxuICAvLyBhbmQgaW4gdGhlIGNhc2Ugb2Ygbm8gc3ViZ3JvdXBzOlxuICBlbHNlIHtcbiAgICAvLyB3ZSB3YW50IGJhY2tncm91bmRzIHdpdGggZ3JvdXBzIHRvIG9ubHkgc2hvdyBpbiBncm91cHMuXG4gICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgQmFja2dyb3VuZEdyb3VwKSB7XG4gICAgICAvLyBpZiB0aGUgaXRlbSBpcyBub3QgaW4gYSBncm91cDpcbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KHRoaXMucGFyZW50LmhlaWdodCxcbiAgICAgICAgICB0aGlzLnBhcmVudC5pdGVtU2V0LmJvZHkuZG9tUHJvcHMuY2VudGVyLmhlaWdodCxcbiAgICAgICAgICB0aGlzLnBhcmVudC5pdGVtU2V0LmJvZHkuZG9tUHJvcHMuY2VudGVyQ29udGFpbmVyLmhlaWdodCk7XG4gICAgICB0aGlzLmRvbS5ib3guc3R5bGUudG9wID0gb25Ub3AgPyAnMCcgOiAnJztcbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS5ib3R0b20gPSBvblRvcCA/ICcnIDogJzAnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMucGFyZW50LmhlaWdodDtcbiAgICAgIC8vIHNhbWUgYWxpZ25tZW50IGZvciBpdGVtcyB3aGVuIG9yaWVudGF0aW9uIGlzIHRvcCBvciBib3R0b21cbiAgICAgIHRoaXMuZG9tLmJveC5zdHlsZS50b3AgPSB0aGlzLnBhcmVudC50b3AgKyAncHgnO1xuICAgICAgdGhpcy5kb20uYm94LnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIH1cbiAgfVxuICB0aGlzLmRvbS5ib3guc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2dyb3VuZEl0ZW07XG4iXX0=
},{"../../../module/hammer":19,"../BackgroundGroup":32,"./Item":41,"./RangeItem":43}],40:[function(require,module,exports){
'use strict';

var Item = require('./Item');
var util = require('../../../util');

/**
 * @constructor BoxItem
 * @extends Item
 * @param {Object} data             Object containing parameters start
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe available options
 */
function BoxItem(data, conversion, options) {
  this.props = {
    dot: {
      width: 0,
      height: 0
    },
    line: {
      width: 0,
      height: 0
    }
  };

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data);
    }
  }

  Item.call(this, data, conversion, options);
}

BoxItem.prototype = new Item(null, null, null);

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
BoxItem.prototype.isVisible = function (range) {
  // determine visibility
  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
  var interval = (range.end - range.start) / 4;
  return this.data.start > range.start - interval && this.data.start < range.end + interval;
};

/**
 * Repaint the item
 */
BoxItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // create main box
    dom.box = document.createElement('DIV');

    // contents box (inside the background box). used for making margins
    dom.content = document.createElement('DIV');
    dom.content.className = 'vis-item-content';
    dom.box.appendChild(dom.content);

    // line to axis
    dom.line = document.createElement('DIV');
    dom.line.className = 'vis-line';

    // dot on axis
    dom.dot = document.createElement('DIV');
    dom.dot.className = 'vis-dot';

    // attach this item as attribute
    dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) throw new Error('Cannot redraw item: parent has no foreground container element');
    foreground.appendChild(dom.box);
  }
  if (!dom.line.parentNode) {
    var background = this.parent.dom.background;
    if (!background) throw new Error('Cannot redraw item: parent has no background container element');
    background.appendChild(dom.line);
  }
  if (!dom.dot.parentNode) {
    var axis = this.parent.dom.axis;
    if (!background) throw new Error('Cannot redraw item: parent has no axis container element');
    axis.appendChild(dom.dot);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.box);
    this._updateDataAttributes(this.dom.box);
    this._updateStyle(this.dom.box);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.box.className = 'vis-item vis-box' + className;
    dom.line.className = 'vis-item vis-line' + className;
    dom.dot.className = 'vis-item vis-dot' + className;

    // recalculate size
    this.props.dot.height = dom.dot.offsetHeight;
    this.props.dot.width = dom.dot.offsetWidth;
    this.props.line.width = dom.line.offsetWidth;
    this.width = dom.box.offsetWidth;
    this.height = dom.box.offsetHeight;

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.box);
};

/**
 * Show the item in the DOM (when not already displayed). The items DOM will
 * be created when needed.
 */
BoxItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 */
BoxItem.prototype.hide = function () {
  if (this.displayed) {
    var dom = this.dom;

    if (dom.box.parentNode) dom.box.parentNode.removeChild(dom.box);
    if (dom.line.parentNode) dom.line.parentNode.removeChild(dom.line);
    if (dom.dot.parentNode) dom.dot.parentNode.removeChild(dom.dot);

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @Override
 */
BoxItem.prototype.repositionX = function () {
  var start = this.conversion.toScreen(this.data.start);
  var align = this.options.align;
  var left;

  // calculate left position of the box
  if (align == 'right') {
    this.left = start - this.width;
  } else if (align == 'left') {
    this.left = start;
  } else {
    // default or 'center'
    this.left = start - this.width / 2;
  }

  // reposition box
  this.dom.box.style.left = this.left + 'px';

  // reposition line
  this.dom.line.style.left = start - this.props.line.width / 2 + 'px';

  // reposition dot
  this.dom.dot.style.left = start - this.props.dot.width / 2 + 'px';
};

/**
 * Reposition the item vertically
 * @Override
 */
BoxItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var box = this.dom.box;
  var line = this.dom.line;
  var dot = this.dom.dot;

  if (orientation == 'top') {
    box.style.top = (this.top || 0) + 'px';

    line.style.top = '0';
    line.style.height = this.parent.top + this.top + 1 + 'px';
    line.style.bottom = '';
  } else {
    // orientation 'bottom'
    var itemSetHeight = this.parent.itemSet.props.height; // TODO: this is nasty
    var lineHeight = itemSetHeight - this.parent.top - this.parent.height + this.top;

    box.style.top = (this.parent.height - this.top - this.height || 0) + 'px';
    line.style.top = itemSetHeight - lineHeight + 'px';
    line.style.bottom = '0';
  }

  dot.style.top = -this.props.dot.height / 2 + 'px';
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
BoxItem.prototype.getWidthLeft = function () {
  return this.width / 2;
};

/**
 * Return the width of the item right from its start date
 * @return {number}
 */
BoxItem.prototype.getWidthRight = function () {
  return this.width / 2;
};

module.exports = BoxItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9Cb3hJdGVtLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzdCLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7O0FBWXBDLFNBQVMsT0FBTyxDQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFO0FBQzNDLE1BQUksQ0FBQyxLQUFLLEdBQUc7QUFDWCxPQUFHLEVBQUU7QUFDSCxXQUFLLEVBQUUsQ0FBQztBQUNSLFlBQU0sRUFBRSxDQUFDO0tBQ1Y7QUFDRCxRQUFJLEVBQUU7QUFDSixXQUFLLEVBQUUsQ0FBQztBQUNSLFlBQU0sRUFBRSxDQUFDO0tBQ1Y7R0FDRixDQUFDOzs7QUFHRixNQUFJLElBQUksRUFBRTtBQUNSLFFBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxTQUFTLEVBQUU7QUFDM0IsWUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsR0FBRyxJQUFJLENBQUMsQ0FBQztLQUM3RDtHQUNGOztBQUVELE1BQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7Q0FDNUM7O0FBRUQsT0FBTyxDQUFDLFNBQVMsR0FBRyxJQUFJLElBQUksQ0FBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDOzs7Ozs7O0FBT2hELE9BQU8sQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFVBQVMsS0FBSyxFQUFFOzs7QUFHNUMsTUFBSSxRQUFRLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUEsR0FBSSxDQUFDLENBQUM7QUFDN0MsU0FBTyxBQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUss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QUFHLEdBQUcsQUFBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUksSUFBSSxDQUFDO0NBQ3JELENBQUM7Ozs7OztBQU1GLE9BQU8sQ0FBQyxTQUFTLENBQUMsWUFBWSxHQUFHLFlBQVk7QUFDM0MsU0FBTyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztDQUN2QixDQUFDOzs7Ozs7QUFNRixPQUFPLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxZQUFZO0FBQzVDLFNBQU8sSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7Q0FDdkIsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyIsImZpbGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvY29tcG9uZW50L2l0ZW0vQm94SXRlbS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBJdGVtID0gcmVxdWlyZSgnLi9JdGVtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgQm94SXRlbVxuICogQGV4dGVuZHMgSXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBzdGFydFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCwgY2xhc3NOYW1lLlxuICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBhdmFpbGFibGUgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBCb3hJdGVtIChkYXRhLCBjb252ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHRoaXMucHJvcHMgPSB7XG4gICAgZG90OiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH0sXG4gICAgbGluZToge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9XG4gIH07XG5cbiAgLy8gdmFsaWRhdGUgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcInN0YXJ0XCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhKTtcbiAgICB9XG4gIH1cblxuICBJdGVtLmNhbGwodGhpcywgZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucyk7XG59XG5cbkJveEl0ZW0ucHJvdG90eXBlID0gbmV3IEl0ZW0gKG51bGwsIG51bGwsIG51bGwpO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhpcyBpdGVtIGlzIHZpc2libGUgaW5zaWRlIGdpdmVuIHJhbmdlXG4gKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyfX0gcmFuZ2Ugd2l0aCBhIHRpbWVzdGFtcCBmb3Igc3RhcnQgYW5kIGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICovXG5Cb3hJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbihyYW5nZSkge1xuICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICAvLyBUT0RPOiBhY2NvdW50IGZvciB0aGUgcmVhbCB3aWR0aCBvZiB0aGUgaXRlbS4gUmlnaHQgbm93IHdlIGp1c3QgYWRkIDEvNCB0byB0aGUgd2luZG93XG4gIHZhciBpbnRlcnZhbCA9IChyYW5nZS5lbmQgLSByYW5nZS5zdGFydCkgLyA0O1xuICByZXR1cm4gKHRoaXMuZGF0YS5zdGFydCA+IHJhbmdlLnN0YXJ0IC0gaW50ZXJ2YWwpICYmICh0aGlzLmRhdGEuc3RhcnQgPCByYW5nZS5lbmQgKyBpbnRlcnZhbCk7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAqL1xuQm94SXRlbS5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgaWYgKCFkb20pIHtcbiAgICAvLyBjcmVhdGUgRE9NXG4gICAgdGhpcy5kb20gPSB7fTtcbiAgICBkb20gPSB0aGlzLmRvbTtcblxuICAgIC8vIGNyZWF0ZSBtYWluIGJveFxuICAgIGRvbS5ib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcblxuICAgIC8vIGNvbnRlbnRzIGJveCAoaW5zaWRlIHRoZSBiYWNrZ3JvdW5kIGJveCkuIHVzZWQgZm9yIG1ha2luZyBtYXJnaW5zXG4gICAgZG9tLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICBkb20uY29udGVudC5jbGFzc05hbWUgPSAndmlzLWl0ZW0tY29udGVudCc7XG4gICAgZG9tLmJveC5hcHBlbmRDaGlsZChkb20uY29udGVudCk7XG5cbiAgICAvLyBsaW5lIHRvIGF4aXNcbiAgICBkb20ubGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIGRvbS5saW5lLmNsYXNzTmFtZSA9ICd2aXMtbGluZSc7XG5cbiAgICAvLyBkb3Qgb24gYXhpc1xuICAgIGRvbS5kb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICBkb20uZG90LmNsYXNzTmFtZSA9ICd2aXMtZG90JztcblxuICAgIC8vIGF0dGFjaCB0aGlzIGl0ZW0gYXMgYXR0cmlidXRlXG4gICAgZG9tLmJveFsndGltZWxpbmUtaXRlbSddID0gdGhpcztcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgLy8gYXBwZW5kIERPTSB0byBwYXJlbnQgRE9NXG4gIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogbm8gcGFyZW50IGF0dGFjaGVkJyk7XG4gIH1cbiAgaWYgKCFkb20uYm94LnBhcmVudE5vZGUpIHtcbiAgICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMucGFyZW50LmRvbS5mb3JlZ3JvdW5kO1xuICAgIGlmICghZm9yZWdyb3VuZCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gZm9yZWdyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgIGZvcmVncm91bmQuYXBwZW5kQ2hpbGQoZG9tLmJveCk7XG4gIH1cbiAgaWYgKCFkb20ubGluZS5wYXJlbnROb2RlKSB7XG4gICAgdmFyIGJhY2tncm91bmQgPSB0aGlzLnBhcmVudC5kb20uYmFja2dyb3VuZDtcbiAgICBpZiAoIWJhY2tncm91bmQpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBwYXJlbnQgaGFzIG5vIGJhY2tncm91bmQgY29udGFpbmVyIGVsZW1lbnQnKTtcbiAgICBiYWNrZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5saW5lKTtcbiAgfVxuICBpZiAoIWRvbS5kb3QucGFyZW50Tm9kZSkge1xuICAgIHZhciBheGlzID0gdGhpcy5wYXJlbnQuZG9tLmF4aXM7XG4gICAgaWYgKCFiYWNrZ3JvdW5kKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBheGlzIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgYXhpcy5hcHBlbmRDaGlsZChkb20uZG90KTtcbiAgfVxuICB0aGlzLmRpc3BsYXllZCA9IHRydWU7XG5cbiAgLy8gVXBkYXRlIERPTSB3aGVuIGl0ZW0gaXMgbWFya2VkIGRpcnR5LiBBbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eSB3aGVuOlxuICAvLyAtIHRoZSBpdGVtIGlzIG5vdCB5ZXQgcmVuZGVyZWRcbiAgLy8gLSB0aGUgaXRlbSdzIGRhdGEgaXMgY2hhbmdlZFxuICAvLyAtIHRoZSBpdGVtIGlzIHNlbGVjdGVkL2Rlc2VsZWN0ZWRcbiAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICB0aGlzLl91cGRhdGVDb250ZW50cyh0aGlzLmRvbS5jb250ZW50KTtcbiAgICB0aGlzLl91cGRhdGVUaXRsZSh0aGlzLmRvbS5ib3gpO1xuICAgIHRoaXMuX3VwZGF0ZURhdGFBdHRyaWJ1dGVzKHRoaXMuZG9tLmJveCk7XG4gICAgdGhpcy5fdXBkYXRlU3R5bGUodGhpcy5kb20uYm94KTtcblxuICAgIHZhciBlZGl0YWJsZSA9ICh0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSB8fCBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZUdyb3VwIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdGFibGUgPT09IHRydWUpICYmXG4gICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAvLyB1cGRhdGUgY2xhc3NcbiAgICB2YXIgY2xhc3NOYW1lID0gKHRoaXMuZGF0YS5jbGFzc05hbWU/ICcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUgOiAnJykgK1xuICAgICAgICAodGhpcy5zZWxlY3RlZCA/ICcgdmlzLXNlbGVjdGVkJyA6ICcnKSArIFxuICAgICAgICAoZWRpdGFibGUgPyAnIHZpcy1lZGl0YWJsZScgOiAnIHZpcy1yZWFkb25seScpO1xuICAgIGRvbS5ib3guY2xhc3NOYW1lID0gJ3Zpcy1pdGVtIHZpcy1ib3gnICsgY2xhc3NOYW1lO1xuICAgIGRvbS5saW5lLmNsYXNzTmFtZSA9ICd2aXMtaXRlbSB2aXMtbGluZScgKyBjbGFzc05hbWU7XG4gICAgZG9tLmRvdC5jbGFzc05hbWUgID0gJ3Zpcy1pdGVtIHZpcy1kb3QnICsgY2xhc3NOYW1lO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgc2l6ZVxuICAgIHRoaXMucHJvcHMuZG90LmhlaWdodCA9IGRvbS5kb3Qub2Zmc2V0SGVpZ2h0O1xuICAgIHRoaXMucHJvcHMuZG90LndpZHRoID0gZG9tLmRvdC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLnByb3BzLmxpbmUud2lkdGggPSBkb20ubGluZS5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLndpZHRoID0gZG9tLmJveC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGRvbS5ib3gub2Zmc2V0SGVpZ2h0O1xuXG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy5fcmVwYWludERlbGV0ZUJ1dHRvbihkb20uYm94KTtcbn07XG5cbi8qKlxuICogU2hvdyB0aGUgaXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IGRpc3BsYXllZCkuIFRoZSBpdGVtcyBET00gd2lsbFxuICogYmUgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqL1xuQm94SXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZGlzcGxheWVkKSB7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBpdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICovXG5Cb3hJdGVtLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmRpc3BsYXllZCkge1xuICAgIHZhciBkb20gPSB0aGlzLmRvbTtcblxuICAgIGlmIChkb20uYm94LnBhcmVudE5vZGUpICAgZG9tLmJveC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbS5ib3gpO1xuICAgIGlmIChkb20ubGluZS5wYXJlbnROb2RlKSAgZG9tLmxpbmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20ubGluZSk7XG4gICAgaWYgKGRvbS5kb3QucGFyZW50Tm9kZSkgICBkb20uZG90LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tLmRvdCk7XG5cbiAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gaG9yaXpvbnRhbGx5XG4gKiBAT3ZlcnJpZGVcbiAqL1xuQm94SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5jb252ZXJzaW9uLnRvU2NyZWVuKHRoaXMuZGF0YS5zdGFydCk7XG4gIHZhciBhbGlnbiA9IHRoaXMub3B0aW9ucy5hbGlnbjtcbiAgdmFyIGxlZnQ7XG5cbiAgLy8gY2FsY3VsYXRlIGxlZnQgcG9zaXRpb24gb2YgdGhlIGJveFxuICBpZiAoYWxpZ24gPT0gJ3JpZ2h0Jykge1xuICAgIHRoaXMubGVmdCA9IHN0YXJ0IC0gdGhpcy53aWR0aDtcbiAgfVxuICBlbHNlIGlmIChhbGlnbiA9PSAnbGVmdCcpIHtcbiAgICB0aGlzLmxlZnQgPSBzdGFydDtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBkZWZhdWx0IG9yICdjZW50ZXInXG4gICAgdGhpcy5sZWZ0ID0gc3RhcnQgLSB0aGlzLndpZHRoIC8gMjtcbiAgfVxuXG4gIC8vIHJlcG9zaXRpb24gYm94XG4gIHRoaXMuZG9tLmJveC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgJ3B4JztcblxuICAvLyByZXBvc2l0aW9uIGxpbmVcbiAgdGhpcy5kb20ubGluZS5zdHlsZS5sZWZ0ID0gKHN0YXJ0IC0gdGhpcy5wcm9wcy5saW5lLndpZHRoIC8gMikgKyAncHgnO1xuXG4gIC8vIHJlcG9zaXRpb24gZG90XG4gIHRoaXMuZG9tLmRvdC5zdHlsZS5sZWZ0ID0gKHN0YXJ0IC0gdGhpcy5wcm9wcy5kb3Qud2lkdGggLyAyKSArICdweCc7XG59O1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gdmVydGljYWxseVxuICogQE92ZXJyaWRlXG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtO1xuICB2YXIgYm94ID0gdGhpcy5kb20uYm94O1xuICB2YXIgbGluZSA9IHRoaXMuZG9tLmxpbmU7XG4gIHZhciBkb3QgPSB0aGlzLmRvbS5kb3Q7XG5cbiAgaWYgKG9yaWVudGF0aW9uID09ICd0b3AnKSB7XG4gICAgYm94LnN0eWxlLnRvcCAgICAgPSAodGhpcy50b3AgfHwgMCkgKyAncHgnO1xuXG4gICAgbGluZS5zdHlsZS50b3AgICAgPSAnMCc7XG4gICAgbGluZS5zdHlsZS5oZWlnaHQgPSAodGhpcy5wYXJlbnQudG9wICsgdGhpcy50b3AgKyAxKSArICdweCc7XG4gICAgbGluZS5zdHlsZS5ib3R0b20gPSAnJztcbiAgfVxuICBlbHNlIHsgLy8gb3JpZW50YXRpb24gJ2JvdHRvbSdcbiAgICB2YXIgaXRlbVNldEhlaWdodCA9IHRoaXMucGFyZW50Lml0ZW1TZXQucHJvcHMuaGVpZ2h0OyAvLyBUT0RPOiB0aGlzIGlzIG5hc3R5XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBpdGVtU2V0SGVpZ2h0IC0gdGhpcy5wYXJlbnQudG9wIC0gdGhpcy5wYXJlbnQuaGVpZ2h0ICsgdGhpcy50b3A7XG5cbiAgICBib3guc3R5bGUudG9wICAgICA9ICh0aGlzLnBhcmVudC5oZWlnaHQgLSB0aGlzLnRvcCAtIHRoaXMuaGVpZ2h0IHx8IDApICsgJ3B4JztcbiAgICBsaW5lLnN0eWxlLnRvcCAgICA9IChpdGVtU2V0SGVpZ2h0IC0gbGluZUhlaWdodCkgKyAncHgnO1xuICAgIGxpbmUuc3R5bGUuYm90dG9tID0gJzAnO1xuICB9XG5cbiAgZG90LnN0eWxlLnRvcCA9ICgtdGhpcy5wcm9wcy5kb3QuaGVpZ2h0IC8gMikgKyAncHgnO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBpdGVtIGxlZnQgZnJvbSBpdHMgc3RhcnQgZGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5Cb3hJdGVtLnByb3RvdHlwZS5nZXRXaWR0aExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoIC8gMjtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgaXRlbSByaWdodCBmcm9tIGl0cyBzdGFydCBkYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkJveEl0ZW0ucHJvdG90eXBlLmdldFdpZHRoUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoIC8gMjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQm94SXRlbTtcbiJdfQ==
},{"../../../util":46,"./Item":41}],41:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var util = require('../../../util');

/**
 * @constructor Item
 * @param {Object} data             Object containing (optional) parameters type,
 *                                  start, end, content, group, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} options          Configuration options
 *                                  // TODO: describe available options
 */
function Item(data, conversion, options) {
  this.id = null;
  this.parent = null;
  this.data = data;
  this.dom = null;
  this.conversion = conversion || {};
  this.options = options || {};

  this.selected = false;
  this.displayed = false;
  this.dirty = true;

  this.top = null;
  this.left = null;
  this.width = null;
  this.height = null;

  this.editable = null;
  if (this.data && this.data.hasOwnProperty('editable') && typeof this.data.editable === 'boolean') {
    this.editable = data.editable;
  }
}

Item.prototype.stack = true;

/**
 * Select current item
 */
Item.prototype.select = function () {
  this.selected = true;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Unselect current item
 */
Item.prototype.unselect = function () {
  this.selected = false;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Set data for the item. Existing data will be updated. The id should not
 * be changed. When the item is displayed, it will be redrawn immediately.
 * @param {Object} data
 */
Item.prototype.setData = function (data) {
  var groupChanged = data.group != undefined && this.data.group != data.group;
  if (groupChanged) {
    this.parent.itemSet._moveToGroup(this, data.group);
  }

  if (data.hasOwnProperty('editable') && typeof data.editable === 'boolean') {
    this.editable = data.editable;
  }

  this.data = data;
  this.dirty = true;
  if (this.displayed) this.redraw();
};

/**
 * Set a parent for the item
 * @param {ItemSet | Group} parent
 */
Item.prototype.setParent = function (parent) {
  if (this.displayed) {
    this.hide();
    this.parent = parent;
    if (this.parent) {
      this.show();
    }
  } else {
    this.parent = parent;
  }
};

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
Item.prototype.isVisible = function (range) {
  // Should be implemented by Item implementations
  return false;
};

/**
 * Show the Item in the DOM (when not already visible)
 * @return {Boolean} changed
 */
Item.prototype.show = function () {
  return false;
};

/**
 * Hide the Item from the DOM (when visible)
 * @return {Boolean} changed
 */
Item.prototype.hide = function () {
  return false;
};

/**
 * Repaint the item
 */
Item.prototype.redraw = function () {
  // should be implemented by the item
};

/**
 * Reposition the Item horizontally
 */
Item.prototype.repositionX = function () {
  // should be implemented by the item
};

/**
 * Reposition the Item vertically
 */
Item.prototype.repositionY = function () {
  // should be implemented by the item
};

/**
 * Repaint a delete button on the top right of the item when the item is selected
 * @param {HTMLElement} anchor
 * @protected
 */
Item.prototype._repaintDeleteButton = function (anchor) {
  var editable = (this.options.editable.remove || this.data.editable === true) && this.data.editable !== false;

  if (this.selected && editable && !this.dom.deleteButton) {
    // create and show button
    var me = this;

    var deleteButton = document.createElement('div');
    deleteButton.className = 'vis-delete';
    deleteButton.title = 'Delete this item';

    // TODO: be able to destroy the delete button
    new Hammer(deleteButton).on('tap', function (event) {
      event.stopPropagation();
      me.parent.removeFromDataSet(me);
    });

    anchor.appendChild(deleteButton);
    this.dom.deleteButton = deleteButton;
  } else if (!this.selected && this.dom.deleteButton) {
    // remove button
    if (this.dom.deleteButton.parentNode) {
      this.dom.deleteButton.parentNode.removeChild(this.dom.deleteButton);
    }
    this.dom.deleteButton = null;
  }
};

/**
 * Set HTML contents for the item
 * @param {Element} element   HTML element to fill with the contents
 * @private
 */
Item.prototype._updateContents = function (element) {
  var content;
  if (this.options.template) {
    var itemData = this.parent.itemSet.itemsData.get(this.id); // get a clone of the data from the dataset
    content = this.options.template(itemData);
  } else {
    content = this.data.content;
  }

  var changed = this._contentToString(this.content) !== this._contentToString(content);
  if (changed) {
    // only replace the content when changed
    if (content instanceof Element) {
      element.innerHTML = '';
      element.appendChild(content);
    } else if (content != undefined) {
      element.innerHTML = content;
    } else {
      if (!(this.data.type == 'background' && this.data.content === undefined)) {
        throw new Error('Property "content" missing in item ' + this.id);
      }
    }

    this.content = content;
  }
};

/**
 * Set HTML contents for the item
 * @param {Element} element   HTML element to fill with the contents
 * @private
 */
Item.prototype._updateTitle = function (element) {
  if (this.data.title != null) {
    element.title = this.data.title || '';
  } else {
    element.removeAttribute('vis-title');
  }
};

/**
 * Process dataAttributes timeline option and set as data- attributes on dom.content
 * @param {Element} element   HTML element to which the attributes will be attached
 * @private
 */
Item.prototype._updateDataAttributes = function (element) {
  if (this.options.dataAttributes && this.options.dataAttributes.length > 0) {
    var attributes = [];

    if (Array.isArray(this.options.dataAttributes)) {
      attributes = this.options.dataAttributes;
    } else if (this.options.dataAttributes == 'all') {
      attributes = Object.keys(this.data);
    } else {
      return;
    }

    for (var i = 0; i < attributes.length; i++) {
      var name = attributes[i];
      var value = this.data[name];

      if (value != null) {
        element.setAttribute('data-' + name, value);
      } else {
        element.removeAttribute('data-' + name);
      }
    }
  }
};

/**
 * Update custom styles of the element
 * @param element
 * @private
 */
Item.prototype._updateStyle = function (element) {
  // remove old styles
  if (this.style) {
    util.removeCssText(element, this.style);
    this.style = null;
  }

  // append new styles
  if (this.data.style) {
    util.addCssText(element, this.data.style);
    this.style = this.data.style;
  }
};

/**
 * Stringify the items contents
 * @param {string | Element | undefined} content
 * @returns {string | undefined}
 * @private
 */
Item.prototype._contentToString = function (content) {
  if (typeof content === 'string') return content;
  if (content && 'outerHTML' in content) return content.outerHTML;
  return content;
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
Item.prototype.getWidthLeft = function () {
  return 0;
};

/**
 * Return the width of the item right from the max of its start and end date
 * @return {number}
 */
Item.prototype.getWidthRight = function () {
  return 0;
};

module.exports = Item;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9JdGVtLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDLENBQUM7QUFDL0MsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDOzs7Ozs7Ozs7OztBQVdwQyxTQUFTLElBQUksQ0FBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRTtBQUN4QyxNQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQztBQUNmLE1BQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ25CLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLE1BQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQ2hCLE1BQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxJQUFJLEVBQUUsQ0FBQztBQUNuQyxNQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sSUFBSSxFQUFFLENBQUM7O0FBRTdCLE1BQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO0FBQ3RCLE1BQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO0FBQ3ZCLE1BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDOztBQUVsQixNQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztBQUNoQixNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNqQixNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztBQUNsQixNQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQzs7QUFFbkIsTUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7QUFDckIsTUFBSSxJQUFJLENBQUMsSUFBSSxJQUNULElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxJQUNwQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMs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QUMiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL0l0ZW0uanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEl0ZW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgIE9iamVjdCBjb250YWluaW5nIChvcHRpb25hbCkgcGFyYW1ldGVycyB0eXBlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQsIGVuZCwgY29udGVudCwgZ3JvdXAsIGNsYXNzTmFtZS5cbiAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgYXZhaWxhYmxlIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gSXRlbSAoZGF0YSwgY29udmVyc2lvbiwgb3B0aW9ucykge1xuICB0aGlzLmlkID0gbnVsbDtcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmRvbSA9IG51bGw7XG4gIHRoaXMuY29udmVyc2lvbiA9IGNvbnZlcnNpb24gfHwge307XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICB0aGlzLnRvcCA9IG51bGw7XG4gIHRoaXMubGVmdCA9IG51bGw7XG4gIHRoaXMud2lkdGggPSBudWxsO1xuICB0aGlzLmhlaWdodCA9IG51bGw7XG5cbiAgdGhpcy5lZGl0YWJsZSA9IG51bGw7XG4gIGlmICh0aGlzLmRhdGEgJiYgXG4gICAgICB0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkoJ2VkaXRhYmxlJykgJiYgXG4gICAgICB0eXBlb2YgdGhpcy5kYXRhLmVkaXRhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICB0aGlzLmVkaXRhYmxlID0gZGF0YS5lZGl0YWJsZTtcbiAgfVxufVxuXG5JdGVtLnByb3RvdHlwZS5zdGFjayA9IHRydWU7XG5cbi8qKlxuICogU2VsZWN0IGN1cnJlbnQgaXRlbVxuICovXG5JdGVtLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0cnVlO1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHRoaXMucmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIFVuc2VsZWN0IGN1cnJlbnQgaXRlbVxuICovXG5JdGVtLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlydHkgPSB0cnVlO1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHRoaXMucmVkcmF3KCk7XG59O1xuXG4vKipcbiAqIFNldCBkYXRhIGZvciB0aGUgaXRlbS4gRXhpc3RpbmcgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIFRoZSBpZCBzaG91bGQgbm90XG4gKiBiZSBjaGFuZ2VkLiBXaGVuIHRoZSBpdGVtIGlzIGRpc3BsYXllZCwgaXQgd2lsbCBiZSByZWRyYXduIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIGdyb3VwQ2hhbmdlZCA9IGRhdGEuZ3JvdXAgIT0gdW5kZWZpbmVkICYmIHRoaXMuZGF0YS5ncm91cCAhPSBkYXRhLmdyb3VwO1xuICBpZiAoZ3JvdXBDaGFuZ2VkKSB7XG4gICAgdGhpcy5wYXJlbnQuaXRlbVNldC5fbW92ZVRvR3JvdXAodGhpcywgZGF0YS5ncm91cCk7XG4gIH1cblxuICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUnKSAmJiB0eXBlb2YgZGF0YS5lZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhpcy5lZGl0YWJsZSA9IGRhdGEuZWRpdGFibGU7XG4gIH1cblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgaWYgKHRoaXMuZGlzcGxheWVkKSB0aGlzLnJlZHJhdygpO1xufTtcblxuLyoqXG4gKiBTZXQgYSBwYXJlbnQgZm9yIHRoZSBpdGVtXG4gKiBAcGFyYW0ge0l0ZW1TZXQgfCBHcm91cH0gcGFyZW50XG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uKHBhcmVudCkge1xuICBpZiAodGhpcy5kaXNwbGF5ZWQpIHtcbiAgICB0aGlzLmhpZGUoKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAqL1xuSXRlbS5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IEl0ZW0gaW1wbGVtZW50YXRpb25zXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2hvdyB0aGUgSXRlbSBpbiB0aGUgRE9NICh3aGVuIG5vdCBhbHJlYWR5IHZpc2libGUpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBjaGFuZ2VkXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBJdGVtIGZyb20gdGhlIERPTSAod2hlbiB2aXNpYmxlKVxuICogQHJldHVybiB7Qm9vbGVhbn0gY2hhbmdlZFxuICovXG5JdGVtLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgaXRlbVxuICovXG5JdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBpdGVtXG59O1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIEl0ZW0gaG9yaXpvbnRhbGx5XG4gKi9cbkl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24oKSB7XG4gIC8vIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgaXRlbVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBJdGVtIHZlcnRpY2FsbHlcbiAqL1xuSXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBpdGVtXG59O1xuXG4vKipcbiAqIFJlcGFpbnQgYSBkZWxldGUgYnV0dG9uIG9uIHRoZSB0b3AgcmlnaHQgb2YgdGhlIGl0ZW0gd2hlbiB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYW5jaG9yXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkl0ZW0ucHJvdG90eXBlLl9yZXBhaW50RGVsZXRlQnV0dG9uID0gZnVuY3Rpb24gKGFuY2hvcikge1xuICB2YXIgZWRpdGFibGUgPSAodGhpcy5vcHRpb25zLmVkaXRhYmxlLnJlbW92ZSB8fCBcbiAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5lZGl0YWJsZSA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmVkaXRhYmxlICE9PSBmYWxzZTtcblxuICBpZiAodGhpcy5zZWxlY3RlZCAmJiBlZGl0YWJsZSAmJiAhdGhpcy5kb20uZGVsZXRlQnV0dG9uKSB7XG4gICAgLy8gY3JlYXRlIGFuZCBzaG93IGJ1dHRvblxuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICB2YXIgZGVsZXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVsZXRlQnV0dG9uLmNsYXNzTmFtZSA9ICd2aXMtZGVsZXRlJztcbiAgICBkZWxldGVCdXR0b24udGl0bGUgPSAnRGVsZXRlIHRoaXMgaXRlbSc7XG5cbiAgICAvLyBUT0RPOiBiZSBhYmxlIHRvIGRlc3Ryb3kgdGhlIGRlbGV0ZSBidXR0b25cbiAgICBuZXcgSGFtbWVyKGRlbGV0ZUJ1dHRvbikub24oJ3RhcCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBtZS5wYXJlbnQucmVtb3ZlRnJvbURhdGFTZXQobWUpO1xuICAgIH0pO1xuXG4gICAgYW5jaG9yLmFwcGVuZENoaWxkKGRlbGV0ZUJ1dHRvbik7XG4gICAgdGhpcy5kb20uZGVsZXRlQnV0dG9uID0gZGVsZXRlQnV0dG9uO1xuICB9XG4gIGVsc2UgaWYgKCF0aGlzLnNlbGVjdGVkICYmIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbikge1xuICAgIC8vIHJlbW92ZSBidXR0b25cbiAgICBpZiAodGhpcy5kb20uZGVsZXRlQnV0dG9uLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbik7XG4gICAgfVxuICAgIHRoaXMuZG9tLmRlbGV0ZUJ1dHRvbiA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IEhUTUwgY29udGVudHMgZm9yIHRoZSBpdGVtXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgICBIVE1MIGVsZW1lbnQgdG8gZmlsbCB3aXRoIHRoZSBjb250ZW50c1xuICogQHByaXZhdGVcbiAqL1xuSXRlbS5wcm90b3R5cGUuX3VwZGF0ZUNvbnRlbnRzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGNvbnRlbnQ7XG4gIGlmICh0aGlzLm9wdGlvbnMudGVtcGxhdGUpIHtcbiAgICB2YXIgaXRlbURhdGEgPSB0aGlzLnBhcmVudC5pdGVtU2V0Lml0ZW1zRGF0YS5nZXQodGhpcy5pZCk7IC8vIGdldCBhIGNsb25lIG9mIHRoZSBkYXRhIGZyb20gdGhlIGRhdGFzZXRcbiAgICBjb250ZW50ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlKGl0ZW1EYXRhKTtcbiAgfVxuICBlbHNlIHtcbiAgICBjb250ZW50ID0gdGhpcy5kYXRhLmNvbnRlbnQ7XG4gIH1cblxuICB2YXIgY2hhbmdlZCA9IHRoaXMuX2NvbnRlbnRUb1N0cmluZyh0aGlzLmNvbnRlbnQpICE9PSB0aGlzLl9jb250ZW50VG9TdHJpbmcoY29udGVudCk7XG4gIGlmIChjaGFuZ2VkKSB7XG4gICAgLy8gb25seSByZXBsYWNlIHRoZSBjb250ZW50IHdoZW4gY2hhbmdlZFxuICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRlbnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKCEodGhpcy5kYXRhLnR5cGUgPT0gJ2JhY2tncm91bmQnICYmIHRoaXMuZGF0YS5jb250ZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJjb250ZW50XCIgbWlzc2luZyBpbiBpdGVtICcgKyB0aGlzLmlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBIVE1MIGNvbnRlbnRzIGZvciB0aGUgaXRlbVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgSFRNTCBlbGVtZW50IHRvIGZpbGwgd2l0aCB0aGUgY29udGVudHNcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW0ucHJvdG90eXBlLl91cGRhdGVUaXRsZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIGlmICh0aGlzLmRhdGEudGl0bGUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQudGl0bGUgPSB0aGlzLmRhdGEudGl0bGUgfHwgJyc7XG4gIH1cbiAgZWxzZSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3Zpcy10aXRsZScpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgZGF0YUF0dHJpYnV0ZXMgdGltZWxpbmUgb3B0aW9uIGFuZCBzZXQgYXMgZGF0YS0gYXR0cmlidXRlcyBvbiBkb20uY29udGVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICAgSFRNTCBlbGVtZW50IHRvIHdoaWNoIHRoZSBhdHRyaWJ1dGVzIHdpbGwgYmUgYXR0YWNoZWRcbiAqIEBwcml2YXRlXG4gKi9cbiBJdGVtLnByb3RvdHlwZS5fdXBkYXRlRGF0YUF0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZGF0YUF0dHJpYnV0ZXMgJiYgdGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzKSkge1xuICAgICAgYXR0cmlidXRlcyA9IHRoaXMub3B0aW9ucy5kYXRhQXR0cmlidXRlcztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmRhdGFBdHRyaWJ1dGVzID09ICdhbGwnKSB7XG4gICAgICBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXModGhpcy5kYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmRhdGFbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLScgKyBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtJyArIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgY3VzdG9tIHN0eWxlcyBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIGVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbkl0ZW0ucHJvdG90eXBlLl91cGRhdGVTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgLy8gcmVtb3ZlIG9sZCBzdHlsZXNcbiAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICB1dGlsLnJlbW92ZUNzc1RleHQoZWxlbWVudCwgdGhpcy5zdHlsZSk7XG4gICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gIH1cblxuICAvLyBhcHBlbmQgbmV3IHN0eWxlc1xuICBpZiAodGhpcy5kYXRhLnN0eWxlKSB7XG4gICAgdXRpbC5hZGRDc3NUZXh0KGVsZW1lbnQsIHRoaXMuZGF0YS5zdHlsZSk7XG4gICAgdGhpcy5zdHlsZSA9IHRoaXMuZGF0YS5zdHlsZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGl0ZW1zIGNvbnRlbnRzXG4gKiBAcGFyYW0ge3N0cmluZyB8IEVsZW1lbnQgfCB1bmRlZmluZWR9IGNvbnRlbnRcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5JdGVtLnByb3RvdHlwZS5fY29udGVudFRvU3RyaW5nID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIGNvbnRlbnQ7XG4gIGlmIChjb250ZW50ICYmICdvdXRlckhUTUwnIGluIGNvbnRlbnQpIHJldHVybiBjb250ZW50Lm91dGVySFRNTDtcbiAgcmV0dXJuIGNvbnRlbnQ7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gbGVmdCBmcm9tIGl0cyBzdGFydCBkYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldFdpZHRoTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gcmlnaHQgZnJvbSB0aGUgbWF4IG9mIGl0cyBzdGFydCBhbmQgZW5kIGRhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZW07XG4iXX0=
},{"../../../module/hammer":19,"../../../util":46}],42:[function(require,module,exports){
'use strict';

var Item = require('./Item');

/**
 * @constructor PointItem
 * @extends Item
 * @param {Object} data             Object containing parameters start
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe available options
 */
function PointItem(data, conversion, options) {
  this.props = {
    dot: {
      top: 0,
      width: 0,
      height: 0
    },
    content: {
      height: 0,
      marginLeft: 0
    }
  };

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data);
    }
  }

  Item.call(this, data, conversion, options);
}

PointItem.prototype = new Item(null, null, null);

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
PointItem.prototype.isVisible = function (range) {
  // determine visibility
  // TODO: account for the real width of the item. Right now we just add 1/4 to the window
  var interval = (range.end - range.start) / 4;
  return this.data.start > range.start - interval && this.data.start < range.end + interval;
};

/**
 * Repaint the item
 */
PointItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.point = document.createElement('div');
    // className is updated in redraw()

    // contents box, right from the dot
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.point.appendChild(dom.content);

    // dot at start
    dom.dot = document.createElement('div');
    dom.point.appendChild(dom.dot);

    // attach this item as attribute
    dom.point['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.point.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) {
      throw new Error('Cannot redraw item: parent has no foreground container element');
    }
    foreground.appendChild(dom.point);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.point);
    this._updateDataAttributes(this.dom.point);
    this._updateStyle(this.dom.point);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.point.className = 'vis-item vis-point' + className;
    dom.dot.className = 'vis-item vis-dot' + className;

    // recalculate size of dot and contents
    this.props.dot.width = dom.dot.offsetWidth;
    this.props.dot.height = dom.dot.offsetHeight;
    this.props.content.height = dom.content.offsetHeight;

    // resize contents
    dom.content.style.marginLeft = 2 * this.props.dot.width + 'px';
    //dom.content.style.marginRight = ... + 'px'; // TODO: margin right

    // recalculate size
    this.width = dom.point.offsetWidth;
    this.height = dom.point.offsetHeight;

    // reposition the dot
    dom.dot.style.top = (this.height - this.props.dot.height) / 2 + 'px';
    dom.dot.style.left = this.props.dot.width / 2 + 'px';

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.point);
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
PointItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 */
PointItem.prototype.hide = function () {
  if (this.displayed) {
    if (this.dom.point.parentNode) {
      this.dom.point.parentNode.removeChild(this.dom.point);
    }

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @Override
 */
PointItem.prototype.repositionX = function () {
  var start = this.conversion.toScreen(this.data.start);

  this.left = start - this.props.dot.width;

  // reposition point
  this.dom.point.style.left = this.left + 'px';
};

/**
 * Reposition the item vertically
 * @Override
 */
PointItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var point = this.dom.point;

  if (orientation == 'top') {
    point.style.top = this.top + 'px';
  } else {
    point.style.top = this.parent.height - this.top - this.height + 'px';
  }
};

/**
 * Return the width of the item left from its start date
 * @return {number}
 */
PointItem.prototype.getWidthLeft = function () {
  return this.props.dot.width;
};

/**
 * Return the width of the item right from  its start date
 * @return {number}
 */
PointItem.prototype.getWidthRight = function () {
  return this.width - this.props.dot.width;
};

module.exports = PointItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9Qb2ludEl0ZW0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7Ozs7Ozs7Ozs7OztBQVk3QixTQUFTLFNBQVMsQ0FBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRTtBQUM3QyxNQUFJLENBQUMsS0FBSyxHQUFHO0FBQ1gsT0FBRyxFQUFFO0FBQ0gsU0FBRyxFQUFFLENBQUM7QUFDTixXQUFLLEVBQUUsQ0FBQztBQUNSLFlBQU0sRUFBRSxDQUFDO0tBQ1Y7QUFDRCxXQUFPLEVBQUU7QUFDUCxZQUFNLEVBQUUsQ0FBQztBQUNULGdCQUFVLEVBQUUsQ0FBQztLQUNkO0dBQ0YsQ0FBQzs7O0FBR0YsTUFBSSxJQUFJLEVBQUU7QUFDUixRQUFJLElBQUksQ0FBQyxLQUFLLElBQUksU0FBUyxFQUFFO0FBQzNCLFlBQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLEdBQUcsSUFBSSxDQUFDLENBQUM7S0FDN0Q7R0FDRjs7QUFFRCxNQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQzVDOztBQUVELFNBQVMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxJQUFJLENBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzs7Ozs7OztBQU9sRCxTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFTLEtBQUssRUFBRTs7O0FBRzlDLE1BQUksUUFBUSxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFBLEdBQUksQ0FBQyxDQUFDO0FBQzdDLFNBQU8sQUFBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxHQUFHLFFBQVEsSUFB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SSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7R0FDbkMsTUFDSTtBQUNILFNBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEFBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFJLElBQUksQ0FBQztHQUN4RTtDQUNGLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsWUFBWSxHQUFHLFlBQVk7QUFDN0MsU0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7Q0FDN0IsQ0FBQzs7Ozs7O0FBTUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsWUFBWTtBQUM5QyxTQUFPLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO0NBQzFDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL2NvbXBvbmVudC9pdGVtL1BvaW50SXRlbS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBJdGVtID0gcmVxdWlyZSgnLi9JdGVtJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIFBvaW50SXRlbVxuICogQGV4dGVuZHMgSXRlbVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgICAgICAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBzdGFydFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCwgY2xhc3NOYW1lLlxuICogQHBhcmFtIHt7dG9TY3JlZW46IGZ1bmN0aW9uLCB0b1RpbWU6IGZ1bmN0aW9ufX0gY29udmVyc2lvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udmVyc2lvbiBmdW5jdGlvbnMgZnJvbSB0aW1lIHRvIHNjcmVlbiBhbmQgdmljZSB2ZXJzYVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXNjcmliZSBhdmFpbGFibGUgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBQb2ludEl0ZW0gKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdGhpcy5wcm9wcyA9IHtcbiAgICBkb3Q6IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfSxcbiAgICBjb250ZW50OiB7XG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBtYXJnaW5MZWZ0OiAwXG4gICAgfVxuICB9O1xuXG4gIC8vIHZhbGlkYXRlIGRhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5zdGFydCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJzdGFydFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgSXRlbS5jYWxsKHRoaXMsIGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpO1xufVxuXG5Qb2ludEl0ZW0ucHJvdG90eXBlID0gbmV3IEl0ZW0gKG51bGwsIG51bGwsIG51bGwpO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhpcyBpdGVtIGlzIHZpc2libGUgaW5zaWRlIGdpdmVuIHJhbmdlXG4gKiBAcmV0dXJucyB7e3N0YXJ0OiBOdW1iZXIsIGVuZDogTnVtYmVyfX0gcmFuZ2Ugd2l0aCBhIHRpbWVzdGFtcCBmb3Igc3RhcnQgYW5kIGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmlzaWJsZVxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIC8vIGRldGVybWluZSB2aXNpYmlsaXR5XG4gIC8vIFRPRE86IGFjY291bnQgZm9yIHRoZSByZWFsIHdpZHRoIG9mIHRoZSBpdGVtLiBSaWdodCBub3cgd2UganVzdCBhZGQgMS80IHRvIHRoZSB3aW5kb3dcbiAgdmFyIGludGVydmFsID0gKHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0KSAvIDQ7XG4gIHJldHVybiAodGhpcy5kYXRhLnN0YXJ0ID4gcmFuZ2Uuc3RhcnQgLSBpbnRlcnZhbCkgJiYgKHRoaXMuZGF0YS5zdGFydCA8IHJhbmdlLmVuZCArIGludGVydmFsKTtcbn07XG5cbi8qKlxuICogUmVwYWludCB0aGUgaXRlbVxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZG9tID0gdGhpcy5kb207XG4gIGlmICghZG9tKSB7XG4gICAgLy8gY3JlYXRlIERPTVxuICAgIHRoaXMuZG9tID0ge307XG4gICAgZG9tID0gdGhpcy5kb207XG5cbiAgICAvLyBiYWNrZ3JvdW5kIGJveFxuICAgIGRvbS5wb2ludCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vIGNsYXNzTmFtZSBpcyB1cGRhdGVkIGluIHJlZHJhdygpXG5cbiAgICAvLyBjb250ZW50cyBib3gsIHJpZ2h0IGZyb20gdGhlIGRvdFxuICAgIGRvbS5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLWNvbnRlbnQnO1xuICAgIGRvbS5wb2ludC5hcHBlbmRDaGlsZChkb20uY29udGVudCk7XG5cbiAgICAvLyBkb3QgYXQgc3RhcnRcbiAgICBkb20uZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLnBvaW50LmFwcGVuZENoaWxkKGRvbS5kb3QpO1xuXG4gICAgLy8gYXR0YWNoIHRoaXMgaXRlbSBhcyBhdHRyaWJ1dGVcbiAgICBkb20ucG9pbnRbJ3RpbWVsaW5lLWl0ZW0nXSA9IHRoaXM7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGFwcGVuZCBET00gdG8gcGFyZW50IERPTVxuICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IG5vIHBhcmVudCBhdHRhY2hlZCcpO1xuICB9XG4gIGlmICghZG9tLnBvaW50LnBhcmVudE5vZGUpIHtcbiAgICB2YXIgZm9yZWdyb3VuZCA9IHRoaXMucGFyZW50LmRvbS5mb3JlZ3JvdW5kO1xuICAgIGlmICghZm9yZWdyb3VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVkcmF3IGl0ZW06IHBhcmVudCBoYXMgbm8gZm9yZWdyb3VuZCBjb250YWluZXIgZWxlbWVudCcpO1xuICAgIH1cbiAgICBmb3JlZ3JvdW5kLmFwcGVuZENoaWxkKGRvbS5wb2ludCk7XG4gIH1cbiAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gIC8vIFVwZGF0ZSBET00gd2hlbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eS4gQW4gaXRlbSBpcyBtYXJrZWQgZGlydHkgd2hlbjpcbiAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgLy8gLSB0aGUgaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgdGhpcy5fdXBkYXRlVGl0bGUodGhpcy5kb20ucG9pbnQpO1xuICAgIHRoaXMuX3VwZGF0ZURhdGFBdHRyaWJ1dGVzKHRoaXMuZG9tLnBvaW50KTtcbiAgICB0aGlzLl91cGRhdGVTdHlsZSh0aGlzLmRvbS5wb2ludCk7XG5cbiAgICB2YXIgZWRpdGFibGUgPSAodGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgfHwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRhYmxlID09PSB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdGFibGUgIT09IGZhbHNlO1xuXG4gICAgLy8gdXBkYXRlIGNsYXNzXG4gICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lID8gJyAnICsgdGhpcy5kYXRhLmNsYXNzTmFtZSA6ICcnKSArXG4gICAgICAgICh0aGlzLnNlbGVjdGVkID8gJyB2aXMtc2VsZWN0ZWQnIDogJycpICtcbiAgICAgICAgKGVkaXRhYmxlID8gJyB2aXMtZWRpdGFibGUnIDogJyB2aXMtcmVhZG9ubHknKTtcbiAgICBkb20ucG9pbnQuY2xhc3NOYW1lICA9ICd2aXMtaXRlbSB2aXMtcG9pbnQnICsgY2xhc3NOYW1lO1xuICAgIGRvbS5kb3QuY2xhc3NOYW1lICA9ICd2aXMtaXRlbSB2aXMtZG90JyArIGNsYXNzTmFtZTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIHNpemUgb2YgZG90IGFuZCBjb250ZW50c1xuICAgIHRoaXMucHJvcHMuZG90LndpZHRoID0gZG9tLmRvdC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLnByb3BzLmRvdC5oZWlnaHQgPSBkb20uZG90Lm9mZnNldEhlaWdodDtcbiAgICB0aGlzLnByb3BzLmNvbnRlbnQuaGVpZ2h0ID0gZG9tLmNvbnRlbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgLy8gcmVzaXplIGNvbnRlbnRzXG4gICAgZG9tLmNvbnRlbnQuc3R5bGUubWFyZ2luTGVmdCA9IDIgKiB0aGlzLnByb3BzLmRvdC53aWR0aCArICdweCc7XG4gICAgLy9kb20uY29udGVudC5zdHlsZS5tYXJnaW5SaWdodCA9IC4uLiArICdweCc7IC8vIFRPRE86IG1hcmdpbiByaWdodFxuXG4gICAgLy8gcmVjYWxjdWxhdGUgc2l6ZVxuICAgIHRoaXMud2lkdGggPSBkb20ucG9pbnQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBkb20ucG9pbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgLy8gcmVwb3NpdGlvbiB0aGUgZG90XG4gICAgZG9tLmRvdC5zdHlsZS50b3AgPSAoKHRoaXMuaGVpZ2h0IC0gdGhpcy5wcm9wcy5kb3QuaGVpZ2h0KSAvIDIpICsgJ3B4JztcbiAgICBkb20uZG90LnN0eWxlLmxlZnQgPSAodGhpcy5wcm9wcy5kb3Qud2lkdGggLyAyKSArICdweCc7XG5cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH1cblxuICB0aGlzLl9yZXBhaW50RGVsZXRlQnV0dG9uKGRvbS5wb2ludCk7XG59O1xuXG4vKipcbiAqIFNob3cgdGhlIGl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKS4gVGhlIGl0ZW1zIERPTSB3aWxsXG4gKiBiZSBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICovXG5Qb2ludEl0ZW0ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRpc3BsYXllZCkge1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH1cbn07XG5cbi8qKlxuICogSGlkZSB0aGUgaXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAqL1xuUG9pbnRJdGVtLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmRpc3BsYXllZCkge1xuICAgIGlmICh0aGlzLmRvbS5wb2ludC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmRvbS5wb2ludC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tLnBvaW50KTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gaG9yaXpvbnRhbGx5XG4gKiBAT3ZlcnJpZGVcbiAqL1xuUG9pbnRJdGVtLnByb3RvdHlwZS5yZXBvc2l0aW9uWCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLmNvbnZlcnNpb24udG9TY3JlZW4odGhpcy5kYXRhLnN0YXJ0KTtcblxuICB0aGlzLmxlZnQgPSBzdGFydCAtIHRoaXMucHJvcHMuZG90LndpZHRoO1xuXG4gIC8vIHJlcG9zaXRpb24gcG9pbnRcbiAgdGhpcy5kb20ucG9pbnQuc3R5bGUubGVmdCA9IHRoaXMubGVmdCArICdweCc7XG59O1xuXG4vKipcbiAqIFJlcG9zaXRpb24gdGhlIGl0ZW0gdmVydGljYWxseVxuICogQE92ZXJyaWRlXG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUucmVwb3NpdGlvblkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uLml0ZW07XG4gIHZhciBwb2ludCA9IHRoaXMuZG9tLnBvaW50O1xuXG4gIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgIHBvaW50LnN0eWxlLnRvcCA9IHRoaXMudG9wICsgJ3B4JztcbiAgfVxuICBlbHNlIHtcbiAgICBwb2ludC5zdHlsZS50b3AgPSAodGhpcy5wYXJlbnQuaGVpZ2h0IC0gdGhpcy50b3AgLSB0aGlzLmhlaWdodCkgKyAncHgnO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gbGVmdCBmcm9tIGl0cyBzdGFydCBkYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblBvaW50SXRlbS5wcm90b3R5cGUuZ2V0V2lkdGhMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wcm9wcy5kb3Qud2lkdGg7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIGl0ZW0gcmlnaHQgZnJvbSAgaXRzIHN0YXJ0IGRhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuUG9pbnRJdGVtLnByb3RvdHlwZS5nZXRXaWR0aFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aCAtIHRoaXMucHJvcHMuZG90LndpZHRoO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludEl0ZW07XG4iXX0=
},{"./Item":41}],43:[function(require,module,exports){
'use strict';

var Hammer = require('../../../module/hammer');
var Item = require('./Item');

/**
 * @constructor RangeItem
 * @extends Item
 * @param {Object} data             Object containing parameters start, end
 *                                  content, className.
 * @param {{toScreen: function, toTime: function}} conversion
 *                                  Conversion functions from time to screen and vice versa
 * @param {Object} [options]        Configuration options
 *                                  // TODO: describe options
 */
function RangeItem(data, conversion, options) {
  this.props = {
    content: {
      width: 0
    }
  };
  this.overflow = false; // if contents can overflow (css styling), this flag is set to true

  // validate data
  if (data) {
    if (data.start == undefined) {
      throw new Error('Property "start" missing in item ' + data.id);
    }
    if (data.end == undefined) {
      throw new Error('Property "end" missing in item ' + data.id);
    }
  }

  Item.call(this, data, conversion, options);
}

RangeItem.prototype = new Item(null, null, null);

RangeItem.prototype.baseClassName = 'vis-item vis-range';

/**
 * Check whether this item is visible inside given range
 * @returns {{start: Number, end: Number}} range with a timestamp for start and end
 * @returns {boolean} True if visible
 */
RangeItem.prototype.isVisible = function (range) {
  // determine visibility
  return this.data.start < range.end && this.data.end > range.start;
};

/**
 * Repaint the item
 */
RangeItem.prototype.redraw = function () {
  var dom = this.dom;
  if (!dom) {
    // create DOM
    this.dom = {};
    dom = this.dom;

    // background box
    dom.box = document.createElement('div');
    // className is updated in redraw()

    // frame box (to prevent the item contents from overflowing
    dom.frame = document.createElement('div');
    dom.frame.className = 'vis-item-overflow';
    dom.box.appendChild(dom.frame);

    // contents box
    dom.content = document.createElement('div');
    dom.content.className = 'vis-item-content';
    dom.frame.appendChild(dom.content);

    // attach this item as attribute
    dom.box['timeline-item'] = this;

    this.dirty = true;
  }

  // append DOM to parent DOM
  if (!this.parent) {
    throw new Error('Cannot redraw item: no parent attached');
  }
  if (!dom.box.parentNode) {
    var foreground = this.parent.dom.foreground;
    if (!foreground) {
      throw new Error('Cannot redraw item: parent has no foreground container element');
    }
    foreground.appendChild(dom.box);
  }
  this.displayed = true;

  // Update DOM when item is marked dirty. An item is marked dirty when:
  // - the item is not yet rendered
  // - the item's data is changed
  // - the item is selected/deselected
  if (this.dirty) {
    this._updateContents(this.dom.content);
    this._updateTitle(this.dom.box);
    this._updateDataAttributes(this.dom.box);
    this._updateStyle(this.dom.box);

    var editable = (this.options.editable.updateTime || this.options.editable.updateGroup || this.editable === true) && this.editable !== false;

    // update class
    var className = (this.data.className ? ' ' + this.data.className : '') + (this.selected ? ' vis-selected' : '') + (editable ? ' vis-editable' : ' vis-readonly');
    dom.box.className = this.baseClassName + className;

    // determine from css whether this box has overflow
    this.overflow = window.getComputedStyle(dom.frame).overflow !== 'hidden';

    // recalculate size
    // turn off max-width to be able to calculate the real width
    // this causes an extra browser repaint/reflow, but so be it
    this.dom.content.style.maxWidth = 'none';
    this.props.content.width = this.dom.content.offsetWidth;
    this.height = this.dom.box.offsetHeight;
    this.dom.content.style.maxWidth = '';

    this.dirty = false;
  }

  this._repaintDeleteButton(dom.box);
  this._repaintDragLeft();
  this._repaintDragRight();
};

/**
 * Show the item in the DOM (when not already visible). The items DOM will
 * be created when needed.
 */
RangeItem.prototype.show = function () {
  if (!this.displayed) {
    this.redraw();
  }
};

/**
 * Hide the item from the DOM (when visible)
 * @return {Boolean} changed
 */
RangeItem.prototype.hide = function () {
  if (this.displayed) {
    var box = this.dom.box;

    if (box.parentNode) {
      box.parentNode.removeChild(box);
    }

    this.displayed = false;
  }
};

/**
 * Reposition the item horizontally
 * @param {boolean} [limitSize=true] If true (default), the width of the range
 *                                   item will be limited, as the browser cannot
 *                                   display very wide divs. This means though
 *                                   that the applied left and width may
 *                                   not correspond to the ranges start and end
 * @Override
 */
RangeItem.prototype.repositionX = function (limitSize) {
  var parentWidth = this.parent.width;
  var start = this.conversion.toScreen(this.data.start);
  var end = this.conversion.toScreen(this.data.end);
  var contentLeft;
  var contentWidth;

  // limit the width of the range, as browsers cannot draw very wide divs
  if (limitSize === undefined || limitSize === true) {
    if (start < -parentWidth) {
      start = -parentWidth;
    }
    if (end > 2 * parentWidth) {
      end = 2 * parentWidth;
    }
  }
  var boxWidth = Math.max(end - start, 1);

  if (this.overflow) {
    this.left = start;
    this.width = boxWidth + this.props.content.width;
    contentWidth = this.props.content.width;

    // Note: The calculation of width is an optimistic calculation, giving
    //       a width which will not change when moving the Timeline
    //       So no re-stacking needed, which is nicer for the eye;
  } else {
      this.left = start;
      this.width = boxWidth;
      contentWidth = Math.min(end - start, this.props.content.width);
    }

  this.dom.box.style.left = this.left + 'px';
  this.dom.box.style.width = boxWidth + 'px';

  switch (this.options.align) {
    case 'left':
      this.dom.content.style.left = '0';
      break;

    case 'right':
      this.dom.content.style.left = Math.max(boxWidth - contentWidth, 0) + 'px';
      break;

    case 'center':
      this.dom.content.style.left = Math.max((boxWidth - contentWidth) / 2, 0) + 'px';
      break;

    default:
      // 'auto'
      // when range exceeds left of the window, position the contents at the left of the visible area
      if (this.overflow) {
        if (end > 0) {
          contentLeft = Math.max(-start, 0);
        } else {
          contentLeft = -contentWidth; // ensure it's not visible anymore
        }
      } else {
          if (start < 0) {
            contentLeft = -start;
          } else {
            contentLeft = 0;
          }
        }
      this.dom.content.style.left = contentLeft + 'px';
  }
};

/**
 * Reposition the item vertically
 * @Override
 */
RangeItem.prototype.repositionY = function () {
  var orientation = this.options.orientation.item;
  var box = this.dom.box;

  if (orientation == 'top') {
    box.style.top = this.top + 'px';
  } else {
    box.style.top = this.parent.height - this.top - this.height + 'px';
  }
};

/**
 * Repaint a drag area on the left side of the range when the range is selected
 * @protected
 */
RangeItem.prototype._repaintDragLeft = function () {
  if (this.selected && this.options.editable.updateTime && !this.dom.dragLeft) {
    // create and show drag area
    var dragLeft = document.createElement('div');
    dragLeft.className = 'vis-drag-left';
    dragLeft.dragLeftItem = this;

    this.dom.box.appendChild(dragLeft);
    this.dom.dragLeft = dragLeft;
  } else if (!this.selected && this.dom.dragLeft) {
    // delete drag area
    if (this.dom.dragLeft.parentNode) {
      this.dom.dragLeft.parentNode.removeChild(this.dom.dragLeft);
    }
    this.dom.dragLeft = null;
  }
};

/**
 * Repaint a drag area on the right side of the range when the range is selected
 * @protected
 */
RangeItem.prototype._repaintDragRight = function () {
  if (this.selected && this.options.editable.updateTime && !this.dom.dragRight) {
    // create and show drag area
    var dragRight = document.createElement('div');
    dragRight.className = 'vis-drag-right';
    dragRight.dragRightItem = this;

    this.dom.box.appendChild(dragRight);
    this.dom.dragRight = dragRight;
  } else if (!this.selected && this.dom.dragRight) {
    // delete drag area
    if (this.dom.dragRight.parentNode) {
      this.dom.dragRight.parentNode.removeChild(this.dom.dragRight);
    }
    this.dom.dragRight = null;
  }
};

module.exports = RangeItem;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9SYW5nZUl0ZW0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQUMvQyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7Ozs7Ozs7Ozs7OztBQVk3QixTQUFTLFNBQVMsQ0FBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRTtBQUM3QyxNQUFJLENBQUMsS0FBSyxHQUFHO0FBQ1gsV0FBTyxFQUFFO0FBQ1AsV0FBSyxFQUFFLENBQUM7S0FDVDtHQUNGLENBQUM7QUFDRixNQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQzs7O0FBR3RCLE1BQUksSUFBSSxFQUFFO0FBQ1IsUUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLFNBQVMsRUFBRTtBQUMzQixZQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUNoRTtBQUNELFFBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxTQUFTLEVBQUU7QUFDekIsWUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDOUQ7R0FDRjs7QUFFRCxNQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQzVDOztBQUVELFNBQVMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxJQUFJLENBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzs7QUFFbEQsU0FBUyxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsb0JBQW9CLENBQUM7Ozs7Ozs7QUFPekQsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsVUFBUyxLQUFLLEVBQUU7O0FBRTlDLFNBQU8sQUFBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxJQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxLQUFLLEFBQUMsQ0FBQztDQUN2RSxDQUFDOzs7OztBQUtGLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFlBQVc7QUFDdEMsTUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUNuQixNQUFJLENBQUMsR0FBRyxFQUFFOztBQUVSLFFBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2QsT0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7OztBQUdmLE9BQUcsQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7OztBQUl4QyxPQUFHLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUMsT0FBRyxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLENBQUM7QUFDMUMsT0FBRyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDOzs7QUFHL0IsT0FBRyxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzVDLE9BQUcsQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLGtCQUFrQixDQUFDO0FBQzNDLE9BQUcsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7O0FBR25DLE9BQUcsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLEdBQUcsSUFBSSxDQUFDOztBQUVoQyxRQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztHQUNuQjs7O0FBR0QsTUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDaEIsVUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO0dBQzNEO0FBQ0QsTUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFO0FBQ3ZCLFFBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQztBQUM1QyxRQUFJLENBQUMsVUFBVSxFQUFFO0FBQ2YsWUFBTSxJQUFJLEtBQUssQ0FBQyxnRUFBZ0UsQ0FBQyxDQUFDO0tBQ25GO0FBQ0QsY0FBVSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7R0FDakM7QUFDRCxNQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQzs7Ozs7O0FBTXRCLE1BQUksSUFBSSxDQUFDLEtBQUssRUFBRTtBQUNkLFFBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN2QyxRQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDaEMsUUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDekMsUUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUVoQyxRQUFJLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFVBQVUsSUFDaEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsV0FBVyxJQUNqQyxJQUFJLENBQUMsUUFBUSxLQUFLLElBQUksQ0FBQSxJQUN2QixJQUFJLENBQUMsUUFBUSxLQUFLLEtBQUssQ0FBQzs7O0FBR3ZDLFFBQUksU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFJLEVBQUUsQ0FBQSxJQUNsRSxJQUFJLENBQUMsUUFBUSxHQUFHLGVBQWUsR0FBRyxFQUFFLENBQUEsQUFBQyxJQUNyQyxRQUFRLEdBQUcsZUFBZSxHQUFHLGVBQWUsQ0FBQSxBQUFDLENBQUM7QUFDbkQsT0FBRyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUM7OztBQUduRCxRQUFJLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxLQUFLLFFBQVEsQ0FBQzs7Ozs7QUFLekUsUUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUM7QUFDekMsUUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQztBQUN4RCxRQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQztBQUN4QyxRQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQzs7QUFFckMsUUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7R0FDcEI7O0FBRUQsTUFBSSxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNuQyxNQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztBQUN4QixNQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztDQUMxQixDQUFDOzs7Ozs7QUFNRixTQUFTLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxZQUFXO0FBQ3BDLE1BQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQ25CLFFBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztHQUNmO0NBQ0YsQ0FBQzs7Ozs7O0FBTUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsWUFBVztBQUNwQyxNQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7QUFDbEIsUUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7O0FBRXZCLFFBQUksR0FBRyxDQUFDLFVBQVUsRUFBRTtBQUNsQixTQUFHLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNqQzs7QUFFRCxRQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztHQUN4QjtDQUNGLENBQUM7Ozs7Ozs7Ozs7O0FBV0YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQUcsVUFBUyxTQUFTLEVBQUU7QUFDcEQsTUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7QUFDcEMsTUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN0RCxNQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2xELE1BQUksV0FBVyxDQUFDO0FBQ2hCLE1BQUksWUFBWSxDQUFDOzs7QUFHakIsTUFBSSxTQUFTLEtBQUssU0FBUyxJQUFJLFNBQVMsS0FBSyxJQUFJLEVBQUU7QUFDakQsUUFBSSxLQUFLLEdBQUcsQ0FBQyxXQUFXLEVBQUU7QUFDeEIsV0FBSyxHQUFHLENBQUMsV0FBVyxDQUFDO0tBQ3RCO0FBQ0QsUUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLFdBQVcsRUFBRTtBQUN6QixTQUFHLEdBQUcsQ0FBQyxHQUFHLFdBQVcsQ0FBQztLQUN2QjtHQUNGO0FBQ0QsTUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDOztBQUV4QyxNQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7QUFDakIsUUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7QUFDbEIsUUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO0FBQ2pELGdCQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDOzs7OztHQUt6QyxNQUNJO0FBQ0gsVUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7QUFDbEIsVUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUM7QUFDdEIsa0JBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDaEU7O0FBRUQsTUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUMzQyxNQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUM7O0FBRTNDLFVBQVEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLO0FBQ3hCLFNBQUssTUFBTTtBQUNULFVBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO0FBQ2xDLFlBQU07O0FBQUEsQUFFUixTQUFLLE9BQU87QUFDVixVQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUUsUUFBUSxHQUFHLFlBQVksRUFBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDNUUsWUFBTTs7QUFBQSxBQUVSLFNBQUssUUFBUTtBQUNYLFVBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsR0FBRyxZQUFZLENBQUEsR0FBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQ2hGLFlBQU07O0FBQUEsQUFFUjs7O0FBRUUsVUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO0FBQ2pCLFlBQUksR0FBRyxHQUFHLENBQUMsRUFBRTtBQUNYLHFCQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztTQUNuQyxNQUNJO0FBQ0gscUJBQVcsR0FBRyxDQUFDLFlBQVksQ0FBQztTQUM3QjtPQUNGLE1BQ0k7QUFDSCxjQUFJLEtBQUssR0FBRyxDQUFDLEVBQUU7QUFDYix1QkFBVyxHQUFHLENBQUMsS0FBSyxDQUFDO1dBQ3RCLE1BQ0k7QUFDSCx1QkFBVyxHQUFHLENBQUMsQ0FBQztXQUNqQjtTQUNGO0FBQ0QsVUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDO0FBQUEsR0FDcEQ7Q0FDRixDQUFDOzs7Ozs7QUFNRixTQUFTLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxZQUFXO0FBQzNDLE1BQUksV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztBQUNoRCxNQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQzs7QUFFdkIsTUFBSSxXQUFXLElBQUksS0FBSyxFQUFFO0FBQ3hCLE9BQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO0dBQ2pDLE1BQ0k7QUFDSCxPQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxBQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBSSxJQUFJLENBQUM7R0FDdEU7Q0FDRixDQUFDOzs7Ozs7QUFNRixTQUFTLENBQUMsU0FBUyxDQUFDLGdCQUFnQixHQUFHLFlBQVk7QUFDakQsTUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFOztBQUUzRSxRQUFJLFFBQVEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzdDLFlBQVEsQ0FBQyxTQUFTLEdBQUcsZUFBZSxDQUFDO0FBQ3JDLFlBQVEsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDOztBQUU3QixRQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDbkMsUUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0dBQzlCLE1BQ0ksSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUU7O0FBRTVDLFFBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFO0FBQ2hDLFVBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUM3RDtBQUNELFFBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztHQUMxQjtDQUNGLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEdBQUcsWUFBWTtBQUNsRCxNQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUU7O0FBRTVFLFFBQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDOUMsYUFBUyxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQztBQUN2QyxhQUFTLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQzs7QUFFL0IsUUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3BDLFFBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztHQUNoQyxNQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFOztBQUU3QyxRQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRTtBQUNqQyxVQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDL0Q7QUFDRCxRQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7R0FDM0I7Q0FDRixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDIiwiZmlsZSI6Ii91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9jb21wb25lbnQvaXRlbS9SYW5nZUl0ZW0uanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSGFtbWVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlL2hhbW1lcicpO1xudmFyIEl0ZW0gPSByZXF1aXJlKCcuL0l0ZW0nKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUmFuZ2VJdGVtXG4gKiBAZXh0ZW5kcyBJdGVtXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHN0YXJ0LCBlbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsIGNsYXNzTmFtZS5cbiAqIEBwYXJhbSB7e3RvU2NyZWVuOiBmdW5jdGlvbiwgdG9UaW1lOiBmdW5jdGlvbn19IGNvbnZlcnNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNpb24gZnVuY3Rpb25zIGZyb20gdGltZSB0byBzY3JlZW4gYW5kIHZpY2UgdmVyc2FcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVzY3JpYmUgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBSYW5nZUl0ZW0gKGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpIHtcbiAgdGhpcy5wcm9wcyA9IHtcbiAgICBjb250ZW50OiB7XG4gICAgICB3aWR0aDogMFxuICAgIH1cbiAgfTtcbiAgdGhpcy5vdmVyZmxvdyA9IGZhbHNlOyAvLyBpZiBjb250ZW50cyBjYW4gb3ZlcmZsb3cgKGNzcyBzdHlsaW5nKSwgdGhpcyBmbGFnIGlzIHNldCB0byB0cnVlXG5cbiAgLy8gdmFsaWRhdGUgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcInN0YXJ0XCIgbWlzc2luZyBpbiBpdGVtICcgKyBkYXRhLmlkKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuZW5kID09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcImVuZFwiIG1pc3NpbmcgaW4gaXRlbSAnICsgZGF0YS5pZCk7XG4gICAgfVxuICB9XG5cbiAgSXRlbS5jYWxsKHRoaXMsIGRhdGEsIGNvbnZlcnNpb24sIG9wdGlvbnMpO1xufVxuXG5SYW5nZUl0ZW0ucHJvdG90eXBlID0gbmV3IEl0ZW0gKG51bGwsIG51bGwsIG51bGwpO1xuXG5SYW5nZUl0ZW0ucHJvdG90eXBlLmJhc2VDbGFzc05hbWUgPSAndmlzLWl0ZW0gdmlzLXJhbmdlJztcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoaXMgaXRlbSBpcyB2aXNpYmxlIGluc2lkZSBnaXZlbiByYW5nZVxuICogQHJldHVybnMge3tzdGFydDogTnVtYmVyLCBlbmQ6IE51bWJlcn19IHJhbmdlIHdpdGggYSB0aW1lc3RhbXAgZm9yIHN0YXJ0IGFuZCBlbmRcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZpc2libGVcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbihyYW5nZSkge1xuICAvLyBkZXRlcm1pbmUgdmlzaWJpbGl0eVxuICByZXR1cm4gKHRoaXMuZGF0YS5zdGFydCA8IHJhbmdlLmVuZCkgJiYgKHRoaXMuZGF0YS5lbmQgPiByYW5nZS5zdGFydCk7XG59O1xuXG4vKipcbiAqIFJlcGFpbnQgdGhlIGl0ZW1cbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICBpZiAoIWRvbSkge1xuICAgIC8vIGNyZWF0ZSBET01cbiAgICB0aGlzLmRvbSA9IHt9O1xuICAgIGRvbSA9IHRoaXMuZG9tO1xuXG4gICAgICAvLyBiYWNrZ3JvdW5kIGJveFxuICAgIGRvbS5ib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAvLyBjbGFzc05hbWUgaXMgdXBkYXRlZCBpbiByZWRyYXcoKVxuXG4gICAgLy8gZnJhbWUgYm94ICh0byBwcmV2ZW50IHRoZSBpdGVtIGNvbnRlbnRzIGZyb20gb3ZlcmZsb3dpbmdcbiAgICBkb20uZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb20uZnJhbWUuY2xhc3NOYW1lID0gJ3Zpcy1pdGVtLW92ZXJmbG93JztcbiAgICBkb20uYm94LmFwcGVuZENoaWxkKGRvbS5mcmFtZSk7XG5cbiAgICAvLyBjb250ZW50cyBib3hcbiAgICBkb20uY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvbS5jb250ZW50LmNsYXNzTmFtZSA9ICd2aXMtaXRlbS1jb250ZW50JztcbiAgICBkb20uZnJhbWUuYXBwZW5kQ2hpbGQoZG9tLmNvbnRlbnQpO1xuXG4gICAgLy8gYXR0YWNoIHRoaXMgaXRlbSBhcyBhdHRyaWJ1dGVcbiAgICBkb20uYm94Wyd0aW1lbGluZS1pdGVtJ10gPSB0aGlzO1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cblxuICAvLyBhcHBlbmQgRE9NIHRvIHBhcmVudCBET01cbiAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZHJhdyBpdGVtOiBubyBwYXJlbnQgYXR0YWNoZWQnKTtcbiAgfVxuICBpZiAoIWRvbS5ib3gucGFyZW50Tm9kZSkge1xuICAgIHZhciBmb3JlZ3JvdW5kID0gdGhpcy5wYXJlbnQuZG9tLmZvcmVncm91bmQ7XG4gICAgaWYgKCFmb3JlZ3JvdW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWRyYXcgaXRlbTogcGFyZW50IGhhcyBubyBmb3JlZ3JvdW5kIGNvbnRhaW5lciBlbGVtZW50Jyk7XG4gICAgfVxuICAgIGZvcmVncm91bmQuYXBwZW5kQ2hpbGQoZG9tLmJveCk7XG4gIH1cbiAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuXG4gIC8vIFVwZGF0ZSBET00gd2hlbiBpdGVtIGlzIG1hcmtlZCBkaXJ0eS4gQW4gaXRlbSBpcyBtYXJrZWQgZGlydHkgd2hlbjpcbiAgLy8gLSB0aGUgaXRlbSBpcyBub3QgeWV0IHJlbmRlcmVkXG4gIC8vIC0gdGhlIGl0ZW0ncyBkYXRhIGlzIGNoYW5nZWRcbiAgLy8gLSB0aGUgaXRlbSBpcyBzZWxlY3RlZC9kZXNlbGVjdGVkXG4gIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgdGhpcy5fdXBkYXRlQ29udGVudHModGhpcy5kb20uY29udGVudCk7XG4gICAgdGhpcy5fdXBkYXRlVGl0bGUodGhpcy5kb20uYm94KTtcbiAgICB0aGlzLl91cGRhdGVEYXRhQXR0cmlidXRlcyh0aGlzLmRvbS5ib3gpO1xuICAgIHRoaXMuX3VwZGF0ZVN0eWxlKHRoaXMuZG9tLmJveCk7XG5cbiAgICB2YXIgZWRpdGFibGUgPSAodGhpcy5vcHRpb25zLmVkaXRhYmxlLnVwZGF0ZVRpbWUgfHwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVHcm91cCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRhYmxlID09PSB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdGFibGUgIT09IGZhbHNlO1xuXG4gICAgLy8gdXBkYXRlIGNsYXNzXG4gICAgdmFyIGNsYXNzTmFtZSA9ICh0aGlzLmRhdGEuY2xhc3NOYW1lID8gKCcgJyArIHRoaXMuZGF0YS5jbGFzc05hbWUpIDogJycpICtcbiAgICAgICAgKHRoaXMuc2VsZWN0ZWQgPyAnIHZpcy1zZWxlY3RlZCcgOiAnJykgKyBcbiAgICAgICAgKGVkaXRhYmxlID8gJyB2aXMtZWRpdGFibGUnIDogJyB2aXMtcmVhZG9ubHknKTtcbiAgICBkb20uYm94LmNsYXNzTmFtZSA9IHRoaXMuYmFzZUNsYXNzTmFtZSArIGNsYXNzTmFtZTtcblxuICAgIC8vIGRldGVybWluZSBmcm9tIGNzcyB3aGV0aGVyIHRoaXMgYm94IGhhcyBvdmVyZmxvd1xuICAgIHRoaXMub3ZlcmZsb3cgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20uZnJhbWUpLm92ZXJmbG93ICE9PSAnaGlkZGVuJztcblxuICAgIC8vIHJlY2FsY3VsYXRlIHNpemVcbiAgICAvLyB0dXJuIG9mZiBtYXgtd2lkdGggdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgdGhlIHJlYWwgd2lkdGhcbiAgICAvLyB0aGlzIGNhdXNlcyBhbiBleHRyYSBicm93c2VyIHJlcGFpbnQvcmVmbG93LCBidXQgc28gYmUgaXRcbiAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLm1heFdpZHRoID0gJ25vbmUnO1xuICAgIHRoaXMucHJvcHMuY29udGVudC53aWR0aCA9IHRoaXMuZG9tLmNvbnRlbnQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmRvbS5ib3gub2Zmc2V0SGVpZ2h0O1xuICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubWF4V2lkdGggPSAnJztcblxuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuX3JlcGFpbnREZWxldGVCdXR0b24oZG9tLmJveCk7XG4gIHRoaXMuX3JlcGFpbnREcmFnTGVmdCgpO1xuICB0aGlzLl9yZXBhaW50RHJhZ1JpZ2h0KCk7XG59O1xuXG4vKipcbiAqIFNob3cgdGhlIGl0ZW0gaW4gdGhlIERPTSAod2hlbiBub3QgYWxyZWFkeSB2aXNpYmxlKS4gVGhlIGl0ZW1zIERPTSB3aWxsXG4gKiBiZSBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRpc3BsYXllZCkge1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH1cbn07XG5cbi8qKlxuICogSGlkZSB0aGUgaXRlbSBmcm9tIHRoZSBET00gKHdoZW4gdmlzaWJsZSlcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAqL1xuUmFuZ2VJdGVtLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmRpc3BsYXllZCkge1xuICAgIHZhciBib3ggPSB0aGlzLmRvbS5ib3g7XG5cbiAgICBpZiAoYm94LnBhcmVudE5vZGUpIHtcbiAgICAgIGJveC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJveCk7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIGhvcml6b250YWxseVxuICogQHBhcmFtIHtib29sZWFufSBbbGltaXRTaXplPXRydWVdIElmIHRydWUgKGRlZmF1bHQpLCB0aGUgd2lkdGggb2YgdGhlIHJhbmdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSB3aWxsIGJlIGxpbWl0ZWQsIGFzIHRoZSBicm93c2VyIGNhbm5vdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgdmVyeSB3aWRlIGRpdnMuIFRoaXMgbWVhbnMgdGhvdWdoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCB0aGUgYXBwbGllZCBsZWZ0IGFuZCB3aWR0aCBtYXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29ycmVzcG9uZCB0byB0aGUgcmFuZ2VzIHN0YXJ0IGFuZCBlbmRcbiAqIEBPdmVycmlkZVxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25YID0gZnVuY3Rpb24obGltaXRTaXplKSB7XG4gIHZhciBwYXJlbnRXaWR0aCA9IHRoaXMucGFyZW50LndpZHRoO1xuICB2YXIgc3RhcnQgPSB0aGlzLmNvbnZlcnNpb24udG9TY3JlZW4odGhpcy5kYXRhLnN0YXJ0KTtcbiAgdmFyIGVuZCA9IHRoaXMuY29udmVyc2lvbi50b1NjcmVlbih0aGlzLmRhdGEuZW5kKTtcbiAgdmFyIGNvbnRlbnRMZWZ0O1xuICB2YXIgY29udGVudFdpZHRoO1xuXG4gIC8vIGxpbWl0IHRoZSB3aWR0aCBvZiB0aGUgcmFuZ2UsIGFzIGJyb3dzZXJzIGNhbm5vdCBkcmF3IHZlcnkgd2lkZSBkaXZzXG4gIGlmIChsaW1pdFNpemUgPT09IHVuZGVmaW5lZCB8fCBsaW1pdFNpemUgPT09IHRydWUpIHtcbiAgICBpZiAoc3RhcnQgPCAtcGFyZW50V2lkdGgpIHtcbiAgICAgIHN0YXJ0ID0gLXBhcmVudFdpZHRoO1xuICAgIH1cbiAgICBpZiAoZW5kID4gMiAqIHBhcmVudFdpZHRoKSB7XG4gICAgICBlbmQgPSAyICogcGFyZW50V2lkdGg7XG4gICAgfVxuICB9XG4gIHZhciBib3hXaWR0aCA9IE1hdGgubWF4KGVuZCAtIHN0YXJ0LCAxKTtcblxuICBpZiAodGhpcy5vdmVyZmxvdykge1xuICAgIHRoaXMubGVmdCA9IHN0YXJ0O1xuICAgIHRoaXMud2lkdGggPSBib3hXaWR0aCArIHRoaXMucHJvcHMuY29udGVudC53aWR0aDtcbiAgICBjb250ZW50V2lkdGggPSB0aGlzLnByb3BzLmNvbnRlbnQud2lkdGg7XG5cbiAgICAvLyBOb3RlOiBUaGUgY2FsY3VsYXRpb24gb2Ygd2lkdGggaXMgYW4gb3B0aW1pc3RpYyBjYWxjdWxhdGlvbiwgZ2l2aW5nXG4gICAgLy8gICAgICAgYSB3aWR0aCB3aGljaCB3aWxsIG5vdCBjaGFuZ2Ugd2hlbiBtb3ZpbmcgdGhlIFRpbWVsaW5lXG4gICAgLy8gICAgICAgU28gbm8gcmUtc3RhY2tpbmcgbmVlZGVkLCB3aGljaCBpcyBuaWNlciBmb3IgdGhlIGV5ZTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmxlZnQgPSBzdGFydDtcbiAgICB0aGlzLndpZHRoID0gYm94V2lkdGg7XG4gICAgY29udGVudFdpZHRoID0gTWF0aC5taW4oZW5kIC0gc3RhcnQsIHRoaXMucHJvcHMuY29udGVudC53aWR0aCk7XG4gIH1cblxuICB0aGlzLmRvbS5ib3guc3R5bGUubGVmdCA9IHRoaXMubGVmdCArICdweCc7XG4gIHRoaXMuZG9tLmJveC5zdHlsZS53aWR0aCA9IGJveFdpZHRoICsgJ3B4JztcblxuICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5hbGlnbikge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgdGhpcy5kb20uY29udGVudC5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmxlZnQgPSBNYXRoLm1heCgoYm94V2lkdGggLSBjb250ZW50V2lkdGgpLCAwKSArICdweCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICB0aGlzLmRvbS5jb250ZW50LnN0eWxlLmxlZnQgPSBNYXRoLm1heCgoYm94V2lkdGggLSBjb250ZW50V2lkdGgpIC8gMiwgMCkgKyAncHgnO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OiAvLyAnYXV0bydcbiAgICAgIC8vIHdoZW4gcmFuZ2UgZXhjZWVkcyBsZWZ0IG9mIHRoZSB3aW5kb3csIHBvc2l0aW9uIHRoZSBjb250ZW50cyBhdCB0aGUgbGVmdCBvZiB0aGUgdmlzaWJsZSBhcmVhXG4gICAgICBpZiAodGhpcy5vdmVyZmxvdykge1xuICAgICAgICBpZiAoZW5kID4gMCkge1xuICAgICAgICAgIGNvbnRlbnRMZWZ0ID0gTWF0aC5tYXgoLXN0YXJ0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZW50TGVmdCA9IC1jb250ZW50V2lkdGg7IC8vIGVuc3VyZSBpdCdzIG5vdCB2aXNpYmxlIGFueW1vcmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBjb250ZW50TGVmdCA9IC1zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZW50TGVmdCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZG9tLmNvbnRlbnQuc3R5bGUubGVmdCA9IGNvbnRlbnRMZWZ0ICsgJ3B4JztcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBvc2l0aW9uIHRoZSBpdGVtIHZlcnRpY2FsbHlcbiAqIEBPdmVycmlkZVxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLnJlcG9zaXRpb25ZID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbi5pdGVtO1xuICB2YXIgYm94ID0gdGhpcy5kb20uYm94O1xuXG4gIGlmIChvcmllbnRhdGlvbiA9PSAndG9wJykge1xuICAgIGJveC5zdHlsZS50b3AgPSB0aGlzLnRvcCArICdweCc7XG4gIH1cbiAgZWxzZSB7XG4gICAgYm94LnN0eWxlLnRvcCA9ICh0aGlzLnBhcmVudC5oZWlnaHQgLSB0aGlzLnRvcCAtIHRoaXMuaGVpZ2h0KSArICdweCc7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwYWludCBhIGRyYWcgYXJlYSBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSByYW5nZSB3aGVuIHRoZSByYW5nZSBpcyBzZWxlY3RlZFxuICogQHByb3RlY3RlZFxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLl9yZXBhaW50RHJhZ0xlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNlbGVjdGVkICYmIHRoaXMub3B0aW9ucy5lZGl0YWJsZS51cGRhdGVUaW1lICYmICF0aGlzLmRvbS5kcmFnTGVmdCkge1xuICAgIC8vIGNyZWF0ZSBhbmQgc2hvdyBkcmFnIGFyZWFcbiAgICB2YXIgZHJhZ0xlZnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkcmFnTGVmdC5jbGFzc05hbWUgPSAndmlzLWRyYWctbGVmdCc7XG4gICAgZHJhZ0xlZnQuZHJhZ0xlZnRJdGVtID0gdGhpcztcblxuICAgIHRoaXMuZG9tLmJveC5hcHBlbmRDaGlsZChkcmFnTGVmdCk7XG4gICAgdGhpcy5kb20uZHJhZ0xlZnQgPSBkcmFnTGVmdDtcbiAgfVxuICBlbHNlIGlmICghdGhpcy5zZWxlY3RlZCAmJiB0aGlzLmRvbS5kcmFnTGVmdCkge1xuICAgIC8vIGRlbGV0ZSBkcmFnIGFyZWFcbiAgICBpZiAodGhpcy5kb20uZHJhZ0xlZnQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uZHJhZ0xlZnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5kcmFnTGVmdCk7XG4gICAgfVxuICAgIHRoaXMuZG9tLmRyYWdMZWZ0ID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBhaW50IGEgZHJhZyBhcmVhIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSByYW5nZSB3aGVuIHRoZSByYW5nZSBpcyBzZWxlY3RlZFxuICogQHByb3RlY3RlZFxuICovXG5SYW5nZUl0ZW0ucHJvdG90eXBlLl9yZXBhaW50RHJhZ1JpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zZWxlY3RlZCAmJiB0aGlzLm9wdGlvbnMuZWRpdGFibGUudXBkYXRlVGltZSAmJiAhdGhpcy5kb20uZHJhZ1JpZ2h0KSB7XG4gICAgLy8gY3JlYXRlIGFuZCBzaG93IGRyYWcgYXJlYVxuICAgIHZhciBkcmFnUmlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkcmFnUmlnaHQuY2xhc3NOYW1lID0gJ3Zpcy1kcmFnLXJpZ2h0JztcbiAgICBkcmFnUmlnaHQuZHJhZ1JpZ2h0SXRlbSA9IHRoaXM7XG5cbiAgICB0aGlzLmRvbS5ib3guYXBwZW5kQ2hpbGQoZHJhZ1JpZ2h0KTtcbiAgICB0aGlzLmRvbS5kcmFnUmlnaHQgPSBkcmFnUmlnaHQ7XG4gIH1cbiAgZWxzZSBpZiAoIXRoaXMuc2VsZWN0ZWQgJiYgdGhpcy5kb20uZHJhZ1JpZ2h0KSB7XG4gICAgLy8gZGVsZXRlIGRyYWcgYXJlYVxuICAgIGlmICh0aGlzLmRvbS5kcmFnUmlnaHQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kb20uZHJhZ1JpZ2h0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20uZHJhZ1JpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy5kb20uZHJhZ1JpZ2h0ID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5nZUl0ZW07XG4iXX0=
},{"../../../module/hammer":19,"./Item":41}],44:[function(require,module,exports){
// English
'use strict';

exports['en'] = {
  current: 'current',
  time: 'time'
};
exports['en_EN'] = exports['en'];
exports['en_US'] = exports['en'];

// Dutch
exports['nl'] = {
  current: 'huidige',
  time: 'tijd'
};
exports['nl_NL'] = exports['nl'];
exports['nl_BE'] = exports['nl'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9sb2NhbGVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRztBQUNkLFNBQU8sRUFBRSxTQUFTO0FBQ2xCLE1BQUksRUFBRSxNQUFNO0NBQ2IsQ0FBQztBQUNGLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQzs7O0FBR2pDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRztBQUNkLFNBQU8sRUFBRSxTQUFTO0FBQ2xCLE1BQUksRUFBRSxNQUFNO0NBQ2IsQ0FBQztBQUNGLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyIsImZpbGUiOiIvdXNyL3NyYy9hcHAvbm9kZV9tb2R1bGVzL3Zpcy9saWIvdGltZWxpbmUvbG9jYWxlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEVuZ2xpc2hcbmV4cG9ydHNbJ2VuJ10gPSB7XG4gIGN1cnJlbnQ6ICdjdXJyZW50JyxcbiAgdGltZTogJ3RpbWUnXG59O1xuZXhwb3J0c1snZW5fRU4nXSA9IGV4cG9ydHNbJ2VuJ107XG5leHBvcnRzWydlbl9VUyddID0gZXhwb3J0c1snZW4nXTtcblxuLy8gRHV0Y2hcbmV4cG9ydHNbJ25sJ10gPSB7XG4gIGN1cnJlbnQ6ICdodWlkaWdlJyxcbiAgdGltZTogJ3RpamQnXG59O1xuZXhwb3J0c1snbmxfTkwnXSA9IGV4cG9ydHNbJ25sJ107XG5leHBvcnRzWydubF9CRSddID0gZXhwb3J0c1snbmwnXTtcbiJdfQ==
},{}],45:[function(require,module,exports){
/**
 * This object contains all possible options. It will check if the types are correct, if required if the option is one
 * of the allowed values.
 *
 * __any__ means that the name of the property does not matter.
 * __type__ is a required field for all objects and contains the allowed types of all objects
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var string = 'string';
var boolean = 'boolean';
var number = 'number';
var array = 'array';
var date = 'date';
var object = 'object'; // should only be in a __type__ property
var dom = 'dom';
var moment = 'moment';
var any = 'any';

var allOptions = {
  configure: {
    enabled: { boolean: boolean },
    filter: { boolean: boolean, 'function': 'function' },
    container: { dom: dom },
    __type__: { object: object, boolean: boolean, 'function': 'function' }
  },

  //globals :
  align: { string: string },
  autoResize: { boolean: boolean },
  throttleRedraw: { number: number },
  clickToUse: { boolean: boolean },
  dataAttributes: { string: string, array: array },
  editable: {
    add: { boolean: boolean, 'undefined': 'undefined' },
    remove: { boolean: boolean, 'undefined': 'undefined' },
    updateGroup: { boolean: boolean, 'undefined': 'undefined' },
    updateTime: { boolean: boolean, 'undefined': 'undefined' },
    __type__: { boolean: boolean, object: object }
  },
  end: { number: number, date: date, string: string, moment: moment },
  format: {
    minorLabels: {
      millisecond: { string: string, 'undefined': 'undefined' },
      second: { string: string, 'undefined': 'undefined' },
      minute: { string: string, 'undefined': 'undefined' },
      hour: { string: string, 'undefined': 'undefined' },
      weekday: { string: string, 'undefined': 'undefined' },
      day: { string: string, 'undefined': 'undefined' },
      month: { string: string, 'undefined': 'undefined' },
      year: { string: string, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    majorLabels: {
      millisecond: { string: string, 'undefined': 'undefined' },
      second: { string: string, 'undefined': 'undefined' },
      minute: { string: string, 'undefined': 'undefined' },
      hour: { string: string, 'undefined': 'undefined' },
      weekday: { string: string, 'undefined': 'undefined' },
      day: { string: string, 'undefined': 'undefined' },
      month: { string: string, 'undefined': 'undefined' },
      year: { string: string, 'undefined': 'undefined' },
      __type__: { object: object }
    },
    __type__: { object: object }
  },
  moment: { 'function': 'function' },
  groupOrder: { string: string, 'function': 'function' },
  groupEditable: {
    add: { boolean: boolean, 'undefined': 'undefined' },
    remove: { boolean: boolean, 'undefined': 'undefined' },
    order: { boolean: boolean, 'undefined': 'undefined' },
    __type__: { boolean: boolean, object: object }
  },
  groupOrderSwap: { 'function': 'function' },
  height: { string: string, number: number },
  hiddenDates: {
    start: { date: date, number: number, string: string, moment: moment },
    end: { date: date, number: number, string: string, moment: moment },
    repeat: { string: string },
    __type__: { object: object, array: array }
  },
  locale: { string: string },
  locales: {
    __type__: { object: object }
  },
  margin: {
    axis: { number: number },
    item: {
      horizontal: { number: number, 'undefined': 'undefined' },
      vertical: { number: number, 'undefined': 'undefined' },
      __type__: { object: object, number: number }
    },
    __type__: { object: object, number: number }
  },
  max: { date: date, number: number, string: string, moment: moment },
  maxHeight: { number: number, string: string },
  min: { date: date, number: number, string: string, moment: moment },
  minHeight: { number: number, string: string },
  moveable: { boolean: boolean },
  multiselect: { boolean: boolean },
  onAdd: { 'function': 'function' },
  onUpdate: { 'function': 'function' },
  onMove: { 'function': 'function' },
  onMoving: { 'function': 'function' },
  onRemove: { 'function': 'function' },
  onAddGroup: { 'function': 'function' },
  onMoveGroup: { 'function': 'function' },
  onRemoveGroup: { 'function': 'function' },
  order: { 'function': 'function' },
  orientation: {
    axis: { string: string, 'undefined': 'undefined' },
    item: { string: string, 'undefined': 'undefined' },
    __type__: { string: string, object: object }
  },
  selectable: { boolean: boolean },
  showCurrentTime: { boolean: boolean },
  showMajorLabels: { boolean: boolean },
  showMinorLabels: { boolean: boolean },
  stack: { boolean: boolean },
  snap: { 'function': 'function', 'null': 'null' },
  start: { date: date, number: number, string: string, moment: moment },
  template: { 'function': 'function' },
  groupTemplate: { 'function': 'function' },
  timeAxis: {
    scale: { string: string, 'undefined': 'undefined' },
    step: { number: number, 'undefined': 'undefined' },
    __type__: { object: object }
  },
  type: { string: string },
  width: { string: string, number: number },
  zoomable: { boolean: boolean },
  zoomKey: { string: ['ctrlKey', 'altKey', 'metaKey', ''] },
  zoomMax: { number: number },
  zoomMin: { number: number },

  __type__: { object: object }
};

var configureOptions = {
  global: {
    align: ['center', 'left', 'right'],
    autoResize: true,
    throttleRedraw: [10, 0, 1000, 10],
    clickToUse: false,
    // dataAttributes: ['all'], // FIXME: can be 'all' or string[]
    editable: {
      add: false,
      remove: false,
      updateGroup: false,
      updateTime: false
    },
    end: '',
    format: {
      minorLabels: {
        millisecond: 'SSS',
        second: 's',
        minute: 'HH:mm',
        hour: 'HH:mm',
        weekday: 'ddd D',
        day: 'D',
        month: 'MMM',
        year: 'YYYY'
      },
      majorLabels: {
        millisecond: 'HH:mm:ss',
        second: 'D MMMM HH:mm',
        minute: 'ddd D MMMM',
        hour: 'ddd D MMMM',
        weekday: 'MMMM YYYY',
        day: 'MMMM YYYY',
        month: 'YYYY',
        year: ''
      }
    },

    //groupOrder: {string, 'function': 'function'},
    groupsDraggable: false,
    height: '',
    //hiddenDates: {object, array},
    locale: '',
    margin: {
      axis: [20, 0, 100, 1],
      item: {
        horizontal: [10, 0, 100, 1],
        vertical: [10, 0, 100, 1]
      }
    },
    max: '',
    maxHeight: '',
    min: '',
    minHeight: '',
    moveable: false,
    multiselect: false,
    //onAdd: {'function': 'function'},
    //onUpdate: {'function': 'function'},
    //onMove: {'function': 'function'},
    //onMoving: {'function': 'function'},
    //onRename: {'function': 'function'},
    //order: {'function': 'function'},
    orientation: {
      axis: ['both', 'bottom', 'top'],
      item: ['bottom', 'top']
    },
    selectable: true,
    showCurrentTime: false,
    showMajorLabels: true,
    showMinorLabels: true,
    stack: true,
    //snap: {'function': 'function', nada},
    start: '',
    //template: {'function': 'function'},
    //timeAxis: {
    //  scale: ['millisecond', 'second', 'minute', 'hour', 'weekday', 'day', 'month', 'year'],
    //  step: [1, 1, 10, 1]
    //},
    type: ['box', 'point', 'range', 'background'],
    width: '100%',
    zoomable: true,
    zoomKey: ['ctrlKey', 'altKey', 'metaKey', ''],
    zoomMax: [315360000000000, 10, 315360000000000, 1],
    zoomMin: [10, 10, 315360000000000, 1]
  }
};

exports.allOptions = allOptions;
exports.configureOptions = configureOptions;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi90aW1lbGluZS9vcHRpb25zVGltZWxpbmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBT0EsSUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDO0FBQ3RCLElBQUksT0FBTyxHQUFHLFNBQVMsQ0FBQztBQUN4QixJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFDdEIsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDO0FBQ3BCLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQztBQUNsQixJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFDdEIsSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDO0FBQ2hCLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQztBQUN0QixJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUM7O0FBR2hCLElBQUksVUFBVSxHQUFHO0FBQ2YsV0FBUyxFQUFFO0FBQ1QsV0FBTyxFQUFFLEVBQUMsT0FBTyxFQUFQLE9BQU8sRUFBQztBQUNsQixVQUFNLEVBQUUsRUFBQyxPQUFPLEVBQVAsT0FBTyxFQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUM7QUFDeEMsYUFBUyxFQUFFLEVBQUMsR0FBRyxFQUFILEdBQUcsRUFBQztBQUNoQixZQUFRLEVBQUUsRUFBQyxNQUFNLEVBQU4sTUFBTSxFQUFDLE9BQU8sRUFBUCxPQUFPLEVBQUMsVUFBVSxFQUFFLFVBQVUsRUFBQztHQUNsRDs7O0FBR0QsT0FBSyxFQUFFLEVBQUMsTUFBTSxFQUFOLE1BQU0sRUFBQztBQUNmLFlBQVUsRUFBRSxFQUFDLE9BQU8sRUFBUCxPQUFPLEVBQUM7QUFDckIsZ0JBQWMsRUFBRSxFQUFDLE1BQU0sRUFBTixNQUFNLEVBQUM7QUFDeEIsWUFBVSxFQUFFLEVBQUMsT0FBTyxFQUFQLE9BQU8sRUFBQztBQUNyQixnQkFBYyxFQUFFLEVBQUMsTUFBTSxFQUFOLE1BQU0sRUFBRSxLQUFLLEVBQUwsS0FBSyxFQUFDO0FBQy9C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LEVBQUUsQ0FBQztBQUM3QyxXQUFPLEVBQUUsQ0FBQyxlQUFlLEVBQUUsRUFBRSxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUM7QUFDbEQsV0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDO0dBQ3RDO0NBQ0YsQ0FBQzs7UUFFTSxVQUFVLEdBQVYsVUFBVTtRQUFFLGdCQUFnQixHQUFoQixnQkFBZ0IiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL3RpbWVsaW5lL29wdGlvbnNUaW1lbGluZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIHBvc3NpYmxlIG9wdGlvbnMuIEl0IHdpbGwgY2hlY2sgaWYgdGhlIHR5cGVzIGFyZSBjb3JyZWN0LCBpZiByZXF1aXJlZCBpZiB0aGUgb3B0aW9uIGlzIG9uZVxuICogb2YgdGhlIGFsbG93ZWQgdmFsdWVzLlxuICpcbiAqIF9fYW55X18gbWVhbnMgdGhhdCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgZG9lcyBub3QgbWF0dGVyLlxuICogX190eXBlX18gaXMgYSByZXF1aXJlZCBmaWVsZCBmb3IgYWxsIG9iamVjdHMgYW5kIGNvbnRhaW5zIHRoZSBhbGxvd2VkIHR5cGVzIG9mIGFsbCBvYmplY3RzXG4gKi9cbmxldCBzdHJpbmcgPSAnc3RyaW5nJztcbmxldCBib29sZWFuID0gJ2Jvb2xlYW4nO1xubGV0IG51bWJlciA9ICdudW1iZXInO1xubGV0IGFycmF5ID0gJ2FycmF5JztcbmxldCBkYXRlID0gJ2RhdGUnO1xubGV0IG9iamVjdCA9ICdvYmplY3QnOyAvLyBzaG91bGQgb25seSBiZSBpbiBhIF9fdHlwZV9fIHByb3BlcnR5XG5sZXQgZG9tID0gJ2RvbSc7XG5sZXQgbW9tZW50ID0gJ21vbWVudCc7XG5sZXQgYW55ID0gJ2FueSc7XG5cblxubGV0IGFsbE9wdGlvbnMgPSB7XG4gIGNvbmZpZ3VyZToge1xuICAgIGVuYWJsZWQ6IHtib29sZWFufSxcbiAgICBmaWx0ZXI6IHtib29sZWFuLCdmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgIGNvbnRhaW5lcjoge2RvbX0sXG4gICAgX190eXBlX186IHtvYmplY3QsYm9vbGVhbiwnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfVxuICB9LFxuXG4gIC8vZ2xvYmFscyA6XG4gIGFsaWduOiB7c3RyaW5nfSxcbiAgYXV0b1Jlc2l6ZToge2Jvb2xlYW59LFxuICB0aHJvdHRsZVJlZHJhdzoge251bWJlcn0sXG4gIGNsaWNrVG9Vc2U6IHtib29sZWFufSxcbiAgZGF0YUF0dHJpYnV0ZXM6IHtzdHJpbmcsIGFycmF5fSxcbiAgZWRpdGFibGU6IHtcbiAgICBhZGQ6IHtib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgIHJlbW92ZToge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgdXBkYXRlR3JvdXA6IHtib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgIHVwZGF0ZVRpbWU6IHtib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgIF9fdHlwZV9fOiB7Ym9vbGVhbiwgb2JqZWN0fVxuICB9LFxuICBlbmQ6IHtudW1iZXIsIGRhdGUsIHN0cmluZywgbW9tZW50fSxcbiAgZm9ybWF0OiB7XG4gICAgbWlub3JMYWJlbHM6IHtcbiAgICAgIG1pbGxpc2Vjb25kOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBzZWNvbmQ6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIG1pbnV0ZToge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgaG91cjoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgd2Vla2RheToge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgZGF5OiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBtb250aDoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgeWVhcjoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgX190eXBlX186IHtvYmplY3R9XG4gICAgfSxcbiAgICBtYWpvckxhYmVsczoge1xuICAgICAgbWlsbGlzZWNvbmQ6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIHNlY29uZDoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgbWludXRlOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBob3VyOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICB3ZWVrZGF5OiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBkYXk6IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICAgIG1vbnRoOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICB5ZWFyOiB7c3RyaW5nLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICBfX3R5cGVfXzoge29iamVjdH1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7b2JqZWN0fVxuICB9LFxuICBtb21lbnQ6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgZ3JvdXBPcmRlcjoge3N0cmluZywgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIGdyb3VwRWRpdGFibGU6IHtcblx0IGFkZDoge2Jvb2xlYW4sICd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG5cdCByZW1vdmU6IHtib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuXHQgb3JkZXI6IHtib29sZWFuLCAndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuXHQgX190eXBlX186IHtib29sZWFuLCBvYmplY3R9XG4gIH0sXG4gIGdyb3VwT3JkZXJTd2FwOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIGhlaWdodDoge3N0cmluZywgbnVtYmVyfSxcbiAgaGlkZGVuRGF0ZXM6IHtcbiAgICBzdGFydDoge2RhdGUsIG51bWJlciwgc3RyaW5nLCBtb21lbnR9LFxuICAgIGVuZDoge2RhdGUsIG51bWJlciwgc3RyaW5nLCBtb21lbnR9LFxuICAgIHJlcGVhdDoge3N0cmluZ30sXG4gICAgX190eXBlX186IHtvYmplY3QsIGFycmF5fVxuICB9LFxuICBsb2NhbGU6e3N0cmluZ30sXG4gIGxvY2FsZXM6e1xuICAgIF9fdHlwZV9fOiB7b2JqZWN0fVxuICB9LFxuICBtYXJnaW46IHtcbiAgICBheGlzOiB7bnVtYmVyfSxcbiAgICBpdGVtOiB7XG4gICAgICBob3Jpem9udGFsOiB7bnVtYmVyLCd1bmRlZmluZWQnOiAndW5kZWZpbmVkJ30sXG4gICAgICB2ZXJ0aWNhbDoge251bWJlciwndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgICAgX190eXBlX186IHtvYmplY3QsbnVtYmVyfVxuICAgIH0sXG4gICAgX190eXBlX186IHtvYmplY3QsbnVtYmVyfVxuICB9LFxuICBtYXg6IHtkYXRlLCBudW1iZXIsIHN0cmluZywgbW9tZW50fSxcbiAgbWF4SGVpZ2h0OiB7bnVtYmVyLCBzdHJpbmd9LFxuICBtaW46IHtkYXRlLCBudW1iZXIsIHN0cmluZywgbW9tZW50fSxcbiAgbWluSGVpZ2h0OiB7bnVtYmVyLCBzdHJpbmd9LFxuICBtb3ZlYWJsZToge2Jvb2xlYW59LFxuICBtdWx0aXNlbGVjdDoge2Jvb2xlYW59LFxuICBvbkFkZDogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvblVwZGF0ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvbk1vdmU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgb25Nb3Zpbmc6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgb25SZW1vdmU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgb25BZGRHcm91cDogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvbk1vdmVHcm91cDogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICBvblJlbW92ZUdyb3VwOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9yZGVyOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIG9yaWVudGF0aW9uOiB7XG4gICAgYXhpczoge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgIGl0ZW06IHtzdHJpbmcsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICBfX3R5cGVfXzoge3N0cmluZywgb2JqZWN0fVxuICB9LFxuICBzZWxlY3RhYmxlOiB7Ym9vbGVhbn0sXG4gIHNob3dDdXJyZW50VGltZToge2Jvb2xlYW59LFxuICBzaG93TWFqb3JMYWJlbHM6IHtib29sZWFufSxcbiAgc2hvd01pbm9yTGFiZWxzOiB7Ym9vbGVhbn0sXG4gIHN0YWNrOiB7Ym9vbGVhbn0sXG4gIHNuYXA6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nLCAnbnVsbCc6ICdudWxsJ30sXG4gIHN0YXJ0OiB7ZGF0ZSwgbnVtYmVyLCBzdHJpbmcsIG1vbWVudH0sXG4gIHRlbXBsYXRlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gIGdyb3VwVGVtcGxhdGU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgdGltZUF4aXM6IHtcbiAgICBzY2FsZToge3N0cmluZywndW5kZWZpbmVkJzogJ3VuZGVmaW5lZCd9LFxuICAgIHN0ZXA6IHtudW1iZXIsJ3VuZGVmaW5lZCc6ICd1bmRlZmluZWQnfSxcbiAgICBfX3R5cGVfXzoge29iamVjdH1cbiAgfSxcbiAgdHlwZToge3N0cmluZ30sXG4gIHdpZHRoOiB7c3RyaW5nLCBudW1iZXJ9LFxuICB6b29tYWJsZToge2Jvb2xlYW59LFxuICB6b29tS2V5OiB7c3RyaW5nOiBbJ2N0cmxLZXknLCAnYWx0S2V5JywgJ21ldGFLZXknLCAnJ119LFxuICB6b29tTWF4OiB7bnVtYmVyfSxcbiAgem9vbU1pbjoge251bWJlcn0sXG5cbiAgX190eXBlX186IHtvYmplY3R9XG59O1xuXG5sZXQgY29uZmlndXJlT3B0aW9ucyA9IHtcbiAgZ2xvYmFsOiB7XG4gICAgYWxpZ246ICBbJ2NlbnRlcicsICdsZWZ0JywgJ3JpZ2h0J10sXG4gICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICB0aHJvdHRsZVJlZHJhdzogWzEwLCAwLCAxMDAwLCAxMF0sXG4gICAgY2xpY2tUb1VzZTogZmFsc2UsXG4gICAgLy8gZGF0YUF0dHJpYnV0ZXM6IFsnYWxsJ10sIC8vIEZJWE1FOiBjYW4gYmUgJ2FsbCcgb3Igc3RyaW5nW11cbiAgICBlZGl0YWJsZToge1xuICAgICAgYWRkOiBmYWxzZSxcbiAgICAgIHJlbW92ZTogZmFsc2UsXG4gICAgICB1cGRhdGVHcm91cDogZmFsc2UsXG4gICAgICB1cGRhdGVUaW1lOiBmYWxzZVxuICAgIH0sXG4gICAgZW5kOiAnJyxcbiAgICBmb3JtYXQ6IHtcbiAgICAgIG1pbm9yTGFiZWxzOiB7XG4gICAgICAgIG1pbGxpc2Vjb25kOidTU1MnLFxuICAgICAgICBzZWNvbmQ6ICAgICAncycsXG4gICAgICAgIG1pbnV0ZTogICAgICdISDptbScsXG4gICAgICAgIGhvdXI6ICAgICAgICdISDptbScsXG4gICAgICAgIHdlZWtkYXk6ICAgICdkZGQgRCcsXG4gICAgICAgIGRheTogICAgICAgICdEJyxcbiAgICAgICAgbW9udGg6ICAgICAgJ01NTScsXG4gICAgICAgIHllYXI6ICAgICAgICdZWVlZJ1xuICAgICAgfSxcbiAgICAgIG1ham9yTGFiZWxzOiB7XG4gICAgICAgIG1pbGxpc2Vjb25kOidISDptbTpzcycsXG4gICAgICAgIHNlY29uZDogICAgICdEIE1NTU0gSEg6bW0nLFxuICAgICAgICBtaW51dGU6ICAgICAnZGRkIEQgTU1NTScsXG4gICAgICAgIGhvdXI6ICAgICAgICdkZGQgRCBNTU1NJyxcbiAgICAgICAgd2Vla2RheTogICAgJ01NTU0gWVlZWScsXG4gICAgICAgIGRheTogICAgICAgICdNTU1NIFlZWVknLFxuICAgICAgICBtb250aDogICAgICAnWVlZWScsXG4gICAgICAgIHllYXI6ICAgICAgICcnXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vZ3JvdXBPcmRlcjoge3N0cmluZywgJ2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgZ3JvdXBzRHJhZ2dhYmxlOiBmYWxzZSxcbiAgICBoZWlnaHQ6ICcnLFxuICAgIC8vaGlkZGVuRGF0ZXM6IHtvYmplY3QsIGFycmF5fSxcbiAgICBsb2NhbGU6ICcnLFxuICAgIG1hcmdpbjoge1xuICAgICAgYXhpczogWzIwLCAwLCAxMDAsIDFdLFxuICAgICAgaXRlbToge1xuICAgICAgICBob3Jpem9udGFsOiBbMTAsIDAsIDEwMCwgMV0sXG4gICAgICAgIHZlcnRpY2FsOiBbMTAsIDAsIDEwMCwgMV1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1heDogJycsXG4gICAgbWF4SGVpZ2h0OiAnJyxcbiAgICBtaW46ICcnLFxuICAgIG1pbkhlaWdodDogJycsXG4gICAgbW92ZWFibGU6IGZhbHNlLFxuICAgIG11bHRpc2VsZWN0OiBmYWxzZSxcbiAgICAvL29uQWRkOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgLy9vblVwZGF0ZTogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgIC8vb25Nb3ZlOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgLy9vbk1vdmluZzogeydmdW5jdGlvbic6ICdmdW5jdGlvbid9LFxuICAgIC8vb25SZW5hbWU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAvL29yZGVyOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJ30sXG4gICAgb3JpZW50YXRpb246IHtcbiAgICAgIGF4aXM6IFsnYm90aCcsICdib3R0b20nLCAndG9wJ10sXG4gICAgICBpdGVtOiBbJ2JvdHRvbScsICd0b3AnXVxuICAgIH0sXG4gICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICBzaG93Q3VycmVudFRpbWU6IGZhbHNlLFxuICAgIHNob3dNYWpvckxhYmVsczogdHJ1ZSxcbiAgICBzaG93TWlub3JMYWJlbHM6IHRydWUsXG4gICAgc3RhY2s6IHRydWUsXG4gICAgLy9zbmFwOiB7J2Z1bmN0aW9uJzogJ2Z1bmN0aW9uJywgbmFkYX0sXG4gICAgc3RhcnQ6ICcnLFxuICAgIC8vdGVtcGxhdGU6IHsnZnVuY3Rpb24nOiAnZnVuY3Rpb24nfSxcbiAgICAvL3RpbWVBeGlzOiB7XG4gICAgLy8gIHNjYWxlOiBbJ21pbGxpc2Vjb25kJywgJ3NlY29uZCcsICdtaW51dGUnLCAnaG91cicsICd3ZWVrZGF5JywgJ2RheScsICdtb250aCcsICd5ZWFyJ10sXG4gICAgLy8gIHN0ZXA6IFsxLCAxLCAxMCwgMV1cbiAgICAvL30sXG4gICAgdHlwZTogWydib3gnLCAncG9pbnQnLCAncmFuZ2UnLCAnYmFja2dyb3VuZCddLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgem9vbWFibGU6IHRydWUsXG4gICAgem9vbUtleTogWydjdHJsS2V5JywgJ2FsdEtleScsICdtZXRhS2V5JywgJyddLFxuICAgIHpvb21NYXg6IFszMTUzNjAwMDAwMDAwMDAsIDEwLCAzMTUzNjAwMDAwMDAwMDAsIDFdLFxuICAgIHpvb21NaW46IFsxMCwgMTAsIDMxNTM2MDAwMDAwMDAwMCwgMV1cbiAgfVxufTtcblxuZXhwb3J0IHthbGxPcHRpb25zLCBjb25maWd1cmVPcHRpb25zfTsiXX0=
},{}],46:[function(require,module,exports){
// utility functions

// first check if moment.js is already loaded in the browser window, if so,
// use this instance. Else, load via commonjs.

'use strict';

var moment = require('./module/moment');
var uuid = require('./module/uuid');

/**
 * Test whether given object is a number
 * @param {*} object
 * @return {Boolean} isNumber
 */
exports.isNumber = function (object) {
  return object instanceof Number || typeof object == 'number';
};

/**
 * Remove everything in the DOM object
 * @param DOMobject
 */
exports.recursiveDOMDelete = function (DOMobject) {
  if (DOMobject) {
    while (DOMobject.hasChildNodes() === true) {
      exports.recursiveDOMDelete(DOMobject.firstChild);
      DOMobject.removeChild(DOMobject.firstChild);
    }
  }
};

/**
 * this function gives you a range between 0 and 1 based on the min and max values in the set, the total sum of all values and the current value.
 *
 * @param min
 * @param max
 * @param total
 * @param value
 * @returns {number}
 */
exports.giveRange = function (min, max, total, value) {
  if (max == min) {
    return 0.5;
  } else {
    var scale = 1 / (max - min);
    return Math.max(0, (value - min) * scale);
  }
};

/**
 * Test whether given object is a string
 * @param {*} object
 * @return {Boolean} isString
 */
exports.isString = function (object) {
  return object instanceof String || typeof object == 'string';
};

/**
 * Test whether given object is a Date, or a String containing a Date
 * @param {Date | String} object
 * @return {Boolean} isDate
 */
exports.isDate = function (object) {
  if (object instanceof Date) {
    return true;
  } else if (exports.isString(object)) {
    // test whether this string contains a date
    var match = ASPDateRegex.exec(object);
    if (match) {
      return true;
    } else if (!isNaN(Date.parse(object))) {
      return true;
    }
  }

  return false;
};

/**
 * Create a semi UUID
 * source: http://stackoverflow.com/a/105074/1262753
 * @return {String} uuid
 */
exports.randomUUID = function () {
  return uuid.v4();
};

/**
 * assign all keys of an object that are not nested objects to a certain value (used for color objects).
 * @param obj
 * @param value
 */
exports.assignAllKeys = function (obj, value) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      if (typeof obj[prop] !== 'object') {
        obj[prop] = value;
      }
    }
  }
};

/**
 * Fill an object with a possibly partially defined other object. Only copies values if the a object has an object requiring values.
 * That means an object is not created on a property if only the b object has it.
 * @param obj
 * @param value
 */
exports.fillIfDefined = function (a, b) {
  var allowDeletion = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

  for (var prop in a) {
    if (b[prop] !== undefined) {
      if (typeof b[prop] !== 'object') {
        if ((b[prop] === undefined || b[prop] === null) && a[prop] !== undefined && allowDeletion === true) {
          delete a[prop];
        } else {
          a[prop] = b[prop];
        }
      } else {
        if (typeof a[prop] === 'object') {
          exports.fillIfDefined(a[prop], b[prop], allowDeletion);
        }
      }
    }
  }
};

/**
 * Extend object a with the properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.protoExtend = function (a, b) {
  for (var i = 1; i < arguments.length; i++) {
    var other = arguments[i];
    for (var prop in other) {
      a[prop] = other[prop];
    }
  }
  return a;
};

/**
 * Extend object a with the properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Object} a
 * @param {... Object} b
 * @return {Object} a
 */
exports.extend = function (a, b) {
  for (var i = 1; i < arguments.length; i++) {
    var other = arguments[i];
    for (var prop in other) {
      if (other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveExtend = function (props, a, b) {
  if (!Array.isArray(props)) {
    throw new Error('Array with property names expected as first argument');
  }

  for (var i = 2; i < arguments.length; i++) {
    var other = arguments[i];

    for (var p = 0; p < props.length; p++) {
      var prop = props[p];
      if (other.hasOwnProperty(prop)) {
        a[prop] = other[prop];
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveDeepExtend = function (props, a, b) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }
  for (var i = 2; i < arguments.length; i++) {
    var other = arguments[i];
    for (var p = 0; p < props.length; p++) {
      var prop = props[p];
      if (other.hasOwnProperty(prop)) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop], false, allowDeletion);
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        } else if (Array.isArray(b[prop])) {
          throw new TypeError('Arrays are not supported by deepExtend');
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      }
    }
  }
  return a;
};

/**
 * Extend object a with selected properties of object b or a series of objects
 * Only properties with defined values are copied
 * @param {Array.<String>} props
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 */
exports.selectiveNotDeepExtend = function (props, a, b) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

  // TODO: add support for Arrays to deepExtend
  if (Array.isArray(b)) {
    throw new TypeError('Arrays are not supported by deepExtend');
  }
  for (var prop in b) {
    if (b.hasOwnProperty(prop)) {
      if (props.indexOf(prop) == -1) {
        if (b[prop] && b[prop].constructor === Object) {
          if (a[prop] === undefined) {
            a[prop] = {};
          }
          if (a[prop].constructor === Object) {
            exports.deepExtend(a[prop], b[prop]);
          } else {
            if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
              delete a[prop];
            } else {
              a[prop] = b[prop];
            }
          }
        } else if (Array.isArray(b[prop])) {
          a[prop] = [];
          for (var i = 0; i < b[prop].length; i++) {
            a[prop].push(b[prop][i]);
          }
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      }
    }
  }
  return a;
};

/**
 * Deep extend an object a with the properties of object b
 * @param {Object} a
 * @param {Object} b
 * @param [Boolean] protoExtend --> optional parameter. If true, the prototype values will also be extended.
 *                                  (ie. the options objects that inherit from others will also get the inherited options)
 * @param [Boolean] global      --> optional parameter. If true, the values of fields that are null will not deleted
 * @returns {Object}
 */
exports.deepExtend = function (a, b, protoExtend, allowDeletion) {
  for (var prop in b) {
    if (b.hasOwnProperty(prop) || protoExtend === true) {
      if (b[prop] && b[prop].constructor === Object) {
        if (a[prop] === undefined) {
          a[prop] = {};
        }
        if (a[prop].constructor === Object) {
          exports.deepExtend(a[prop], b[prop], protoExtend);
        } else {
          if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
            delete a[prop];
          } else {
            a[prop] = b[prop];
          }
        }
      } else if (Array.isArray(b[prop])) {
        a[prop] = [];
        for (var i = 0; i < b[prop].length; i++) {
          a[prop].push(b[prop][i]);
        }
      } else {
        if (b[prop] === null && a[prop] !== undefined && allowDeletion === true) {
          delete a[prop];
        } else {
          a[prop] = b[prop];
        }
      }
    }
  }
  return a;
};

/**
 * Test whether all elements in two arrays are equal.
 * @param {Array} a
 * @param {Array} b
 * @return {boolean} Returns true if both arrays have the same length and same
 *                   elements.
 */
exports.equalArray = function (a, b) {
  if (a.length != b.length) return false;

  for (var i = 0, len = a.length; i < len; i++) {
    if (a[i] != b[i]) return false;
  }

  return true;
};

/**
 * Convert an object to another type
 * @param {Boolean | Number | String | Date | Moment | Null | undefined} object
 * @param {String | undefined} type   Name of the type. Available types:
 *                                    'Boolean', 'Number', 'String',
 *                                    'Date', 'Moment', ISODate', 'ASPDate'.
 * @return {*} object
 * @throws Error
 */
exports.convert = function (object, type) {
  var match;

  if (object === undefined) {
    return undefined;
  }
  if (object === null) {
    return null;
  }

  if (!type) {
    return object;
  }
  if (!(typeof type === 'string') && !(type instanceof String)) {
    throw new Error('Type must be a string');
  }

  //noinspection FallthroughInSwitchStatementJS
  switch (type) {
    case 'boolean':
    case 'Boolean':
      return Boolean(object);

    case 'number':
    case 'Number':
      return Number(object.valueOf());

    case 'string':
    case 'String':
      return String(object);

    case 'Date':
      if (exports.isNumber(object)) {
        return new Date(object);
      }
      if (object instanceof Date) {
        return new Date(object.valueOf());
      } else if (moment.isMoment(object)) {
        return new Date(object.valueOf());
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])); // parse number
        } else {
            return moment(object).toDate(); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
        }

    case 'Moment':
      if (exports.isNumber(object)) {
        return moment(object);
      }
      if (object instanceof Date) {
        return moment(object.valueOf());
      } else if (moment.isMoment(object)) {
        return moment(object);
      }
      if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return moment(Number(match[1])); // parse number
        } else {
            return moment(object); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type Date');
        }

    case 'ISODate':
      if (exports.isNumber(object)) {
        return new Date(object);
      } else if (object instanceof Date) {
        return object.toISOString();
      } else if (moment.isMoment(object)) {
        return object.toDate().toISOString();
      } else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        if (match) {
          // object is an ASP date
          return new Date(Number(match[1])).toISOString(); // parse number
        } else {
            return new Date(object).toISOString(); // parse string
          }
      } else {
          throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ISODate');
        }

    case 'ASPDate':
      if (exports.isNumber(object)) {
        return '/Date(' + object + ')/';
      } else if (object instanceof Date) {
        return '/Date(' + object.valueOf() + ')/';
      } else if (exports.isString(object)) {
        match = ASPDateRegex.exec(object);
        var value;
        if (match) {
          // object is an ASP date
          value = new Date(Number(match[1])).valueOf(); // parse number
        } else {
            value = new Date(object).valueOf(); // parse string
          }
        return '/Date(' + value + ')/';
      } else {
        throw new Error('Cannot convert object of type ' + exports.getType(object) + ' to type ASPDate');
      }

    default:
      throw new Error('Unknown type "' + type + '"');
  }
};

// parse ASP.Net Date pattern,
// for example '/Date(1198908717056)/' or '/Date(1198908717056-0700)/'
// code from http://momentjs.com/
var ASPDateRegex = /^\/?Date\((\-?\d+)/i;

/**
 * Get the type of an object, for example exports.getType([]) returns 'Array'
 * @param {*} object
 * @return {String} type
 */
exports.getType = function (object) {
  var type = typeof object;

  if (type == 'object') {
    if (object === null) {
      return 'null';
    }
    if (object instanceof Boolean) {
      return 'Boolean';
    }
    if (object instanceof Number) {
      return 'Number';
    }
    if (object instanceof String) {
      return 'String';
    }
    if (Array.isArray(object)) {
      return 'Array';
    }
    if (object instanceof Date) {
      return 'Date';
    }
    return 'Object';
  } else if (type == 'number') {
    return 'Number';
  } else if (type == 'boolean') {
    return 'Boolean';
  } else if (type == 'string') {
    return 'String';
  } else if (type === undefined) {
    return 'undefined';
  }

  return type;
};

/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr
 * @param newValue
 * @returns {Array}
 */
exports.copyAndExtendArray = function (arr, newValue) {
  var newArr = [];
  for (var i = 0; i < arr.length; i++) {
    newArr.push(arr[i]);
  }
  newArr.push(newValue);
  return newArr;
};

/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr
 * @param newValue
 * @returns {Array}
 */
exports.copyArray = function (arr) {
  var newArr = [];
  for (var i = 0; i < arr.length; i++) {
    newArr.push(arr[i]);
  }
  return newArr;
};

/**
 * Retrieve the absolute left value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} left        The absolute left position of this element
 *                              in the browser page.
 */
exports.getAbsoluteLeft = function (elem) {
  return elem.getBoundingClientRect().left;
};

/**
 * Retrieve the absolute top value of a DOM element
 * @param {Element} elem        A dom element, for example a div
 * @return {number} top        The absolute top position of this element
 *                              in the browser page.
 */
exports.getAbsoluteTop = function (elem) {
  return elem.getBoundingClientRect().top;
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
exports.addClassName = function (elem, className) {
  var classes = elem.className.split(' ');
  if (classes.indexOf(className) == -1) {
    classes.push(className); // add the class to the array
    elem.className = classes.join(' ');
  }
};

/**
 * add a className to the given elements style
 * @param {Element} elem
 * @param {String} className
 */
exports.removeClassName = function (elem, className) {
  var classes = elem.className.split(' ');
  var index = classes.indexOf(className);
  if (index != -1) {
    classes.splice(index, 1); // remove the class from the array
    elem.className = classes.join(' ');
  }
};

/**
 * For each method for both arrays and objects.
 * In case of an array, the built-in Array.forEach() is applied.
 * In case of an Object, the method loops over all properties of the object.
 * @param {Object | Array} object   An Object or Array
 * @param {function} callback       Callback method, called for each item in
 *                                  the object or array with three parameters:
 *                                  callback(value, index, object)
 */
exports.forEach = function (object, callback) {
  var i, len;
  if (Array.isArray(object)) {
    // array
    for (i = 0, len = object.length; i < len; i++) {
      callback(object[i], i, object);
    }
  } else {
    // object
    for (i in object) {
      if (object.hasOwnProperty(i)) {
        callback(object[i], i, object);
      }
    }
  }
};

/**
 * Convert an object into an array: all objects properties are put into the
 * array. The resulting array is unordered.
 * @param {Object} object
 * @param {Array} array
 */
exports.toArray = function (object) {
  var array = [];

  for (var prop in object) {
    if (object.hasOwnProperty(prop)) array.push(object[prop]);
  }

  return array;
};

/**
 * Update a property in an object
 * @param {Object} object
 * @param {String} key
 * @param {*} value
 * @return {Boolean} changed
 */
exports.updateProperty = function (object, key, value) {
  if (object[key] !== value) {
    object[key] = value;
    return true;
  } else {
    return false;
  }
};

/**
 * Throttle the given function to be only executed once every `wait` milliseconds
 * @param {function} fn
 * @param {number} wait    Time in milliseconds
 * @returns {function} Returns the throttled function
 */
exports.throttle = function (fn, wait) {
  var timeout = null;
  var needExecution = false;

  return function throttled() {
    if (!timeout) {
      needExecution = false;
      fn();

      timeout = setTimeout(function () {
        timeout = null;
        if (needExecution) {
          throttled();
        }
      }, wait);
    } else {
      needExecution = true;
    }
  };
};

/**
 * Add and event listener. Works for all browsers
 * @param {Element}     element    An html element
 * @param {string}      action     The action, for example "click",
 *                                 without the prefix "on"
 * @param {function}    listener   The callback function to be executed
 * @param {boolean}     [useCapture]
 */
exports.addEventListener = function (element, action, listener, useCapture) {
  if (element.addEventListener) {
    if (useCapture === undefined) useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.addEventListener(action, listener, useCapture);
  } else {
    element.attachEvent("on" + action, listener); // IE browsers
  }
};

/**
 * Remove an event listener from an element
 * @param {Element}     element         An html dom element
 * @param {string}      action          The name of the event, for example "mousedown"
 * @param {function}    listener        The listener function
 * @param {boolean}     [useCapture]
 */
exports.removeEventListener = function (element, action, listener, useCapture) {
  if (element.removeEventListener) {
    // non-IE browsers
    if (useCapture === undefined) useCapture = false;

    if (action === "mousewheel" && navigator.userAgent.indexOf("Firefox") >= 0) {
      action = "DOMMouseScroll"; // For Firefox
    }

    element.removeEventListener(action, listener, useCapture);
  } else {
    // IE browsers
    element.detachEvent("on" + action, listener);
  }
};

/**
 * Cancels the event if it is cancelable, without stopping further propagation of the event.
 */
exports.preventDefault = function (event) {
  if (!event) event = window.event;

  if (event.preventDefault) {
    event.preventDefault(); // non-IE browsers
  } else {
      event.returnValue = false; // IE browsers
    }
};

/**
 * Get HTML element which is the target of the event
 * @param {Event} event
 * @return {Element} target element
 */
exports.getTarget = function (event) {
  // code from http://www.quirksmode.org/js/events_properties.html
  if (!event) {
    event = window.event;
  }

  var target;

  if (event.target) {
    target = event.target;
  } else if (event.srcElement) {
    target = event.srcElement;
  }

  if (target.nodeType != undefined && target.nodeType == 3) {
    // defeat Safari bug
    target = target.parentNode;
  }

  return target;
};

/**
 * Check if given element contains given parent somewhere in the DOM tree
 * @param {Element} element
 * @param {Element} parent
 */
exports.hasParent = function (element, parent) {
  var e = element;

  while (e) {
    if (e === parent) {
      return true;
    }
    e = e.parentNode;
  }

  return false;
};

exports.option = {};

/**
 * Convert a value into a boolean
 * @param {Boolean | function | undefined} value
 * @param {Boolean} [defaultValue]
 * @returns {Boolean} bool
 */
exports.option.asBoolean = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return value != false;
  }

  return defaultValue || null;
};

/**
 * Convert a value into a number
 * @param {Boolean | function | undefined} value
 * @param {Number} [defaultValue]
 * @returns {Number} number
 */
exports.option.asNumber = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return Number(value) || defaultValue || null;
  }

  return defaultValue || null;
};

/**
 * Convert a value into a string
 * @param {String | function | undefined} value
 * @param {String} [defaultValue]
 * @returns {String} str
 */
exports.option.asString = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (value != null) {
    return String(value);
  }

  return defaultValue || null;
};

/**
 * Convert a size or location into a string with pixels or a percentage
 * @param {String | Number | function | undefined} value
 * @param {String} [defaultValue]
 * @returns {String} size
 */
exports.option.asSize = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  if (exports.isString(value)) {
    return value;
  } else if (exports.isNumber(value)) {
    return value + 'px';
  } else {
    return defaultValue || null;
  }
};

/**
 * Convert a value into a DOM element
 * @param {HTMLElement | function | undefined} value
 * @param {HTMLElement} [defaultValue]
 * @returns {HTMLElement | null} dom
 */
exports.option.asElement = function (value, defaultValue) {
  if (typeof value == 'function') {
    value = value();
  }

  return value || defaultValue || null;
};

/**
 * http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
 *
 * @param {String} hex
 * @returns {{r: *, g: *, b: *}} | 255 range
 */
exports.hexToRGB = function (hex) {
  // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, function (m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
};

/**
 * This function takes color in hex format or rgb() or rgba() format and overrides the opacity. Returns rgba() string.
 * @param color
 * @param opacity
 * @returns {*}
 */
exports.overrideOpacity = function (color, opacity) {
  if (color.indexOf("rgba") != -1) {
    return color;
  } else if (color.indexOf("rgb") != -1) {
    var rgb = color.substr(color.indexOf("(") + 1).replace(")", "").split(",");
    return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + opacity + ")";
  } else {
    var rgb = exports.hexToRGB(color);
    if (rgb == null) {
      return color;
    } else {
      return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + opacity + ")";
    }
  }
};

/**
 *
 * @param red     0 -- 255
 * @param green   0 -- 255
 * @param blue    0 -- 255
 * @returns {string}
 * @constructor
 */
exports.RGBToHex = function (red, green, blue) {
  return "#" + ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16).slice(1);
};

/**
 * Parse a color property into an object with border, background, and
 * highlight colors
 * @param {Object | String} color
 * @return {Object} colorObject
 */
exports.parseColor = function (color) {
  var c;
  if (exports.isString(color) === true) {
    if (exports.isValidRGB(color) === true) {
      var rgb = color.substr(4).substr(0, color.length - 5).split(',').map(function (value) {
        return parseInt(value);
      });
      color = exports.RGBToHex(rgb[0], rgb[1], rgb[2]);
    }
    if (exports.isValidHex(color) === true) {
      var hsv = exports.hexToHSV(color);
      var lighterColorHSV = { h: hsv.h, s: hsv.s * 0.8, v: Math.min(1, hsv.v * 1.02) };
      var darkerColorHSV = { h: hsv.h, s: Math.min(1, hsv.s * 1.25), v: hsv.v * 0.8 };
      var darkerColorHex = exports.HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);
      var lighterColorHex = exports.HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);
      c = {
        background: color,
        border: darkerColorHex,
        highlight: {
          background: lighterColorHex,
          border: darkerColorHex
        },
        hover: {
          background: lighterColorHex,
          border: darkerColorHex
        }
      };
    } else {
      c = {
        background: color,
        border: color,
        highlight: {
          background: color,
          border: color
        },
        hover: {
          background: color,
          border: color
        }
      };
    }
  } else {
    c = {};
    c.background = color.background || undefined;
    c.border = color.border || undefined;

    if (exports.isString(color.highlight)) {
      c.highlight = {
        border: color.highlight,
        background: color.highlight
      };
    } else {
      c.highlight = {};
      c.highlight.background = color.highlight && color.highlight.background || undefined;
      c.highlight.border = color.highlight && color.highlight.border || undefined;
    }

    if (exports.isString(color.hover)) {
      c.hover = {
        border: color.hover,
        background: color.hover
      };
    } else {
      c.hover = {};
      c.hover.background = color.hover && color.hover.background || undefined;
      c.hover.border = color.hover && color.hover.border || undefined;
    }
  }

  return c;
};

/**
 * http://www.javascripter.net/faq/rgb2hsv.htm
 *
 * @param red
 * @param green
 * @param blue
 * @returns {*}
 * @constructor
 */
exports.RGBToHSV = function (red, green, blue) {
  red = red / 255;green = green / 255;blue = blue / 255;
  var minRGB = Math.min(red, Math.min(green, blue));
  var maxRGB = Math.max(red, Math.max(green, blue));

  // Black-gray-white
  if (minRGB == maxRGB) {
    return { h: 0, s: 0, v: minRGB };
  }

  // Colors other than black-gray-white:
  var d = red == minRGB ? green - blue : blue == minRGB ? red - green : blue - red;
  var h = red == minRGB ? 3 : blue == minRGB ? 1 : 5;
  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;
  var saturation = (maxRGB - minRGB) / maxRGB;
  var value = maxRGB;
  return { h: hue, s: saturation, v: value };
};

var cssUtil = {
  // split a string with css styles into an object with key/values
  split: function split(cssText) {
    var styles = {};

    cssText.split(';').forEach(function (style) {
      if (style.trim() != '') {
        var parts = style.split(':');
        var key = parts[0].trim();
        var value = parts[1].trim();
        styles[key] = value;
      }
    });

    return styles;
  },

  // build a css text string from an object with key/values
  join: function join(styles) {
    return Object.keys(styles).map(function (key) {
      return key + ': ' + styles[key];
    }).join('; ');
  }
};

/**
 * Append a string with css styles to an element
 * @param {Element} element
 * @param {String} cssText
 */
exports.addCssText = function (element, cssText) {
  var currentStyles = cssUtil.split(element.style.cssText);
  var newStyles = cssUtil.split(cssText);
  var styles = exports.extend(currentStyles, newStyles);

  element.style.cssText = cssUtil.join(styles);
};

/**
 * Remove a string with css styles from an element
 * @param {Element} element
 * @param {String} cssText
 */
exports.removeCssText = function (element, cssText) {
  var styles = cssUtil.split(element.style.cssText);
  var removeStyles = cssUtil.split(cssText);

  for (var key in removeStyles) {
    if (removeStyles.hasOwnProperty(key)) {
      delete styles[key];
    }
  }

  element.style.cssText = cssUtil.join(styles);
};

/**
 * https://gist.github.com/mjijackson/5311256
 * @param h
 * @param s
 * @param v
 * @returns {{r: number, g: number, b: number}}
 * @constructor
 */
exports.HSVToRGB = function (h, s, v) {
  var r, g, b;

  var i = Math.floor(h * 6);
  var f = h * 6 - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);

  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;break;
    case 1:
      r = q, g = v, b = p;break;
    case 2:
      r = p, g = v, b = t;break;
    case 3:
      r = p, g = q, b = v;break;
    case 4:
      r = t, g = p, b = v;break;
    case 5:
      r = v, g = p, b = q;break;
  }

  return { r: Math.floor(r * 255), g: Math.floor(g * 255), b: Math.floor(b * 255) };
};

exports.HSVToHex = function (h, s, v) {
  var rgb = exports.HSVToRGB(h, s, v);
  return exports.RGBToHex(rgb.r, rgb.g, rgb.b);
};

exports.hexToHSV = function (hex) {
  var rgb = exports.hexToRGB(hex);
  return exports.RGBToHSV(rgb.r, rgb.g, rgb.b);
};

exports.isValidHex = function (hex) {
  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  return isOk;
};

exports.isValidRGB = function (rgb) {
  rgb = rgb.replace(" ", "");
  var isOk = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/i.test(rgb);
  return isOk;
};
exports.isValidRGBA = function (rgba) {
  rgba = rgba.replace(" ", "");
  var isOk = /rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(.{1,3})\)/i.test(rgba);
  return isOk;
};

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param referenceObject
 * @returns {*}
 */
exports.selectiveBridgeObject = function (fields, referenceObject) {
  if (typeof referenceObject == "object") {
    var objectTo = Object.create(referenceObject);
    for (var i = 0; i < fields.length; i++) {
      if (referenceObject.hasOwnProperty(fields[i])) {
        if (typeof referenceObject[fields[i]] == "object") {
          objectTo[fields[i]] = exports.bridgeObject(referenceObject[fields[i]]);
        }
      }
    }
    return objectTo;
  } else {
    return null;
  }
};

/**
 * This recursively redirects the prototype of JSON objects to the referenceObject
 * This is used for default options.
 *
 * @param referenceObject
 * @returns {*}
 */
exports.bridgeObject = function (referenceObject) {
  if (typeof referenceObject == "object") {
    var objectTo = Object.create(referenceObject);
    for (var i in referenceObject) {
      if (referenceObject.hasOwnProperty(i)) {
        if (typeof referenceObject[i] == "object") {
          objectTo[i] = exports.bridgeObject(referenceObject[i]);
        }
      }
    }
    return objectTo;
  } else {
    return null;
  }
};

/**
 * this is used to set the options of subobjects in the options object. A requirement of these subobjects
 * is that they have an 'enabled' element which is optional for the user but mandatory for the program.
 *
 * @param [object] mergeTarget | this is either this.options or the options used for the groups.
 * @param [object] options     | options
 * @param [String] option      | this is the option key in the options argument
 * @private
 */
exports.mergeOptions = function (mergeTarget, options, option) {
  var allowDeletion = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
  var globalOptions = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

  if (options[option] === null) {
    mergeTarget[option] = Object.create(globalOptions[option]);
  } else {
    if (options[option] !== undefined) {
      if (typeof options[option] === 'boolean') {
        mergeTarget[option].enabled = options[option];
      } else {
        if (options[option].enabled === undefined) {
          mergeTarget[option].enabled = true;
        }
        for (var prop in options[option]) {
          if (options[option].hasOwnProperty(prop)) {
            mergeTarget[option][prop] = options[option][prop];
          }
        }
      }
    }
  }
};

/**
 * This function does a binary search for a visible item in a sorted list. If we find a visible item, the code that uses
 * this function will then iterate in both directions over this sorted list to find all visible items.
 *
 * @param {Item[]} orderedItems       | Items ordered by start
 * @param {function} searchFunction   | -1 is lower, 0 is found, 1 is higher
 * @param {String} field
 * @param {String} field2
 * @returns {number}
 * @private
 */
exports.binarySearchCustom = function (orderedItems, searchFunction, field, field2) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;

  while (low <= high && iteration < maxIterations) {
    var middle = Math.floor((low + high) / 2);

    var item = orderedItems[middle];
    var value = field2 === undefined ? item[field] : item[field][field2];

    var searchResult = searchFunction(value);
    if (searchResult == 0) {
      // jihaa, found a visible item!
      return middle;
    } else if (searchResult == -1) {
      // it is too small --> increase low
      low = middle + 1;
    } else {
      // it is too big --> decrease high
      high = middle - 1;
    }

    iteration++;
  }

  return -1;
};

/**
 * This function does a binary search for a specific value in a sorted array. If it does not exist but is in between of
 * two values, we return either the one before or the one after, depending on user input
 * If it is found, we return the index, else -1.
 *
 * @param {Array} orderedItems
 * @param {{start: number, end: number}} target
 * @param {String} field
 * @param {String} sidePreference   'before' or 'after'
 * @returns {number}
 * @private
 */
exports.binarySearchValue = function (orderedItems, target, field, sidePreference) {
  var maxIterations = 10000;
  var iteration = 0;
  var low = 0;
  var high = orderedItems.length - 1;
  var prevValue, value, nextValue, middle;

  while (low <= high && iteration < maxIterations) {
    // get a new guess
    middle = Math.floor(0.5 * (high + low));
    prevValue = orderedItems[Math.max(0, middle - 1)][field];
    value = orderedItems[middle][field];
    nextValue = orderedItems[Math.min(orderedItems.length - 1, middle + 1)][field];

    if (value == target) {
      // we found the target
      return middle;
    } else if (prevValue < target && value > target) {
      // target is in between of the previous and the current
      return sidePreference == 'before' ? Math.max(0, middle - 1) : middle;
    } else if (value < target && nextValue > target) {
      // target is in between of the current and the next
      return sidePreference == 'before' ? middle : Math.min(orderedItems.length - 1, middle + 1);
    } else {
      // didnt find the target, we need to change our boundaries.
      if (value < target) {
        // it is too small --> increase low
        low = middle + 1;
      } else {
        // it is too big --> decrease high
        high = middle - 1;
      }
    }
    iteration++;
  }

  // didnt find anything. Return -1.
  return -1;
};

/*
 * Easing Functions - inspired from http://gizma.com/easing/
 * only considering the t value for the range [0, 1] => [0, 1]
 * https://gist.github.com/gre/1650294
 */
exports.easingFunctions = {
  // no easing, no acceleration
  linear: function linear(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function easeInQuad(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function easeOutQuad(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function easeInOutQuad(t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity
  easeInCubic: function easeInCubic(t) {
    return t * t * t;
  },
  // decelerating to zero velocity
  easeOutCubic: function easeOutCubic(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function easeInOutCubic(t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity
  easeInQuart: function easeInQuart(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuart: function easeOutQuart(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function easeInOutQuart(t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function easeInQuint(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function easeOutQuint(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function easeInOutQuint(t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9ub2RlX21vZHVsZXMvdmlzL2xpYi91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFNQSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUN4QyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7Ozs7Ozs7QUFPcEMsT0FBTyxDQUFDLFFBQVEsR0FBRyxVQUFVLE1BQU0sRUFBRTtBQUNuQyxTQUFRLE1BQU0sWUFBWSxNQUFNLElBQUksT0FBTyxNQUFNLElBQUksUUFBUSxDQUFFO0NBQ2hFLENBQUM7Ozs7OztBQU9GLE9BQU8sQ0FBQyxrQkFBa0IsR0FBRyxVQUFVLFNBQVMsRUFBRTtBQUNoRCxNQUFJLFNBQVMsRUFBRTtBQUNiLFdBQU8sU0FBUyxDQUFDLGFBQWEsRUFBRSxLQUFLLElBQUksRUFBRTtBQUN6QyxhQUFPLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2pELGVBQVMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQzdDO0dBQ0Y7Q0FDRixDQUFDOzs7Ozs7Ozs7OztBQVdGLE9BQU8sQ0FBQyxTQUFTLEdBQUcsVUFBVSxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDcEQsTUFBSSxHQUFHLElBQUksR0FBRyxFQUFFO0FBQ2QsV0FBTyxHQUFHLENBQUM7R0FDWixNQUNJO0FBQ0gsUUFBSSxLQUFLLEdBQUcsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLENBQUEsQUFBQyxDQUFDO0FBQzVCLFdBQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFBLEdBQUksS0FBSyxDQUFDLENBQUM7R0FDM0M7Q0FDRixDQUFBOzs7Ozs7O0FBT0QsT0FBTyxDQUFDLFFBQVEsR0FBRyxVQUFVLE1BQU0sRUFBRTtBQUNuQyxT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TUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksRUFBRTtBQUNwQyxRQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQ3RDLFVBQUksR0FBRyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxLQUFLLEVBQUU7QUFBRSxlQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQTtPQUFFLENBQUMsQ0FBQztBQUNsSCxXQUFLLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2xEO0FBQ0QsUUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksRUFBRTtBQUN0QyxVQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2xDLFVBQUksZUFBZSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7QUFDakYsVUFBSSxjQUFjLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FB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USxDQUFDLEdBQUcsQ0FBQztBQUNYLFNBQUssQ0FBQztBQUFFLE9BQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQUMsTUFBTTtBQUFBLEFBQ25DLFNBQUssQ0FBQztBQUFFLE9BQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQUMsTUFBTTtBQUFBLEFBQ25DLFNBQUssQ0FBQztBQUFFLE9BQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQUMsTUFBTTtBQUFBLEFBQ25DLFNBQUssQ0FBQztBQUFFLE9BQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQUMsTUFBTTtBQUFBLEFBQ25DLFNBQUssQ0FBQztBQUFFLE9BQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQUMsTUFBTTtBQUFBLEFBQ25DLFNBQUssQ0FBQztBQUFFLE9BQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQUMsTUFBTTtBQUFBLEdBQ3BDOztBQUVELFNBQU8sRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDO0NBQ25GLENBQUM7O0FBRUYsT0FBTyxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ3BDLE1BQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FB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RyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtHQUN4RTtDQUNGLENBQUMiLCJmaWxlIjoiL3Vzci9zcmMvYXBwL25vZGVfbW9kdWxlcy92aXMvbGliL3V0aWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4vLyBmaXJzdCBjaGVjayBpZiBtb21lbnQuanMgaXMgYWxyZWFkeSBsb2FkZWQgaW4gdGhlIGJyb3dzZXIgd2luZG93LCBpZiBzbyxcbi8vIHVzZSB0aGlzIGluc3RhbmNlLiBFbHNlLCBsb2FkIHZpYSBjb21tb25qcy5cblxuXG52YXIgbW9tZW50ID0gcmVxdWlyZSgnLi9tb2R1bGUvbW9tZW50Jyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJy4vbW9kdWxlL3V1aWQnKTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgbnVtYmVyXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNOdW1iZXJcbiAqL1xuZXhwb3J0cy5pc051bWJlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdHlwZW9mIG9iamVjdCA9PSAnbnVtYmVyJyk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGV2ZXJ5dGhpbmcgaW4gdGhlIERPTSBvYmplY3RcbiAqIEBwYXJhbSBET01vYmplY3RcbiAqL1xuZXhwb3J0cy5yZWN1cnNpdmVET01EZWxldGUgPSBmdW5jdGlvbiAoRE9Nb2JqZWN0KSB7XG4gIGlmIChET01vYmplY3QpIHtcbiAgICB3aGlsZSAoRE9Nb2JqZWN0Lmhhc0NoaWxkTm9kZXMoKSA9PT0gdHJ1ZSkge1xuICAgICAgZXhwb3J0cy5yZWN1cnNpdmVET01EZWxldGUoRE9Nb2JqZWN0LmZpcnN0Q2hpbGQpO1xuICAgICAgRE9Nb2JqZWN0LnJlbW92ZUNoaWxkKERPTW9iamVjdC5maXJzdENoaWxkKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogdGhpcyBmdW5jdGlvbiBnaXZlcyB5b3UgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEgYmFzZWQgb24gdGhlIG1pbiBhbmQgbWF4IHZhbHVlcyBpbiB0aGUgc2V0LCB0aGUgdG90YWwgc3VtIG9mIGFsbCB2YWx1ZXMgYW5kIHRoZSBjdXJyZW50IHZhbHVlLlxuICpcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqIEBwYXJhbSB0b3RhbFxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmdpdmVSYW5nZSA9IGZ1bmN0aW9uIChtaW4sIG1heCwgdG90YWwsIHZhbHVlKSB7XG4gIGlmIChtYXggPT0gbWluKSB7XG4gICAgcmV0dXJuIDAuNTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgc2NhbGUgPSAxIC8gKG1heCAtIG1pbik7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsICh2YWx1ZSAtIG1pbikgKiBzY2FsZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgc3RyaW5nXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gaXNTdHJpbmdcbiAqL1xuZXhwb3J0cy5pc1N0cmluZyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIG9iamVjdCA9PSAnc3RyaW5nJyk7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBnaXZlbiBvYmplY3QgaXMgYSBEYXRlLCBvciBhIFN0cmluZyBjb250YWluaW5nIGEgRGF0ZVxuICogQHBhcmFtIHtEYXRlIHwgU3RyaW5nfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlzRGF0ZVxuICovXG5leHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAvLyB0ZXN0IHdoZXRoZXIgdGhpcyBzdHJpbmcgY29udGFpbnMgYSBkYXRlXG4gICAgdmFyIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNOYU4oRGF0ZS5wYXJzZShvYmplY3QpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzZW1pIFVVSURcbiAqIHNvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA1MDc0LzEyNjI3NTNcbiAqIEByZXR1cm4ge1N0cmluZ30gdXVpZFxuICovXG5leHBvcnRzLnJhbmRvbVVVSUQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB1dWlkLnY0KCk7XG59O1xuXG4vKipcbiAqIGFzc2lnbiBhbGwga2V5cyBvZiBhbiBvYmplY3QgdGhhdCBhcmUgbm90IG5lc3RlZCBvYmplY3RzIHRvIGEgY2VydGFpbiB2YWx1ZSAodXNlZCBmb3IgY29sb3Igb2JqZWN0cykuXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0cy5hc3NpZ25BbGxLZXlzID0gZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBpZiAodHlwZW9mIG9ialtwcm9wXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgb2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBGaWxsIGFuIG9iamVjdCB3aXRoIGEgcG9zc2libHkgcGFydGlhbGx5IGRlZmluZWQgb3RoZXIgb2JqZWN0LiBPbmx5IGNvcGllcyB2YWx1ZXMgaWYgdGhlIGEgb2JqZWN0IGhhcyBhbiBvYmplY3QgcmVxdWlyaW5nIHZhbHVlcy5cbiAqIFRoYXQgbWVhbnMgYW4gb2JqZWN0IGlzIG5vdCBjcmVhdGVkIG9uIGEgcHJvcGVydHkgaWYgb25seSB0aGUgYiBvYmplY3QgaGFzIGl0LlxuICogQHBhcmFtIG9ialxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydHMuZmlsbElmRGVmaW5lZCA9IGZ1bmN0aW9uIChhLCBiLCBhbGxvd0RlbGV0aW9uID0gZmFsc2UpIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBhKSB7XG4gICAgaWYgKGJbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBiW3Byb3BdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoKGJbcHJvcF0gPT09IHVuZGVmaW5lZCB8fCBiW3Byb3BdID09PSBudWxsKSAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQgJiYgYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhW3Byb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGV4cG9ydHMuZmlsbElmRGVmaW5lZChhW3Byb3BdLCBiW3Byb3BdLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHsuLi4gT2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqL1xuZXhwb3J0cy5wcm90b0V4dGVuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG90aGVyID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAodmFyIHByb3AgaW4gb3RoZXIpIHtcbiAgICAgIGFbcHJvcF0gPSBvdGhlcltwcm9wXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0gey4uLiBPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG90aGVyID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAodmFyIHByb3AgaW4gb3RoZXIpIHtcbiAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBhW3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiIG9yIGEgc2VyaWVzIG9mIG9iamVjdHNcbiAqIE9ubHkgcHJvcGVydGllcyB3aXRoIGRlZmluZWQgdmFsdWVzIGFyZSBjb3BpZWRcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHByb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICovXG5leHBvcnRzLnNlbGVjdGl2ZUV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wcywgYSwgYikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSB3aXRoIHByb3BlcnR5IG5hbWVzIGV4cGVjdGVkIGFzIGZpcnN0IGFyZ3VtZW50Jyk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcHJvcHMubGVuZ3RoOyBwKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbcF07XG4gICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgYVtwcm9wXSA9IG90aGVyW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqL1xuZXhwb3J0cy5zZWxlY3RpdmVEZWVwRXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzLCBhLCBiLCBhbGxvd0RlbGV0aW9uID0gZmFsc2UpIHtcbiAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmQnKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHByb3BzLmxlbmd0aDsgcCsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW3BdO1xuICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFbcHJvcF0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgZXhwb3J0cy5kZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIGZhbHNlLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJbcHJvcF0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIG9iamVjdCBhIHdpdGggc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgYiBvciBhIHNlcmllcyBvZiBvYmplY3RzXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqL1xuZXhwb3J0cy5zZWxlY3RpdmVOb3REZWVwRXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzLCBhLCBiLCBhbGxvd0RlbGV0aW9uID0gZmFsc2UpIHtcbiAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmQnKTtcbiAgfVxuICBmb3IgKHZhciBwcm9wIGluIGIpIHtcbiAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgaWYgKHByb3BzLmluZGV4T2YocHJvcCkgPT0gLTEpIHtcbiAgICAgICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGFbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBleHBvcnRzLmRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChiW3Byb3BdID09PSBudWxsKSAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQgJiYgYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBkZWxldGUgYVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICAgIGFbcHJvcF0gPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJbcHJvcF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFbcHJvcF0ucHVzaChiW3Byb3BdW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKChiW3Byb3BdID09PSBudWxsKSAmJiBhW3Byb3BdICE9PSB1bmRlZmluZWQgJiYgYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBEZWVwIGV4dGVuZCBhbiBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEBwYXJhbSBbQm9vbGVhbl0gcHJvdG9FeHRlbmQgLS0+IG9wdGlvbmFsIHBhcmFtZXRlci4gSWYgdHJ1ZSwgdGhlIHByb3RvdHlwZSB2YWx1ZXMgd2lsbCBhbHNvIGJlIGV4dGVuZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGllLiB0aGUgb3B0aW9ucyBvYmplY3RzIHRoYXQgaW5oZXJpdCBmcm9tIG90aGVycyB3aWxsIGFsc28gZ2V0IHRoZSBpbmhlcml0ZWQgb3B0aW9ucylcbiAqIEBwYXJhbSBbQm9vbGVhbl0gZ2xvYmFsICAgICAgLS0+IG9wdGlvbmFsIHBhcmFtZXRlci4gSWYgdHJ1ZSwgdGhlIHZhbHVlcyBvZiBmaWVsZHMgdGhhdCBhcmUgbnVsbCB3aWxsIG5vdCBkZWxldGVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnRzLmRlZXBFeHRlbmQgPSBmdW5jdGlvbiAoYSwgYiwgcHJvdG9FeHRlbmQsIGFsbG93RGVsZXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiKSB7XG4gICAgaWYgKGIuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgcHJvdG9FeHRlbmQgPT09IHRydWUpIHtcbiAgICAgIGlmIChiW3Byb3BdICYmIGJbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBpZiAoYVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICBleHBvcnRzLmRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSwgcHJvdG9FeHRlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICgoYltwcm9wXSA9PT0gbnVsbCkgJiYgYVtwcm9wXSAhPT0gdW5kZWZpbmVkICYmIGFsbG93RGVsZXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJbcHJvcF0pKSB7XG4gICAgICAgIGFbcHJvcF0gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiW3Byb3BdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYVtwcm9wXS5wdXNoKGJbcHJvcF1baV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGJbcHJvcF0gPT09IG51bGwpICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZCAmJiBhbGxvd0RlbGV0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgZGVsZXRlIGFbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYVtwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbGwgZWxlbWVudHMgaW4gdHdvIGFycmF5cyBhcmUgZXF1YWwuXG4gKiBAcGFyYW0ge0FycmF5fSBhXG4gKiBAcGFyYW0ge0FycmF5fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYm90aCBhcnJheXMgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYW5kIHNhbWVcbiAqICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLlxuICovXG5leHBvcnRzLmVxdWFsQXJyYXkgPSBmdW5jdGlvbiAoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhW2ldICE9IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCB0byBhbm90aGVyIHR5cGVcbiAqIEBwYXJhbSB7Qm9vbGVhbiB8IE51bWJlciB8IFN0cmluZyB8IERhdGUgfCBNb21lbnQgfCBOdWxsIHwgdW5kZWZpbmVkfSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nIHwgdW5kZWZpbmVkfSB0eXBlICAgTmFtZSBvZiB0aGUgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQm9vbGVhbicsICdOdW1iZXInLCAnU3RyaW5nJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0RhdGUnLCAnTW9tZW50JywgSVNPRGF0ZScsICdBU1BEYXRlJy5cbiAqIEByZXR1cm4geyp9IG9iamVjdFxuICogQHRocm93cyBFcnJvclxuICovXG5leHBvcnRzLmNvbnZlcnQgPSBmdW5jdGlvbiAob2JqZWN0LCB0eXBlKSB7XG4gIHZhciBtYXRjaDtcblxuICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghdHlwZSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgaWYgKCEodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSAmJiAhKHR5cGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgIHJldHVybiBCb29sZWFuKG9iamVjdCk7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ051bWJlcic6XG4gICAgICByZXR1cm4gTnVtYmVyKG9iamVjdC52YWx1ZU9mKCkpO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgcmV0dXJuIFN0cmluZyhvYmplY3QpO1xuXG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobW9tZW50LmlzTW9tZW50KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdC52YWx1ZU9mKCkpO1xuICAgICAgfVxuICAgICAgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIobWF0Y2hbMV0pKTsgLy8gcGFyc2UgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpLnRvRGF0ZSgpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICtcbiAgICAgICAgICAnIHRvIHR5cGUgRGF0ZScpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnTW9tZW50JzpcbiAgICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudChvYmplY3QudmFsdWVPZigpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG1vbWVudC5pc01vbWVudChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBtb21lbnQob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBvcnRzLmlzU3RyaW5nKG9iamVjdCkpIHtcbiAgICAgICAgbWF0Y2ggPSBBU1BEYXRlUmVnZXguZXhlYyhvYmplY3QpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAvLyBvYmplY3QgaXMgYW4gQVNQIGRhdGVcbiAgICAgICAgICByZXR1cm4gbW9tZW50KE51bWJlcihtYXRjaFsxXSkpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbW9tZW50KG9iamVjdCk7IC8vIHBhcnNlIHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdDYW5ub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnICsgZXhwb3J0cy5nZXRUeXBlKG9iamVjdCkgK1xuICAgICAgICAgICcgdG8gdHlwZSBEYXRlJyk7XG4gICAgICB9XG5cbiAgICBjYXNlICdJU09EYXRlJzpcbiAgICAgIGlmIChleHBvcnRzLmlzTnVtYmVyKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iamVjdCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG1vbWVudC5pc01vbWVudChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGV4cG9ydHMuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICBtYXRjaCA9IEFTUERhdGVSZWdleC5leGVjKG9iamVjdCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIC8vIG9iamVjdCBpcyBhbiBBU1AgZGF0ZVxuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIobWF0Y2hbMV0pKS50b0lTT1N0cmluZygpOyAvLyBwYXJzZSBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqZWN0KS50b0lTT1N0cmluZygpOyAvLyBwYXJzZSBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICtcbiAgICAgICAgICAnIHRvIHR5cGUgSVNPRGF0ZScpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnQVNQRGF0ZSc6XG4gICAgICBpZiAoZXhwb3J0cy5pc051bWJlcihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiAnL0RhdGUoJyArIG9iamVjdCArICcpLyc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnL0RhdGUoJyArIG9iamVjdC52YWx1ZU9mKCkgKyAnKS8nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhwb3J0cy5pc1N0cmluZyhvYmplY3QpKSB7XG4gICAgICAgIG1hdGNoID0gQVNQRGF0ZVJlZ2V4LmV4ZWMob2JqZWN0KTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAvLyBvYmplY3QgaXMgYW4gQVNQIGRhdGVcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKE51bWJlcihtYXRjaFsxXSkpLnZhbHVlT2YoKTsgLy8gcGFyc2UgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShvYmplY3QpLnZhbHVlT2YoKTsgLy8gcGFyc2Ugc3RyaW5nXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcvRGF0ZSgnICsgdmFsdWUgKyAnKS8nO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGNvbnZlcnQgb2JqZWN0IG9mIHR5cGUgJyArIGV4cG9ydHMuZ2V0VHlwZShvYmplY3QpICtcbiAgICAgICAgICAnIHRvIHR5cGUgQVNQRGF0ZScpO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlIFwiJyArIHR5cGUgKyAnXCInKTtcbiAgfVxufTtcblxuLy8gcGFyc2UgQVNQLk5ldCBEYXRlIHBhdHRlcm4sXG4vLyBmb3IgZXhhbXBsZSAnL0RhdGUoMTE5ODkwODcxNzA1NikvJyBvciAnL0RhdGUoMTE5ODkwODcxNzA1Ni0wNzAwKS8nXG4vLyBjb2RlIGZyb20gaHR0cDovL21vbWVudGpzLmNvbS9cbnZhciBBU1BEYXRlUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4vKipcbiAqIEdldCB0aGUgdHlwZSBvZiBhbiBvYmplY3QsIGZvciBleGFtcGxlIGV4cG9ydHMuZ2V0VHlwZShbXSkgcmV0dXJucyAnQXJyYXknXG4gKiBAcGFyYW0geyp9IG9iamVjdFxuICogQHJldHVybiB7U3RyaW5nfSB0eXBlXG4gKi9cbmV4cG9ydHMuZ2V0VHlwZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqZWN0O1xuXG4gIGlmICh0eXBlID09ICdvYmplY3QnKSB7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgcmV0dXJuICdTdHJpbmcnO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICByZXR1cm4gJ0FycmF5JztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnRGF0ZSc7XG4gICAgfVxuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxuICBlbHNlIGlmICh0eXBlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICdOdW1iZXInO1xuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuICdCb29sZWFuJztcbiAgfVxuICBlbHNlIGlmICh0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICdTdHJpbmcnO1xuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG5cbiAgcmV0dXJuIHR5cGU7XG59O1xuXG5cbi8qKlxuICogVXNlZCB0byBleHRlbmQgYW4gYXJyYXkgYW5kIGNvcHkgaXQuIFRoaXMgaXMgdXNlZCB0byBwcm9wYWdhdGUgcGF0aHMgcmVjdXJzaXZlbHkuXG4gKlxuICogQHBhcmFtIGFyclxuICogQHBhcmFtIG5ld1ZhbHVlXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmV4cG9ydHMuY29weUFuZEV4dGVuZEFycmF5ID0gZnVuY3Rpb24gKGFyciwgbmV3VmFsdWUpIHtcbiAgbGV0IG5ld0FyciA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIG5ld0Fyci5wdXNoKGFycltpXSk7XG4gIH1cbiAgbmV3QXJyLnB1c2gobmV3VmFsdWUpO1xuICByZXR1cm4gbmV3QXJyO1xufVxuXG4vKipcbiAqIFVzZWQgdG8gZXh0ZW5kIGFuIGFycmF5IGFuZCBjb3B5IGl0LiBUaGlzIGlzIHVzZWQgdG8gcHJvcGFnYXRlIHBhdGhzIHJlY3Vyc2l2ZWx5LlxuICpcbiAqIEBwYXJhbSBhcnJcbiAqIEBwYXJhbSBuZXdWYWx1ZVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5leHBvcnRzLmNvcHlBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgbGV0IG5ld0FyciA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIG5ld0Fyci5wdXNoKGFycltpXSk7XG4gIH1cbiAgcmV0dXJuIG5ld0Fycjtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWJzb2x1dGUgbGVmdCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gICAgICAgIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2XG4gKiBAcmV0dXJuIHtudW1iZXJ9IGxlZnQgICAgICAgIFRoZSBhYnNvbHV0ZSBsZWZ0IHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgYnJvd3NlciBwYWdlLlxuICovXG5leHBvcnRzLmdldEFic29sdXRlTGVmdCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSB0b3AgdmFsdWUgb2YgYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtICAgICAgICBBIGRvbSBlbGVtZW50LCBmb3IgZXhhbXBsZSBhIGRpdlxuICogQHJldHVybiB7bnVtYmVyfSB0b3AgICAgICAgIFRoZSBhYnNvbHV0ZSB0b3AgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBicm93c2VyIHBhZ2UuXG4gKi9cbmV4cG9ydHMuZ2V0QWJzb2x1dGVUb3AgPSBmdW5jdGlvbiAoZWxlbSkge1xuICByZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG59O1xuXG4vKipcbiAqIGFkZCBhIGNsYXNzTmFtZSB0byB0aGUgZ2l2ZW4gZWxlbWVudHMgc3R5bGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICovXG5leHBvcnRzLmFkZENsYXNzTmFtZSA9IGZ1bmN0aW9uIChlbGVtLCBjbGFzc05hbWUpIHtcbiAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPT0gLTEpIHtcbiAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTsgLy8gYWRkIHRoZSBjbGFzcyB0byB0aGUgYXJyYXlcbiAgICBlbGVtLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpO1xuICB9XG59O1xuXG4vKipcbiAqIGFkZCBhIGNsYXNzTmFtZSB0byB0aGUgZ2l2ZW4gZWxlbWVudHMgc3R5bGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxuICovXG5leHBvcnRzLnJlbW92ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uIChlbGVtLCBjbGFzc05hbWUpIHtcbiAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcbiAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpOyAvLyByZW1vdmUgdGhlIGNsYXNzIGZyb20gdGhlIGFycmF5XG4gICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgZWFjaCBtZXRob2QgZm9yIGJvdGggYXJyYXlzIGFuZCBvYmplY3RzLlxuICogSW4gY2FzZSBvZiBhbiBhcnJheSwgdGhlIGJ1aWx0LWluIEFycmF5LmZvckVhY2goKSBpcyBhcHBsaWVkLlxuICogSW4gY2FzZSBvZiBhbiBPYmplY3QsIHRoZSBtZXRob2QgbG9vcHMgb3ZlciBhbGwgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3QgfCBBcnJheX0gb2JqZWN0ICAgQW4gT2JqZWN0IG9yIEFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgICAgICBDYWxsYmFjayBtZXRob2QsIGNhbGxlZCBmb3IgZWFjaCBpdGVtIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb2JqZWN0IG9yIGFycmF5IHdpdGggdGhyZWUgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgb2JqZWN0KVxuICovXG5leHBvcnRzLmZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICB2YXIgaSxcbiAgICBsZW47XG4gIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAvLyBhcnJheVxuICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FsbGJhY2sob2JqZWN0W2ldLCBpLCBvYmplY3QpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBvYmplY3RcbiAgICBmb3IgKGkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtpXSwgaSwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgaW50byBhbiBhcnJheTogYWxsIG9iamVjdHMgcHJvcGVydGllcyBhcmUgcHV0IGludG8gdGhlXG4gKiBhcnJheS4gVGhlIHJlc3VsdGluZyBhcnJheSBpcyB1bm9yZGVyZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICovXG5leHBvcnRzLnRvQXJyYXkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHZhciBhcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgYXJyYXkucHVzaChvYmplY3RbcHJvcF0pO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYSBwcm9wZXJ0eSBpbiBhbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNoYW5nZWRcbiAqL1xuZXhwb3J0cy51cGRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKG9iamVjdFtrZXldICE9PSB2YWx1ZSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFRocm90dGxlIHRoZSBnaXZlbiBmdW5jdGlvbiB0byBiZSBvbmx5IGV4ZWN1dGVkIG9uY2UgZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0ICAgIFRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IFJldHVybnMgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICovXG5leHBvcnRzLnRocm90dGxlID0gZnVuY3Rpb24gKGZuLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgdmFyIG5lZWRFeGVjdXRpb24gPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24gdGhyb3R0bGVkICgpIHtcbiAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgIG5lZWRFeGVjdXRpb24gPSBmYWxzZTtcbiAgICAgIGZuKCk7XG5cbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKG5lZWRFeGVjdXRpb24pIHtcbiAgICAgICAgICB0aHJvdHRsZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgd2FpdClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBuZWVkRXhlY3V0aW9uID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIGFuZCBldmVudCBsaXN0ZW5lci4gV29ya3MgZm9yIGFsbCBicm93c2Vyc1xuICogQHBhcmFtIHtFbGVtZW50fSAgICAgZWxlbWVudCAgICBBbiBodG1sIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIGFjdGlvbiAgICAgVGhlIGFjdGlvbiwgZm9yIGV4YW1wbGUgXCJjbGlja1wiLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRob3V0IHRoZSBwcmVmaXggXCJvblwiXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSAgICBsaXN0ZW5lciAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICogQHBhcmFtIHtib29sZWFufSAgICAgW3VzZUNhcHR1cmVdXG4gKi9cbmV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgdXNlQ2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gXCJtb3VzZXdoZWVsXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+PSAwKSB7XG4gICAgICBhY3Rpb24gPSBcIkRPTU1vdXNlU2Nyb2xsXCI7ICAvLyBGb3IgRmlyZWZveFxuICAgIH1cblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGFjdGlvbiwgbGlzdGVuZXIpOyAgLy8gSUUgYnJvd3NlcnNcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9ICAgICBlbGVtZW50ICAgICAgICAgQW4gaHRtbCBkb20gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgYWN0aW9uICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCwgZm9yIGV4YW1wbGUgXCJtb3VzZWRvd25cIlxuICogQHBhcmFtIHtmdW5jdGlvbn0gICAgbGlzdGVuZXIgICAgICAgIFRoZSBsaXN0ZW5lciBmdW5jdGlvblxuICogQHBhcmFtIHtib29sZWFufSAgICAgW3VzZUNhcHR1cmVdXG4gKi9cbmV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAvLyBub24tSUUgYnJvd3NlcnNcbiAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgdXNlQ2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gXCJtb3VzZXdoZWVsXCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+PSAwKSB7XG4gICAgICBhY3Rpb24gPSBcIkRPTU1vdXNlU2Nyb2xsXCI7ICAvLyBGb3IgRmlyZWZveFxuICAgIH1cblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihhY3Rpb24sIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJRSBicm93c2Vyc1xuICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoXCJvblwiICsgYWN0aW9uLCBsaXN0ZW5lcik7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FuY2VscyB0aGUgZXZlbnQgaWYgaXQgaXMgY2FuY2VsYWJsZSwgd2l0aG91dCBzdG9wcGluZyBmdXJ0aGVyIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudC5cbiAqL1xuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoIWV2ZW50KVxuICAgIGV2ZW50ID0gd2luZG93LmV2ZW50O1xuXG4gIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7ICAvLyBub24tSUUgYnJvd3NlcnNcbiAgfVxuICBlbHNlIHtcbiAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlOyAgLy8gSUUgYnJvd3NlcnNcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgSFRNTCBlbGVtZW50IHdoaWNoIGlzIHRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7RWxlbWVudH0gdGFyZ2V0IGVsZW1lbnRcbiAqL1xuZXhwb3J0cy5nZXRUYXJnZXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gY29kZSBmcm9tIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICBpZiAoIWV2ZW50KSB7XG4gICAgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG4gIH1cblxuICB2YXIgdGFyZ2V0O1xuXG4gIGlmIChldmVudC50YXJnZXQpIHtcbiAgICB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIH1cbiAgZWxzZSBpZiAoZXZlbnQuc3JjRWxlbWVudCkge1xuICAgIHRhcmdldCA9IGV2ZW50LnNyY0VsZW1lbnQ7XG4gIH1cblxuICBpZiAodGFyZ2V0Lm5vZGVUeXBlICE9IHVuZGVmaW5lZCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMykge1xuICAgIC8vIGRlZmVhdCBTYWZhcmkgYnVnXG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBnaXZlbiBlbGVtZW50IGNvbnRhaW5zIGdpdmVuIHBhcmVudCBzb21ld2hlcmUgaW4gdGhlIERPTSB0cmVlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmV4cG9ydHMuaGFzUGFyZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCkge1xuICB2YXIgZSA9IGVsZW1lbnQ7XG5cbiAgd2hpbGUgKGUpIHtcbiAgICBpZiAoZSA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZSA9IGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydHMub3B0aW9uID0ge307XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBib29sZWFuXG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtCb29sZWFufSBib29sXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgbnVtYmVyXG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybnMge051bWJlcn0gbnVtYmVyXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKSB8fCBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nIHwgZnVuY3Rpb24gfCB1bmRlZmluZWR9IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlZmF1bHRWYWx1ZV1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0clxuICovXG5leHBvcnRzLm9wdGlvbi5hc1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBzaXplIG9yIGxvY2F0aW9uIGludG8gYSBzdHJpbmcgd2l0aCBwaXhlbHMgb3IgYSBwZXJjZW50YWdlXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlciB8IGZ1bmN0aW9uIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IFtkZWZhdWx0VmFsdWVdXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzaXplXG4gKi9cbmV4cG9ydHMub3B0aW9uLmFzU2l6ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuXG4gIGlmIChleHBvcnRzLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBlbHNlIGlmIChleHBvcnRzLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBmdW5jdGlvbiB8IHVuZGVmaW5lZH0gdmFsdWVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtkZWZhdWx0VmFsdWVdXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfSBkb21cbiAqL1xuZXhwb3J0cy5vcHRpb24uYXNFbGVtZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlIHx8IGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU2MjM4MzgvcmdiLXRvLWhleC1hbmQtaGV4LXRvLXJnYlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXhcbiAqIEByZXR1cm5zIHt7cjogKiwgZzogKiwgYjogKn19IHwgMjU1IHJhbmdlXG4gKi9cbmV4cG9ydHMuaGV4VG9SR0IgPSBmdW5jdGlvbiAoaGV4KSB7XG4gIC8vIEV4cGFuZCBzaG9ydGhhbmQgZm9ybSAoZS5nLiBcIjAzRlwiKSB0byBmdWxsIGZvcm0gKGUuZy4gXCIwMDMzRkZcIilcbiAgdmFyIHNob3J0aGFuZFJlZ2V4ID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTtcbiAgaGV4ID0gaGV4LnJlcGxhY2Uoc2hvcnRoYW5kUmVnZXgsIGZ1bmN0aW9uIChtLCByLCBnLCBiKSB7XG4gICAgcmV0dXJuIHIgKyByICsgZyArIGcgKyBiICsgYjtcbiAgfSk7XG4gIHZhciByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICByOiBwYXJzZUludChyZXN1bHRbMV0sIDE2KSxcbiAgICBnOiBwYXJzZUludChyZXN1bHRbMl0sIDE2KSxcbiAgICBiOiBwYXJzZUludChyZXN1bHRbM10sIDE2KVxuICB9IDogbnVsbDtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBjb2xvciBpbiBoZXggZm9ybWF0IG9yIHJnYigpIG9yIHJnYmEoKSBmb3JtYXQgYW5kIG92ZXJyaWRlcyB0aGUgb3BhY2l0eS4gUmV0dXJucyByZ2JhKCkgc3RyaW5nLlxuICogQHBhcmFtIGNvbG9yXG4gKiBAcGFyYW0gb3BhY2l0eVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMub3ZlcnJpZGVPcGFjaXR5ID0gZnVuY3Rpb24gKGNvbG9yLCBvcGFjaXR5KSB7XG4gIGlmIChjb2xvci5pbmRleE9mKFwicmdiYVwiKSAhPSAtMSkge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuICBlbHNlIGlmIChjb2xvci5pbmRleE9mKFwicmdiXCIpICE9IC0xKSB7XG4gICAgdmFyIHJnYiA9IGNvbG9yLnN1YnN0cihjb2xvci5pbmRleE9mKFwiKFwiKSArIDEpLnJlcGxhY2UoXCIpXCIsIFwiXCIpLnNwbGl0KFwiLFwiKTtcbiAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiWzBdICsgXCIsXCIgKyByZ2JbMV0gKyBcIixcIiArIHJnYlsyXSArIFwiLFwiICsgb3BhY2l0eSArIFwiKVwiXG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHJnYiA9IGV4cG9ydHMuaGV4VG9SR0IoY29sb3IpO1xuICAgIGlmIChyZ2IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBcInJnYmEoXCIgKyByZ2IuciArIFwiLFwiICsgcmdiLmcgKyBcIixcIiArIHJnYi5iICsgXCIsXCIgKyBvcGFjaXR5ICsgXCIpXCJcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHJlZCAgICAgMCAtLSAyNTVcbiAqIEBwYXJhbSBncmVlbiAgIDAgLS0gMjU1XG4gKiBAcGFyYW0gYmx1ZSAgICAwIC0tIDI1NVxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnRzLlJHQlRvSGV4ID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUpIHtcbiAgcmV0dXJuIFwiI1wiICsgKCgxIDw8IDI0KSArIChyZWQgPDwgMTYpICsgKGdyZWVuIDw8IDgpICsgYmx1ZSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGNvbG9yIHByb3BlcnR5IGludG8gYW4gb2JqZWN0IHdpdGggYm9yZGVyLCBiYWNrZ3JvdW5kLCBhbmRcbiAqIGhpZ2hsaWdodCBjb2xvcnNcbiAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nfSBjb2xvclxuICogQHJldHVybiB7T2JqZWN0fSBjb2xvck9iamVjdFxuICovXG5leHBvcnRzLnBhcnNlQ29sb3IgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgdmFyIGM7XG4gIGlmIChleHBvcnRzLmlzU3RyaW5nKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgIGlmIChleHBvcnRzLmlzVmFsaWRSR0IoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICB2YXIgcmdiID0gY29sb3Iuc3Vic3RyKDQpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA1KS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHBhcnNlSW50KHZhbHVlKSB9KTtcbiAgICAgIGNvbG9yID0gZXhwb3J0cy5SR0JUb0hleChyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdKTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMuaXNWYWxpZEhleChjb2xvcikgPT09IHRydWUpIHtcbiAgICAgIHZhciBoc3YgPSBleHBvcnRzLmhleFRvSFNWKGNvbG9yKTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIU1YgPSB7IGg6IGhzdi5oLCBzOiBoc3YucyAqIDAuOCwgdjogTWF0aC5taW4oMSwgaHN2LnYgKiAxLjAyKSB9O1xuICAgICAgdmFyIGRhcmtlckNvbG9ySFNWID0geyBoOiBoc3YuaCwgczogTWF0aC5taW4oMSwgaHN2LnMgKiAxLjI1KSwgdjogaHN2LnYgKiAwLjggfTtcbiAgICAgIHZhciBkYXJrZXJDb2xvckhleCA9IGV4cG9ydHMuSFNWVG9IZXgoZGFya2VyQ29sb3JIU1YuaCwgZGFya2VyQ29sb3JIU1YucywgZGFya2VyQ29sb3JIU1Yudik7XG4gICAgICB2YXIgbGlnaHRlckNvbG9ySGV4ID0gZXhwb3J0cy5IU1ZUb0hleChsaWdodGVyQ29sb3JIU1YuaCwgbGlnaHRlckNvbG9ySFNWLnMsIGxpZ2h0ZXJDb2xvckhTVi52KTtcbiAgICAgIGMgPSB7XG4gICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLFxuICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4LFxuICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBsaWdodGVyQ29sb3JIZXgsXG4gICAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleFxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcbiAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYyA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogY29sb3IsXG4gICAgICAgIGJvcmRlcjogY29sb3IsXG4gICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLFxuICAgICAgICAgIGJvcmRlcjogY29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvcixcbiAgICAgICAgICBib3JkZXI6IGNvbG9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGMgPSB7fTtcbiAgICBjLmJhY2tncm91bmQgPSBjb2xvci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZDtcbiAgICBjLmJvcmRlciA9IGNvbG9yLmJvcmRlciB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhjb2xvci5oaWdobGlnaHQpKSB7XG4gICAgICBjLmhpZ2hsaWdodCA9IHtcbiAgICAgICAgYm9yZGVyOiBjb2xvci5oaWdobGlnaHQsXG4gICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLmhpZ2hsaWdodFxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGMuaGlnaGxpZ2h0ID0ge307XG4gICAgICBjLmhpZ2hsaWdodC5iYWNrZ3JvdW5kID0gY29sb3IuaGlnaGxpZ2h0ICYmIGNvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZDtcbiAgICAgIGMuaGlnaGxpZ2h0LmJvcmRlciA9IGNvbG9yLmhpZ2hsaWdodCAmJiBjb2xvci5oaWdobGlnaHQuYm9yZGVyIHx8IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZXhwb3J0cy5pc1N0cmluZyhjb2xvci5ob3ZlcikpIHtcbiAgICAgIGMuaG92ZXIgPSB7XG4gICAgICAgIGJvcmRlcjogY29sb3IuaG92ZXIsXG4gICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLmhvdmVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYy5ob3ZlciA9IHt9O1xuICAgICAgYy5ob3Zlci5iYWNrZ3JvdW5kID0gY29sb3IuaG92ZXIgJiYgY29sb3IuaG92ZXIuYmFja2dyb3VuZCB8fCB1bmRlZmluZWQ7XG4gICAgICBjLmhvdmVyLmJvcmRlciA9IGNvbG9yLmhvdmVyICYmIGNvbG9yLmhvdmVyLmJvcmRlciB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGM7XG59O1xuXG5cblxuLyoqXG4gKiBodHRwOi8vd3d3LmphdmFzY3JpcHRlci5uZXQvZmFxL3JnYjJoc3YuaHRtXG4gKlxuICogQHBhcmFtIHJlZFxuICogQHBhcmFtIGdyZWVuXG4gKiBAcGFyYW0gYmx1ZVxuICogQHJldHVybnMgeyp9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0cy5SR0JUb0hTViA9IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlKSB7XG4gIHJlZCA9IHJlZCAvIDI1NTsgZ3JlZW4gPSBncmVlbiAvIDI1NTsgYmx1ZSA9IGJsdWUgLyAyNTU7XG4gIHZhciBtaW5SR0IgPSBNYXRoLm1pbihyZWQsIE1hdGgubWluKGdyZWVuLCBibHVlKSk7XG4gIHZhciBtYXhSR0IgPSBNYXRoLm1heChyZWQsIE1hdGgubWF4KGdyZWVuLCBibHVlKSk7XG5cbiAgLy8gQmxhY2stZ3JheS13aGl0ZVxuICBpZiAobWluUkdCID09IG1heFJHQikge1xuICAgIHJldHVybiB7IGg6IDAsIHM6IDAsIHY6IG1pblJHQiB9O1xuICB9XG5cbiAgLy8gQ29sb3JzIG90aGVyIHRoYW4gYmxhY2stZ3JheS13aGl0ZTpcbiAgdmFyIGQgPSAocmVkID09IG1pblJHQikgPyBncmVlbiAtIGJsdWUgOiAoKGJsdWUgPT0gbWluUkdCKSA/IHJlZCAtIGdyZWVuIDogYmx1ZSAtIHJlZCk7XG4gIHZhciBoID0gKHJlZCA9PSBtaW5SR0IpID8gMyA6ICgoYmx1ZSA9PSBtaW5SR0IpID8gMSA6IDUpO1xuICB2YXIgaHVlID0gNjAgKiAoaCAtIGQgLyAobWF4UkdCIC0gbWluUkdCKSkgLyAzNjA7XG4gIHZhciBzYXR1cmF0aW9uID0gKG1heFJHQiAtIG1pblJHQikgLyBtYXhSR0I7XG4gIHZhciB2YWx1ZSA9IG1heFJHQjtcbiAgcmV0dXJuIHsgaDogaHVlLCBzOiBzYXR1cmF0aW9uLCB2OiB2YWx1ZSB9O1xufTtcblxudmFyIGNzc1V0aWwgPSB7XG4gIC8vIHNwbGl0IGEgc3RyaW5nIHdpdGggY3NzIHN0eWxlcyBpbnRvIGFuIG9iamVjdCB3aXRoIGtleS92YWx1ZXNcbiAgc3BsaXQ6IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgdmFyIHN0eWxlcyA9IHt9O1xuXG4gICAgY3NzVGV4dC5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICBpZiAoc3R5bGUudHJpbSgpICE9ICcnKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHN0eWxlLnNwbGl0KCc6Jyk7XG4gICAgICAgIHZhciBrZXkgPSBwYXJ0c1swXS50cmltKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzWzFdLnRyaW0oKTtcbiAgICAgICAgc3R5bGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sXG5cbiAgLy8gYnVpbGQgYSBjc3MgdGV4dCBzdHJpbmcgZnJvbSBhbiBvYmplY3Qgd2l0aCBrZXkvdmFsdWVzXG4gIGpvaW46IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3R5bGVzKVxuICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgKyAnOiAnICsgc3R5bGVzW2tleV07XG4gICAgICB9KVxuICAgICAgLmpvaW4oJzsgJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwZW5kIGEgc3RyaW5nIHdpdGggY3NzIHN0eWxlcyB0byBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjc3NUZXh0XG4gKi9cbmV4cG9ydHMuYWRkQ3NzVGV4dCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjc3NUZXh0KSB7XG4gIHZhciBjdXJyZW50U3R5bGVzID0gY3NzVXRpbC5zcGxpdChlbGVtZW50LnN0eWxlLmNzc1RleHQpO1xuICB2YXIgbmV3U3R5bGVzID0gY3NzVXRpbC5zcGxpdChjc3NUZXh0KTtcbiAgdmFyIHN0eWxlcyA9IGV4cG9ydHMuZXh0ZW5kKGN1cnJlbnRTdHlsZXMsIG5ld1N0eWxlcyk7XG5cbiAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gY3NzVXRpbC5qb2luKHN0eWxlcyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHN0cmluZyB3aXRoIGNzcyBzdHlsZXMgZnJvbSBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjc3NUZXh0XG4gKi9cbmV4cG9ydHMucmVtb3ZlQ3NzVGV4dCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjc3NUZXh0KSB7XG4gIHZhciBzdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGVsZW1lbnQuc3R5bGUuY3NzVGV4dCk7XG4gIHZhciByZW1vdmVTdHlsZXMgPSBjc3NVdGlsLnNwbGl0KGNzc1RleHQpO1xuXG4gIGZvciAodmFyIGtleSBpbiByZW1vdmVTdHlsZXMpIHtcbiAgICBpZiAocmVtb3ZlU3R5bGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGRlbGV0ZSBzdHlsZXNba2V5XTtcbiAgICB9XG4gIH1cblxuICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBjc3NVdGlsLmpvaW4oc3R5bGVzKTtcbn07XG5cbi8qKlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWppamFja3Nvbi81MzExMjU2XG4gKiBAcGFyYW0gaFxuICogQHBhcmFtIHNcbiAqIEBwYXJhbSB2XG4gKiBAcmV0dXJucyB7e3I6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXJ9fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydHMuSFNWVG9SR0IgPSBmdW5jdGlvbiAoaCwgcywgdikge1xuICB2YXIgciwgZywgYjtcblxuICB2YXIgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICB2YXIgZiA9IGggKiA2IC0gaTtcbiAgdmFyIHAgPSB2ICogKDEgLSBzKTtcbiAgdmFyIHEgPSB2ICogKDEgLSBmICogcyk7XG4gIHZhciB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpO1xuXG4gIHN3aXRjaCAoaSAlIDYpIHtcbiAgICBjYXNlIDA6IHIgPSB2LCBnID0gdCwgYiA9IHA7IGJyZWFrO1xuICAgIGNhc2UgMTogciA9IHEsIGcgPSB2LCBiID0gcDsgYnJlYWs7XG4gICAgY2FzZSAyOiByID0gcCwgZyA9IHYsIGIgPSB0OyBicmVhaztcbiAgICBjYXNlIDM6IHIgPSBwLCBnID0gcSwgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNDogciA9IHQsIGcgPSBwLCBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA1OiByID0gdiwgZyA9IHAsIGIgPSBxOyBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7IHI6IE1hdGguZmxvb3IociAqIDI1NSksIGc6IE1hdGguZmxvb3IoZyAqIDI1NSksIGI6IE1hdGguZmxvb3IoYiAqIDI1NSkgfTtcbn07XG5cbmV4cG9ydHMuSFNWVG9IZXggPSBmdW5jdGlvbiAoaCwgcywgdikge1xuICB2YXIgcmdiID0gZXhwb3J0cy5IU1ZUb1JHQihoLCBzLCB2KTtcbiAgcmV0dXJuIGV4cG9ydHMuUkdCVG9IZXgocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59O1xuXG5leHBvcnRzLmhleFRvSFNWID0gZnVuY3Rpb24gKGhleCkge1xuICB2YXIgcmdiID0gZXhwb3J0cy5oZXhUb1JHQihoZXgpO1xuICByZXR1cm4gZXhwb3J0cy5SR0JUb0hTVihyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbn07XG5cbmV4cG9ydHMuaXNWYWxpZEhleCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgdmFyIGlzT2sgPSAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChoZXgpO1xuICByZXR1cm4gaXNPaztcbn07XG5cbmV4cG9ydHMuaXNWYWxpZFJHQiA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgcmdiID0gcmdiLnJlcGxhY2UoXCIgXCIsIFwiXCIpO1xuICB2YXIgaXNPayA9IC9yZ2JcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KVxcKS9pLnRlc3QocmdiKTtcbiAgcmV0dXJuIGlzT2s7XG59XG5leHBvcnRzLmlzVmFsaWRSR0JBID0gZnVuY3Rpb24gKHJnYmEpIHtcbiAgcmdiYSA9IHJnYmEucmVwbGFjZShcIiBcIiwgXCJcIik7XG4gIHZhciBpc09rID0gL3JnYmFcXCgoXFxkezEsM30pLChcXGR7MSwzfSksKFxcZHsxLDN9KSwoLnsxLDN9KVxcKS9pLnRlc3QocmdiYSk7XG4gIHJldHVybiBpc09rO1xufVxuXG4vKipcbiAqIFRoaXMgcmVjdXJzaXZlbHkgcmVkaXJlY3RzIHRoZSBwcm90b3R5cGUgb2YgSlNPTiBvYmplY3RzIHRvIHRoZSByZWZlcmVuY2VPYmplY3RcbiAqIFRoaXMgaXMgdXNlZCBmb3IgZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSByZWZlcmVuY2VPYmplY3RcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnRzLnNlbGVjdGl2ZUJyaWRnZU9iamVjdCA9IGZ1bmN0aW9uIChmaWVsZHMsIHJlZmVyZW5jZU9iamVjdCkge1xuICBpZiAodHlwZW9mIHJlZmVyZW5jZU9iamVjdCA9PSBcIm9iamVjdFwiKSB7XG4gICAgdmFyIG9iamVjdFRvID0gT2JqZWN0LmNyZWF0ZShyZWZlcmVuY2VPYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVmZXJlbmNlT2JqZWN0Lmhhc093blByb3BlcnR5KGZpZWxkc1tpXSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZlcmVuY2VPYmplY3RbZmllbGRzW2ldXSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgb2JqZWN0VG9bZmllbGRzW2ldXSA9IGV4cG9ydHMuYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdFtmaWVsZHNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0VG87XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyByZWN1cnNpdmVseSByZWRpcmVjdHMgdGhlIHByb3RvdHlwZSBvZiBKU09OIG9iamVjdHMgdG8gdGhlIHJlZmVyZW5jZU9iamVjdFxuICogVGhpcyBpcyB1c2VkIGZvciBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHJlZmVyZW5jZU9iamVjdFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydHMuYnJpZGdlT2JqZWN0ID0gZnVuY3Rpb24gKHJlZmVyZW5jZU9iamVjdCkge1xuICBpZiAodHlwZW9mIHJlZmVyZW5jZU9iamVjdCA9PSBcIm9iamVjdFwiKSB7XG4gICAgdmFyIG9iamVjdFRvID0gT2JqZWN0LmNyZWF0ZShyZWZlcmVuY2VPYmplY3QpO1xuICAgIGZvciAodmFyIGkgaW4gcmVmZXJlbmNlT2JqZWN0KSB7XG4gICAgICBpZiAocmVmZXJlbmNlT2JqZWN0Lmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmZXJlbmNlT2JqZWN0W2ldID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBvYmplY3RUb1tpXSA9IGV4cG9ydHMuYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFRvO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5cbi8qKlxuICogdGhpcyBpcyB1c2VkIHRvIHNldCB0aGUgb3B0aW9ucyBvZiBzdWJvYmplY3RzIGluIHRoZSBvcHRpb25zIG9iamVjdC4gQSByZXF1aXJlbWVudCBvZiB0aGVzZSBzdWJvYmplY3RzXG4gKiBpcyB0aGF0IHRoZXkgaGF2ZSBhbiAnZW5hYmxlZCcgZWxlbWVudCB3aGljaCBpcyBvcHRpb25hbCBmb3IgdGhlIHVzZXIgYnV0IG1hbmRhdG9yeSBmb3IgdGhlIHByb2dyYW0uXG4gKlxuICogQHBhcmFtIFtvYmplY3RdIG1lcmdlVGFyZ2V0IHwgdGhpcyBpcyBlaXRoZXIgdGhpcy5vcHRpb25zIG9yIHRoZSBvcHRpb25zIHVzZWQgZm9yIHRoZSBncm91cHMuXG4gKiBAcGFyYW0gW29iamVjdF0gb3B0aW9ucyAgICAgfCBvcHRpb25zXG4gKiBAcGFyYW0gW1N0cmluZ10gb3B0aW9uICAgICAgfCB0aGlzIGlzIHRoZSBvcHRpb24ga2V5IGluIHRoZSBvcHRpb25zIGFyZ3VtZW50XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChtZXJnZVRhcmdldCwgb3B0aW9ucywgb3B0aW9uLCBhbGxvd0RlbGV0aW9uID0gZmFsc2UsIGdsb2JhbE9wdGlvbnMgPSB7fSkge1xuICBpZiAob3B0aW9uc1tvcHRpb25dID09PSBudWxsKSB7XG4gICAgbWVyZ2VUYXJnZXRbb3B0aW9uXSA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsT3B0aW9uc1tvcHRpb25dKTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAob3B0aW9uc1tvcHRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1tvcHRpb25dID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zW29wdGlvbl0uZW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgICAgIGlmIChvcHRpb25zW29wdGlvbl0uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIG1lcmdlVGFyZ2V0W29wdGlvbl1bcHJvcF0gPSBvcHRpb25zW29wdGlvbl1bcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgYSBiaW5hcnkgc2VhcmNoIGZvciBhIHZpc2libGUgaXRlbSBpbiBhIHNvcnRlZCBsaXN0LiBJZiB3ZSBmaW5kIGEgdmlzaWJsZSBpdGVtLCB0aGUgY29kZSB0aGF0IHVzZXNcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCB0aGVuIGl0ZXJhdGUgaW4gYm90aCBkaXJlY3Rpb25zIG92ZXIgdGhpcyBzb3J0ZWQgbGlzdCB0byBmaW5kIGFsbCB2aXNpYmxlIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7SXRlbVtdfSBvcmRlcmVkSXRlbXMgICAgICAgfCBJdGVtcyBvcmRlcmVkIGJ5IHN0YXJ0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzZWFyY2hGdW5jdGlvbiAgIHwgLTEgaXMgbG93ZXIsIDAgaXMgZm91bmQsIDEgaXMgaGlnaGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZDJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmFyeVNlYXJjaEN1c3RvbSA9IGZ1bmN0aW9uIChvcmRlcmVkSXRlbXMsIHNlYXJjaEZ1bmN0aW9uLCBmaWVsZCwgZmllbGQyKSB7XG4gIHZhciBtYXhJdGVyYXRpb25zID0gMTAwMDA7XG4gIHZhciBpdGVyYXRpb24gPSAwO1xuICB2YXIgbG93ID0gMDtcbiAgdmFyIGhpZ2ggPSBvcmRlcmVkSXRlbXMubGVuZ3RoIC0gMTtcblxuICB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucykge1xuICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuXG4gICAgdmFyIGl0ZW0gPSBvcmRlcmVkSXRlbXNbbWlkZGxlXTtcbiAgICB2YXIgdmFsdWUgPSAoZmllbGQyID09PSB1bmRlZmluZWQpID8gaXRlbVtmaWVsZF0gOiBpdGVtW2ZpZWxkXVtmaWVsZDJdO1xuXG4gICAgdmFyIHNlYXJjaFJlc3VsdCA9IHNlYXJjaEZ1bmN0aW9uKHZhbHVlKTtcbiAgICBpZiAoc2VhcmNoUmVzdWx0ID09IDApIHsgLy8gamloYWEsIGZvdW5kIGEgdmlzaWJsZSBpdGVtIVxuICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VhcmNoUmVzdWx0ID09IC0xKSB7ICAvLyBpdCBpcyB0b28gc21hbGwgLS0+IGluY3JlYXNlIGxvd1xuICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICB9XG4gICAgZWxzZSB7ICAvLyBpdCBpcyB0b28gYmlnIC0tPiBkZWNyZWFzZSBoaWdoXG4gICAgICBoaWdoID0gbWlkZGxlIC0gMTtcbiAgICB9XG5cbiAgICBpdGVyYXRpb24rKztcbiAgfVxuXG4gIHJldHVybiAtMTtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIGEgYmluYXJ5IHNlYXJjaCBmb3IgYSBzcGVjaWZpYyB2YWx1ZSBpbiBhIHNvcnRlZCBhcnJheS4gSWYgaXQgZG9lcyBub3QgZXhpc3QgYnV0IGlzIGluIGJldHdlZW4gb2ZcbiAqIHR3byB2YWx1ZXMsIHdlIHJldHVybiBlaXRoZXIgdGhlIG9uZSBiZWZvcmUgb3IgdGhlIG9uZSBhZnRlciwgZGVwZW5kaW5nIG9uIHVzZXIgaW5wdXRcbiAqIElmIGl0IGlzIGZvdW5kLCB3ZSByZXR1cm4gdGhlIGluZGV4LCBlbHNlIC0xLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG9yZGVyZWRJdGVtc1xuICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHNpZGVQcmVmZXJlbmNlICAgJ2JlZm9yZScgb3IgJ2FmdGVyJ1xuICogQHJldHVybnMge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmluYXJ5U2VhcmNoVmFsdWUgPSBmdW5jdGlvbiAob3JkZXJlZEl0ZW1zLCB0YXJnZXQsIGZpZWxkLCBzaWRlUHJlZmVyZW5jZSkge1xuICB2YXIgbWF4SXRlcmF0aW9ucyA9IDEwMDAwO1xuICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgdmFyIGxvdyA9IDA7XG4gIHZhciBoaWdoID0gb3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDE7XG4gIHZhciBwcmV2VmFsdWUsIHZhbHVlLCBuZXh0VmFsdWUsIG1pZGRsZTtcblxuICB3aGlsZSAobG93IDw9IGhpZ2ggJiYgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9ucykge1xuICAgIC8vIGdldCBhIG5ldyBndWVzc1xuICAgIG1pZGRsZSA9IE1hdGguZmxvb3IoMC41ICogKGhpZ2ggKyBsb3cpKTtcbiAgICBwcmV2VmFsdWUgPSBvcmRlcmVkSXRlbXNbTWF0aC5tYXgoMCwgbWlkZGxlIC0gMSldW2ZpZWxkXTtcbiAgICB2YWx1ZSA9IG9yZGVyZWRJdGVtc1ttaWRkbGVdW2ZpZWxkXTtcbiAgICBuZXh0VmFsdWUgPSBvcmRlcmVkSXRlbXNbTWF0aC5taW4ob3JkZXJlZEl0ZW1zLmxlbmd0aCAtIDEsIG1pZGRsZSArIDEpXVtmaWVsZF07XG5cbiAgICBpZiAodmFsdWUgPT0gdGFyZ2V0KSB7IC8vIHdlIGZvdW5kIHRoZSB0YXJnZXRcbiAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByZXZWYWx1ZSA8IHRhcmdldCAmJiB2YWx1ZSA+IHRhcmdldCkgeyAgLy8gdGFyZ2V0IGlzIGluIGJldHdlZW4gb2YgdGhlIHByZXZpb3VzIGFuZCB0aGUgY3VycmVudFxuICAgICAgcmV0dXJuIHNpZGVQcmVmZXJlbmNlID09ICdiZWZvcmUnID8gTWF0aC5tYXgoMCwgbWlkZGxlIC0gMSkgOiBtaWRkbGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlIDwgdGFyZ2V0ICYmIG5leHRWYWx1ZSA+IHRhcmdldCkgeyAvLyB0YXJnZXQgaXMgaW4gYmV0d2VlbiBvZiB0aGUgY3VycmVudCBhbmQgdGhlIG5leHRcbiAgICAgIHJldHVybiBzaWRlUHJlZmVyZW5jZSA9PSAnYmVmb3JlJyA/IG1pZGRsZSA6IE1hdGgubWluKG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxLCBtaWRkbGUgKyAxKTtcbiAgICB9XG4gICAgZWxzZSB7ICAvLyBkaWRudCBmaW5kIHRoZSB0YXJnZXQsIHdlIG5lZWQgdG8gY2hhbmdlIG91ciBib3VuZGFyaWVzLlxuICAgICAgaWYgKHZhbHVlIDwgdGFyZ2V0KSB7IC8vIGl0IGlzIHRvbyBzbWFsbCAtLT4gaW5jcmVhc2UgbG93XG4gICAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgICB9XG4gICAgICBlbHNlIHsgIC8vIGl0IGlzIHRvbyBiaWcgLS0+IGRlY3JlYXNlIGhpZ2hcbiAgICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZXJhdGlvbisrO1xuICB9XG5cbiAgLy8gZGlkbnQgZmluZCBhbnl0aGluZy4gUmV0dXJuIC0xLlxuICByZXR1cm4gLTE7XG59O1xuXG4vKlxuICogRWFzaW5nIEZ1bmN0aW9ucyAtIGluc3BpcmVkIGZyb20gaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXG4gKiBvbmx5IGNvbnNpZGVyaW5nIHRoZSB0IHZhbHVlIGZvciB0aGUgcmFuZ2UgWzAsIDFdID0+IFswLCAxXVxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTRcbiAqL1xuZXhwb3J0cy5lYXNpbmdGdW5jdGlvbnMgPSB7XG4gIC8vIG5vIGVhc2luZywgbm8gYWNjZWxlcmF0aW9uXG4gIGxpbmVhcjogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdFxuICB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJblF1YWQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiB0XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogKDIgLSB0KVxuICB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHRcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0XG4gIH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRDdWJpYzogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gKC0tdCkgKiB0ICogdCArIDFcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0IDwgLjUgPyA0ICogdCAqIHQgKiB0IDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxXG4gIH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHRcbiAgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dFF1YXJ0OiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiAxIC0gKC0tdCkgKiB0ICogdCAqIHRcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0IDwgLjUgPyA4ICogdCAqIHQgKiB0ICogdCA6IDEgLSA4ICogKC0tdCkgKiB0ICogdCAqIHRcbiAgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWludDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHRcbiAgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dFF1aW50OiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiAxICsgKC0tdCkgKiB0ICogdCAqIHQgKiB0XG4gIH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRRdWludDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IC41ID8gMTYgKiB0ICogdCAqIHQgKiB0ICogdCA6IDEgKyAxNiAqICgtLXQpICogdCAqIHQgKiB0ICogdFxuICB9XG59O1xuIl19
},{"./module/moment":20,"./module/uuid":21}]},{},[1])(1)
});